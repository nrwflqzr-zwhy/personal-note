# C++ 笔记

[TOC]



# 第 O 部分 开篇！

## 第一章 开始

### 1.1 编写一个简单的C++程序

一个函数的定义包含4部分：

- 返回类型
- 函数名
- 形参列表（允许为空）
- 函数体

### 1.2 初始输入输出

### 1.3 注释简介

```c++
/*
*
*/

//
```

### 1.4 控制流

#### 1.4.1 while

#### 1.4.2 for

#### 1.4.4 if 语句



### 1.5 类简介

成员函数是定义为类的一部分的函数，有时也被称为方法

### 1.6 书店程序

------

# 第 I 部分 C++基础

- 整型、字符型等内置类型
- 变量，用来为对象命名
- 表达式和语句，用于操纵上述数据类型的具体值
- if或while等控制结构，这些结构允许我们有选择地执行一些语句或者重复地执行一些语句
- 函数，用于定义可供随时调用的计算单元

## 第二章 变量和基本类型

### 2.1 基本内置类型

**算数类型**和**空类型**

#### 2.1.1 算数类型

|    类型     |                |     长度     |
| :---------: | :------------: | :----------: |
|    bool     |    布尔类型    |    未定义    |
|    char     |      字符      |     8位      |
|   wchar_t   |     宽字符     |     16位     |
|  char16_t   |  Unicode 字符  |     16位     |
|  char32_t   |  Unicode 字符  |     32位     |
|    short    |     短整型     |     16位     |
|     int     |      整型      |     16位     |
|    long     |     长整型     |     32位     |
|  long long  |     长整型     |     64位     |
|    float    |  单精度浮点数  | 6位有效数字  |
|   double    |  双精度浮点数  | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

#### 2.1.2 类型转换

类型所能表示的值的范围决定了转换的过程：

- 当我们把一个非布尔类型的算术值赋值给布尔类型时，初始值为0则结果为false，否则结果为true
- 当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1
- 当我们把一个浮点数赋给整数类型时，进行了近似处理，结果值仅保留整数部分（直接截断）
- 当我们赋给无符号类型一个超出他表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数
- 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）

#### 2.1.3 字面值常量

字面值常亮的形式和值决定了它的数据类型

```c++
'a'  //字符字面值
"aaa" //字符串字面值
```

| 名称           | 符号 |
| -------------- | ---- |
| 换行符         | \n   |
| 横向制表符     | \t   |
| 报警（响铃）符 | \a   |
| 纵向制表符     | \v   |
| 退格符         | \b   |
| 双引号         | \\"  |
| 反斜线         | \\\  |
| 问号           | \?   |
| 单引号         | \\'  |
| 回车符         | \r   |
| 进纸符         | \f   |

**指定字面值的类型**

<center>字符和字符串字面值</center>

| 前缀 | 含义                            | 类型     |
| ---- | ------------------------------- | -------- |
| u    | Unicode 16 字符                 | char16_t |
| U    | Unicode 32 字符                 | char32_t |
| L    | 宽字符                          | wchar_t  |
| u8   | UTF-8（仅用于字符串字面值常量） | char     |

<center>整型字面值</center>

| 后缀     | 最小匹配类型 |
| -------- | ------------ |
| u or U   | unsigned     |
| l or L   | long         |
| ll or LL | long long    |

<center>浮点型字面值</center>

| 后缀 | 类型        |
| ---- | ----------- |
| f或F | float       |
| l或L | long double |

### 2.2 变量

#### 2.2.1 变量定义

**变量定义的基本形式是：**首先是类型说明符，随后紧跟由一个或多个变量名组成的列表，变量名以逗号分隔，最后以分号结束。

**在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量**

##### 列表初始化

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

用花括号初始化的方式称为**列表初始化**。当用于内置类型的变量时，这种初始化形式用一个重要的特点：如果我们使用列表初始化且初始值存在丢失信息的风险，编译器将报错

```c++
long double ld = 3.13231515151241;
int a{ld}, b = {ld}; //错误，会丢失信息
```

##### 默认初始化

如果定义变量时没有指定初值，则变量被**默认初始化**。默认值由变量类型和定义变量的位置决定。

- 定义在任何函数之外的变量被初始化为0
- 定义在函数体内部的内置类型将不被初始化，一个未被初始化的内置类型变量的值是未定义的，此时访问会引发错误
- 每个类各自决定其初始化对象的方式。
- 一些类要求每个对象都显式初始化，若未初始化将引发错误。

#### 2.2.2 变量声明和定义的关系

为了允许把程序拆分成多个逻辑部分来编写，C++语言支持**分离式编译**机制，允许程序分隔为若干个文件，每个文件可独立编译。

为了支持分离式编译，C++将声明和定义区分开来。

==**声明**==使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明

==**定义**==负责创建与名字关联的实体

如果想声明一个变量而非定义，则可以添加`extern`关键字，不要显式的初始化变量

```c++
extern int  i; //声明 i 而非定义 i
int j; //声明并定义 j
```

任何包含了显式初始化的声明即成为定义，即使添加了`extern`关键字

#### 2.2.3 标识符

C++的标识符由 **字母、数字、下画线**组成，必须以字母或下画线开头。标识符的长度没有限制，但是对大小写字母敏感。

##### 变量命名规范

- 标识符要能体现实际含义
- 变量名一般用小写字符，如index
- 用户自定义的类名一般以大写字母开头
- 如果标识符由多个单词组成，单词见最好有明显区分

#### 2.2.4 名字的作用域

作用域是程序的一部分，在其中名字有其特定的含义，C++中大多数作用域以花括号分隔

### 2.3 复合类型

复合类型是指基于其他类型定义的类型。

#### 2.3.1 引用

**引用**为对象起了另外一个名字，引用类型引用另外一种类型，通常使用`&`符号。

无法将引用重新绑定到另一个对象上，因此==引用必须初始化==

#### 2.3.2 指针

**指针**是指向另外一种类型的复合类型

- 指针本身就是一个对象（这一点和引用不同），允许对指针赋值和拷贝，而且指针的生命周期内可以先后指向几个不同的对象
- 指针无需在定义时赋初值（引用必须初始化），和其他类型一样，如果没有赋初值，将拥有一个不确定的值（非常的危险！）

定义指针类型的方法将声明符写成`*d`的形式

##### 取地址符

获取对象的地址需要使用取地址符 `&`

##### 指针值

指针的值应该处于下列4中状态之一：

- 指向一个对象
- 指向紧邻对象所占空间的下一位置
- 空指针，意味着不指向任何对象
- 无效指针，除上述情况之外的其他值

##### 解引用符

允许使用解引用符`*`来访问指针指向的对象

##### 空指针

空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空

```c++
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL; //需要先 #include cstdlib
```

##### void* 指针

void* 指针是一种特殊的指针，可以存放任意对象的地址，但是我们不知道指向的地址中的数据是什么类型的

能做的操作有：

- 拿它和别的指针比较
- 作为函数的输入输出
- 赋值给另外一个void*指针

### 2.4 const 限定符

==默认状态下，const 对象仅在文件内有效==

编译器编译过程中将const变量替换成对应的值，所以为了执行这一替换编译器必须知道变量的初始值，如果有多个文件，每个使用了const对象的文件都必须访问到它的初始值，所以需要在每一个用到变量的文件中都有对他的定义，所以默认情况下，const对象被设定为仅在文件内有效，避免了对同一变量的重复定义的冲突。

#### 2.4.1 const 的引用

把引用绑定到 const 对象上（对象是 const 的），称之为对常量的引用。对常量的引用不能修改它绑定的对象。

对const的引用可以引用一个非const的对象，只是我们通过该引用认为这个值是const的

#### 2.4.2 指针和const

类似于常量引用，指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。

##### const指针

指针是对象而引用不是，所以允许把指针定义为常量。**常量指针**必须被初始化，而且它的值不能改变。把*放在const关键字之前用以说明指针是一个常量。

```c++
const double *const pip = &pi;  //pip是一个指向常量对象的常量指针
```

#### 2.4.3 <span id="topConst">顶层const </span> 

**顶层const**表示指针本身是个常量，**底层const**表明指针所指的对象是一个常量（这两个概念也可以泛指任意数据类型，例如const int ci = 42 ，此处的const就是顶层const，表明变量本身是个const）。指针类型既可以是顶层const也可以是底层const。

#### 2.4.4 `constexpr`和常量表达式

**常量表达式**是指值不会改变并且在编译过程就能得到计算结果的表达式

字面值属于常量表达式，用常量表达式初始化的`const`对象也是常量表达式

##### `constexpr`变量

C++11中，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化

如果constexpr声明了一个指针，限定符constexpr只对指针有效，与指针所指对象无关

```c++
const int *p = nullptr;
constexpr int *q = nullptr;
二者一个是指向const int 的指针，一个是指向 int 的const 指针
```

### 2.5 处理类型

#### 2.5.1 类型别名

**类型别名**是一个名字，它是某种类型的同义词。

两种方法可以定义类型别名：

- `typedef`关键字

  ```c++
  typedef double wages; //wages是double的同义词
  typedef wages base,*p; //base是double的同义词，p是double*的同义词
  ```

- 别名声明

  ```c++
  using SI = Sales_item; //SI是Sales_item的别名
  ```

#### 2.5.2 auto类型说明符

auto类型说明符，编译器会帮助我们推断表达式所属的类型

#### 2.5.3 decltype类型说明符

decltype的作用是选择并返回操作数的数据类型。编译器分析表达式并得到它的类型，却不实际计算表达式的值。

```c++
decltype(f()) sum = x; //sum的类型就是函数f的返回类型
```

### 2.6 自定义数据结构

#### 预处理器概述

确保头文件多次包含仍能安全工作的常用技术是预处理器。预处理器是在编译之前执行的一段程序，可以部分的改变我们所写的程序。

#include ：当预处理器看到 #include 标记时就会使用指定的头文件的内容代替#include

头文件保护符：头文件保护符依赖于预处理变量。预处理变量有两种状态：

- 已定义
- 未定义

#define ： #define 把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义

#ifdef ： 当且仅当变量已定义时为真

#ifndef ：当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直到遇到#endif指令

```c++
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data{
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
#endif
```

整个程序中的预处理变量必须唯一，一般是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。并且建议全部大写。

## 第三章 字符串、向量和数组

### 3.1 命名空间的using声明

位于头文件的代码一般来说不应该使用using声明

### 3.2 标准库类型 string

==包含string头文件==

#### 3.2.1 定义和初始化 string 对象

| 初始化方式          |                                    |
| ------------------- | ---------------------------------- |
| string s1           | 默认初始化，s1是一个空串           |
| string s2(s1)       | s2是s1的副本                       |
| string s2 = s1      | 等价于s2(s1)                       |
| string s3("value")  | 除了字面值最后的那个空字符外的副本 |
| string s3 = "value" | 同上                               |
| string s4(n, 'c')   | n个字符'c'组成的字符串             |

使用等号（=）初始化一个变量，采用的是**拷贝初始化**；如果不使用等号，则执行的是**直接初始化**

```c++
string s5 = "hi"; //拷贝初始化
string s6("hi");//直接初始化
```

#### 3.2.2 string 对象上的操作

| 操作          |                                                 |
| ------------- | ----------------------------------------------- |
| os << s       | 将s写入到输出流os当中，返回os                   |
| is >> s       | 从is中读取字符串赋给s，字符串以空白分隔，返回is |
| getline(is,s) | 从is中读取一行赋给s，返回is                     |
| s.empty()     | 判断s是否为空                                   |
| s.size()      | 返回s中的子符个数                               |

### 3.3 标准库类型 vector

==头文件 vector==

#### 3.3.2 向vector对象中添加元素

`push_back()`能够向vector尾部添加一个元素，不能以下标形式添加元素

### 3.4 迭代器介绍

#### 3.4.1 使用迭代器

获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。

- begin 成员返回指向第一个元素的迭代器
- end 成员返回指向尾元素下一位置的迭代器（尾后迭代器）

#### 3.4.2 迭代器运算

简单的移动运算例如 +n , -n

迭代器也可以相减，得到的是它们之前的距离

### 3.5 数组

**数组的大小固定，不能随意向数组中增加元素**

#### 3.5.1 定义和初始化内置数组

数组的声明形式如 a[d],其中 a 是数组的名字，d是数组的维度。 d 必须是一个**常量表达式**

默认情况下，数组的元素被默认初始化

##### 字符数组的特殊性

字符数组可以用字符串字面值初始化，一定要注意字符串字面值尾部还有一个空字符，这个空字符也会像字符串其他的字符一样被拷贝到字符数组中去

#### 3.5.3 指针和数组

使用数组的时候编译器一般将其转化为指针

指针也是迭代器

##### 标准库函数begin和end

这两个函数不是成员函数，正确的使用形式如下：

相对于成员函数的概念是相同的

```c++
int ia[] = {0,1,2,3,4};
int *beg = begin(ia);
int *last = end(ia);
```

#### 3.5.4 C风格字符串

C风格字符串不是一种类型，而是一种约定成俗的写法。按此习惯书写的字符串存放在字符数组中并以**空字符结束**

- 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。
- 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象

上述性质反过来不成立，不能使用string对象直接初始化指向字符的指针

```c++
char *str = s; //错误不能直接初始化
const char *str = s.c_str();//正确  结果的类型时const char * 防止我们更改
```

## 第四章 表达式

### 4.1 基础

#### 4.1.1 基本概念

##### 左值和右值

C++的表达式要么是右值，要不然是左值。这两个名词是从C语言继承而来的，原本是为了帮助记忆；左值可以位于赋值语句的左侧，右值则不能；

在C++中：一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象（这就跟之前表达的`左值可以位于赋值语句的左侧`有所不同）。此外虽然某些表达式的求值结果是对象，但它们是右值而非左值。

**当一个对象被用作右值的时候，用的是对象的值（内容）；**

**当对象被用作左值的时候用的是对象的身份（在内存中的位置）**

==一个重要的原则是==在需要右值的地方可以使用左值代替，但是不能把右值当做左值使用。当一个左值被当成右值使用时，实际使用的是他的内容。目前有几种熟悉的运算需要左值：

- 赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也仍然是一个左值
- 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值（要赋给一个指针）
- 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值
- 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值

使用关键字`decltype`的时候，左值和右值也有所不同。表达式的求值结果是左值，decltype作用于该表达式得到一个引用类型。i.e. 若p的类型为int\*，如果decltype(*p)则结果为int&，decltype(&p)则结果为int**.

#### 4.1.3 求值顺序

优先级规定了运算对象的组合方式，但是**不会指明运算对象按什么顺序求值**

```c++
int i = f1() * f2();
```

对于这个式子，我们只知道f1和f2一定会在乘法之前被调用，但是无法知道到底是f1先被调用还是f2先被调用

```c++
int i = 0;
cout << i << "  " << ++i <<endl;  //未定义的 
```

该表达式不知道先执行 i 还是 ++i ，所以此表达式的行为不可预知，因此不论编译器生成什么样的代码程序都是错误的

##### 规定了运算对象求值顺序的运算符

- 逻辑与
- 逻辑或
- 条件运算符
- 逗号运算符

以下两条**经验准则**对书写复合表达式有益：

1. 拿不准的时候用括号强制优先级
2. 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象

### 4.2 算数运算符

### 4.3 逻辑和关系运算符

逻辑与和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为**短路求值**

### 4.4 赋值运算符

赋值运算符的左侧运算对象必须是一个**可修改的左值**

### 4.5 递增递减运算符

这两种运算符必须作用于**左值**运算对象

前置版本将对象本身作为左值返回

后置版本则将对象原始值的副本作为右值返回

> 除非必须，否则不用递增递减运算符的后置版本
>
> 前置版本的递增运算符避免了不必要的工作，它将值加1后直接返回改变了的运算对象。
>
> 后置半年需要将原始值存储下来以便返回这个未修改的内容，如果我们不需要修改前的额值，那么后置版本的操作就是一种浪费

**后置递增运算符的优先级高于解引用运算符**，因此\*pbeg++等价于\*(pbeg++)，因为后置++是返回pbeg的初始值，所以解引用运算符的运算对象是pbeg未增加之前的值

### 4.6 成员访问运算符

**点运算符   .** 和 **箭头运算符 ->**

### 4.7 条件运算符

?: 运算符

### 4.8 位运算符

| 运算符 | 功能   | 用法           |
| ------ | ------ | -------------- |
| ~      | 位求反 | ~expr          |
| <<     | 左移   | expr1 << expr2 |
| >>     | 右移   | expr1 >> xpr2  |
| &      | 位与   | expr & expr    |
| ^      | 位异或 | expr ^ expr    |
| \|     | 位或   | expr \| expr   |

### 4.11 类型转换

**隐式转换：**不需要程序员的介入和了解，自动执行的类型转换

下面的情况，编译器会自动转换运算对象的类型

- 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型
- 在条件中，非布尔值转换成布尔类型
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
- 如果算术运算或关系运算的的运算对象有多种类型，需要转换成同一种类型
- 函数调用时也会发生类型转换

#### 4.11.1 <span id="4.11.1 算术转换">算术转换</span>

**算术转换**的含义是把一种算术类型转换成另一种算数类型

##### 整型提升

**整型提升**负责把小整数类型转换成较大的整数类型

#### 4.11.3 显式转换

#### 命名的强制类型转换

```c++
cast-name<type>(expression):
```

type是转换的目标类型，如果type是引用类型，则结果是**左值**

expression是要转换的值。

cast-name 是 **static_cast、dynamic_cast、const_cast** 和 **reinterpret_cast**

##### static_cast

任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast

当需要把一个较大的算数类型赋值给较小的类型时，static_cast非常有用。此时强制类型转换告诉读者和编译器：我们知道并且不在乎精度的损失

static_cast对于编译器无法自动执行的类型转换也非常有用。例如我们可以使用static_cast找回存在与void*的指针中的值：

```c++
void *p = &d;
double *dp = static_cast<double*>(p);
```

##### const_cast

const_cast只能改变运算对象的底层const

```c++
const char *pc;
char *p =const_cast<char*>(pc); //正确，但是通过p写值是未定义的行为
```

##### reinterpret_cast

reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释

```c++
int *ip;
char *pc = reinterpret_cast<char*>(ip); //这种行为非常危险
```

## 第五章 语句

### 5.1 简单语句

##### 空语句

最简单的语句就是一个 ;

##### 复合语句

复合语句是指用花括号括起来的语句和声明的序列，符合语句也被称作块。

### 5.2 语句作用域

pass;

### 5.3 条件语句

#### 5.3.1 if语句

pass;

#### 5.3.2 switch 语句

swith语句首先对括号里的表达式求值，该表达式紧跟在关键字switch的后面，可以是一个初始化的变量声明。==**表达式的值转换成整数类型，然后与每个case标签的值比较（表达式的值必须可以转换为整数类型）**==；**case标签必须是整型常量表达式**

##### swith内部变量定义

switch的执行流程有可能会跨过某些case标签。那么如果被跨过的标签中有变量的定义怎么办？

答案是：如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法的。

```c++
case true:
	string  file_name;  //错误：控制流绕过一个隐式初始化的变量
	int ival = 0; //错误：控制流绕过一个显式初始化的变量
	int jval; //正确：因为jval没有初始化
	break;
case false:
	//正确：jval虽然在作用域内，但是它没有被初始化
	jval = next_num(); //正确，给jval赋一个值
	if(file_name.empty()) //错误 file_name 在作用域内，但是没有被初始化
        
```

如果需要为某个case分支定义并初始化一个变量，那么应该把变量定义在块内，从而确保后面的所有case标签都在作用域之外。

```c++
case true:
{
    string file_name = getname();//正确
}
case false:

```

### 5.4 迭代语句

#### 5.4.1 while语句

#### 5.4.2 for语句

传统for

范围for

#### 5.4.3 do while 语句

### 5.5 跳转语句

#### 5.5.1 break

#### 5.5.2 continue

#### 5.5.3 goto

### 5.6 try语句块和异常处理

异常处理机制为程序中**异常检测**和**异常处理**这两部分的协作提供支持

异常处理包括

- throw表达式，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发了异常
- try语句块，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句结束。try语句块以关键字try开始，并以一个或多个catch子句结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称为异常处理代码
- 一套异常类，用于在throw表达式和相关的catch子句之间传递异常的具体信息

#### 5.6.1 throw表达式

程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句

```c++
if(i > j){
    throw runtime_error("message");
}
```

抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码

#### 5.6.2 try语句块

```c++
try{
    program-statements
}catch(exception-declaration){  //exception-declaration 是异常声明
    handler-statements
}catch(exception-declaration){
    handler-statements
}// ...
```

#### 5.6.3 标准异常

- exception 头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息
- stdexcept头文件定义了几种常用的异常类。
- new头文件定义了bad_alloc异常类型
- type_info头文件定义了bad_cast异常类型

## 第六章 函数

### 6.1 函数基础

一个典型的函数包括以下几个部分：

- 返回类型
- 函数名字
- 形参列表
- 函数体

通过调用运算符`()`来执行函数

**函数的调用**完成两项工作：

1. 用实参初始化函数对应的形参
2. 将控制权转移给被调用函数

**return语句**完成两项工作：

1. 返回return语句中的值
2. 将控制权转移回主调函数

##### 形参和实参

==实参和形参一一对应，但是并没有规定实参的求值顺序==，编译器能以任意可行的顺序对实参求值。

形参一定会被初始化

#### 6.1.1 局部对象

形参和函数体内部定义的变量统称为局部变量

局部静态对象，在程序的执行路径第一次经过对象定义语句时初始化，并且直到**程序终止**才被销毁

#### 6.1.2 函数声明

函数声明也称作函数原型

函数的声明不包含函数体，所以无须参数的名字。

### 6.2 参数传递

#### 6.2.1 传值参数

#### 6.2.2 传引用参数

**使用引用避免拷贝**，对于大类型对象或容器对象比较有用

#### 6.2.3 const形参和实参

```c++
void fcn(const int i){}
void fcn(int i){}
```

用实参初始化形参时会忽略掉[顶层const](#topConst)，传给该形参的值是不是const的都可以，但是像上述的代码就会出现歧义，所以这样定义是错的

#### 6.2.4 数组形参

不允许拷贝数组以及使用数组时通常会将其转换成指针。

因为数组是以指针形式传递给函数的，所以还需要额外提供数组的尺寸等信息

管理指针形参有三种常用的技术：

1. 使用标记指定数组长度

   要求数组本身包含一个结束标记

2. 使用标准库规范

   传递指向数组首元素和尾后元素的指针

3. 显式传递一个表示数组大小的值

##### 数组引用形参

C++允许将变量定义成数组的引用，所以形参也可以是数组的引用。引用形参绑定到对应的实参上，也就是绑定到数组上

```c++
void print(int (&arr)[10]){
    for (auto elem : arr){
        cout << elem << endl;
    }
}
```

> &arr 两端的括号必不可少
>
> ```c++
> f(int &arr[10])  //错误，将arr声明成了引用的数组
> f(int (&arr)[10])  //正确 arr是具有10个int型数据的数组的引用
> ```

#### 6.2.5 main处理命令行选项

```shell
prog -d -o ofile data0
```

```c++
int main(int argc, char *argv[]){ ... }
int main(int argc, char **argv){ }
```

第二个形参argv是一个数组，他的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符的个数

#### 6.2.6 含有可变形参的函数

C++11 提供了两种主要的方法：

- 如果所有的实参类型相同，可以传递一个名为`initializer_list`的标准库类型
- 如果实参的类型不同，可以编写一种特殊的函数，即可变参数模板（16.4 节介绍）

C++还有一种特殊的形参类型（省略符），可以用它传递可变数量的实参，这种功能一般只用于与C函数交互的接口程序

##### initializer_list

| 操作                                 | 含义                          |
| ------------------------------------ | ----------------------------- |
| initializer_list\<T> list            | 默认初始化：T类型的元素空列表 |
| initializer_list\<T> list{a,b,c,...} | 列表中的元素是const           |
| lst2(lst)                            |                               |
| lst2 = lst                           |                               |
| lst.begin()                          |                               |
| lst.end()                            |                               |

initializer_list 对象中的元素**永远是常量值**，我们无法改变。

##### 省略符形参

省略符形参只能出现在形参列表的最后一个位置

```c++
void foo(parm_list,...);
void foo(...);
```

### 6.3 返回类型和`return`语句

#### 6.3.1 无返回值函数

#### 6.3.2 有返回值函数

返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时两，该临时量就是函数调用的结果

##### 不要返回局部对象的引用或指针

##### 引用返回左值

调用一个返回引用（不能是局部变量的引用）的函数得到左值，其他返回类型得到右值。我们能为返回类型是非常量引用的函数的结果赋值

##### 列表初始化返回值

C++11新标准规定，函数可以返回花括号包围的值的列表

如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间（这个设定很奇怪）。如果函数返回的是类类型，由类本身定义初始值如何使用。

##### 主函数main的返回值

我们允许main函数没有return语句直接结束。如果控制到达了main函数的结尾处而且没有return语句，则隐式插入一条return 0;

#### 6.3.3 返回数组指针

无法返回数组（因为数组无法拷贝），只能返回数组指针

从语法上讲，定义一个返回数组的指针或引用的函数比较繁琐，但是使用类型别名等方法可以简化这一操作

```c++
typedef int arrT[10]; //arrT是一个类型别名，表示的类型是含有10个整数的数组
using arrT = int[10]; //arrT的等价声明
arrT* func(int i); //func返回一个指向含有10个整数的数组的指针
```

##### 声明一个返回数组指针的函数

要想在声明func时不使用类型别名，必须牢记被定义的名字后面数组的维度

```c++
int arr[10]; //arr是含有10个指针的数组
int *p1[10]; //p1是含有10个指针的数组
int (*p2)[10] = &arr; // p2是一个指针，指向含有10个整数的数组
```

与这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后（实际上应该在形参列表之后）

```c++
Type (*function(parameter_list)[dimension]
int (*func(int i))[10]
```

- func(int i) 表明调用func函数需要一个整型值
- (*func(int i)) 意味着我们可以对函数调用的结果执行解引用操作
- (*func(int i))[10] 表示解引用操作将得到一个大小是10的数组
- int (*func(int i))[10] 表示数组中的元素类型是int

##### 使用尾置返回类型

为了表示函数真正的返回类型跟在形参列表之后，我们在返回类型的位置上放一个`auto`

```c++
auto func(int i) -> int(*)[10]; //接受int类型的实参，返回一个指针，指向含有10个整型的数组
```

##### 使用decltype

```c++
int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
decltype(odd) *arrPtr(int i){
    return (i % 2) ? &odd : &even;
}
```

arrPtr使用关键字decltype表示它返回类型是个指针，并且该指针**所指对象**与odd的类型一致。因为odd是数组，所以arrPtr返回指向含有5个整数的数组的指针。decltype并不负责将数组类型转换为相应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时加一个*符号

### 6.4 函数重载

同一作用域几个函数名字相同但是形参列表不同，称之为重载

**不允许两个函数除了返回类型外其他所有的要素都相同**

##### 重载和const形参

顶层const无法实现重载，底层const可以实现重载，我们只能把const对象传递给const形参，当我们传一个非常量对象或者指向非常量对象的指针时，编译器会优先选择非常量版本的函数。

##### const_cast 和重载

下面这个方法返回const string  <span id="shorterString">**shorterString**</span> 

```c++
const string &shorterString(const string &s1, const string &s2){
    return s1.size() < s2.size() ? s1 : s2;
}
```

这个函数的参数和返回类型都是const string 的引用。我们可以对非常量的string实参调用这个方法，但是它返回的仍旧是const string 的引用，这导致我们可能无法修改返回的string。

因此我们需要新的shorterString方法，当它的实参不是常量时，得到的结果是一个普通的引用，使用`const_cast`可以做到

```c++
string &shorterString(string &s1, string &s2){
    auto &r = shorterString(const_cast<const string&>(s1),const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
```

能够得到如下的效果，如果实参是const string引用，那么直接调用const版本，如果不是，那么调用非const版本，此时将一个本来就是非常量的数据（虽然返回的时候是按常量返回的）强制转换成非const是可以接受的。

```c++
const string& shorterString(const string& s1, const string& s2)
{
    cout << "这是 const 版本" << endl;
    return s1.size() < s2.size() ? s1 : s2;
}
string& shorterString(string& s1, string& s2)
{
    cout << "这是非 const 版本" << endl;
    auto& r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
int main(int argc, char const* argv[])
{
    const string s1 = "aaa", s2 = "bbb";
    string s3 = "ccc", s4 = "ddd";
    string s5 = shorterString(s1, s2);
    string s6 = shorterString(s3, s4);
    return 0;
}
//输出结果为
//这是 const 版本
//这是非 const 版本
//这是 const 版本
```

##### 调用重载的函数

**函数匹配（重载确定）**：在这个过程中，我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做重载确定。

我们将在后续[6.6节](#函数匹配)介绍当重载函数参数数量相同且参数类型可以互相转换时编译器的处理方法（因为其余情况都非常好确定）

当调用重载函数时有三种可能的结果：

- 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码
- 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息
- 有多于一个函数可以匹配，但都不是最佳选择。此时也将发生错误，称为二义性调用

#### 6.4.1 重载与作用域

如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体（而不是重载它）。所以在不同的作用域中无法重载函数名。

### 6.5 特殊用途语言特性

#### 6.5.1 默认实参

**一旦某一个形参被赋予了默认值，它后面的所有形参都必须有默认值**

##### 默认实参声明

通常将函数声明放在头文件中，并且一个函数只声明一次。但是多次声明函数也是合法的。需要注意的是在给定的作用域中一个形参只能被赋予一次默认实参。**函数的后续声明只能为之前没有默认值的形参添加默认实参，而且该形参右侧的所有形参都必须有默认值。**

```c++
string screen(sz, sz, char = ' ');
string screen(sz, sz, char = '*');// error 无法修改默认值
string screen(sz, sz = 80, char = ' ')// 正确：添加默认实参
```

##### 默认实参初始值

局部变量不能作为默认实参

#### 6.5.2 内联函数和constexpr函数

##### 内敛函数

对于[shorterString](#shorterString)方法，若定义为内联，如下调用

```c++
cout << shorterString(s1,s2) <<endl;
//将展开为
cout << (s1.size() < s2.size() ? s1 : s2) << endl;
```

##### constexpr函数

constexpr函数是指能用于常量表达式的函数。

- 函数的返回类型及所有形参的类型都得是字面值类型
- 函数体中必须有且只有一条return语句

```c++
constexpr int new_sz(){return 42;}
constexpr int foo = new_sz(); //正确：foo是一个常量表达式
```

constexpr被隐式的指定为内联函数

constexpr函数体内可以包含其他语句，只要这些语句在运行时不执行任何操作就行，例如空语句、类型别名、using声明

允许constexpr函数的返回值为非常量

```c++
constexpr size_t scale(size_t cnt){return new_sz() * cnt;}
int arr[scale(2)]; //正确scale(2)是常量表达式
int i = 2;
int a2[scale(i)]; //错误：scale(i)不是常量表达式
```

当scale的实参是常量表达式时，返回值也是常量表达式；反之则不然

**内联函数和constexpr函数的多个定义必须完全一致**，所以一般定义在头文件中

#### 6.5.3 调试帮助

##### assert预处理宏

assert是一种预处理宏，是一个预处理变量。assert宏使用一个表达式作为它的条件：

```c++
assert(expr);
//首先对expr求值，如果表达式为false，assert输出信息并终止程序的执行，如果表达式为true，assert什么也不做
```

宏名字在程序内必须唯一

##### NDEBUG预处理变量

assert的行为依赖于一个名为NDEBUG的预处理变量。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查

我们可以使用一个 #define 语句定义NDEBUG，从而关闭调试状态。

### 6.6 <span id="函数匹配">函数匹配</span>

**函数匹配的第一步**是选定本次调用对应的重载函数集，集合中的函数称为**候选函数**。候选函数具备两个特征：

- 与被调用函数同名
- 声明在调用点可见

**第二步**考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为**可行函数**。可行函数也具有两个特征

- 形参数量与本次调用提供的实参数量相等
- 每个实参的类型和对应的形参类型相同，或者可以转换为形参的类型

**第三步**从可行函数中选择与本次调用最匹配的函数。逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。

- 该函数每个实参的匹配都不劣于其他可行函数需要的匹配
- 至少有一个实参的匹配优于其他可行函数提供的匹配

如果没有函数脱颖而出则会报错二义性调用

#### 6.6.1 实参类型转换

为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下：

1. 精确匹配
   - 实参类型与形参类型相同
   - 实参从数组类型或函数类型转换成对应的指针类型参见[6.7 函数指针](#函数指针)
   - 向实参添加顶层const或者从实参中删除顶层const（这里应该要保证实参本质上是一个非常量？）
2. 通过const转换实现的匹配
3. 通过类型提升实现的匹配
4. 通过[算术类型](#4.11.1 算术转换)的转换实现的匹配
5. 通过类类型转换实现的匹配（参见[14.9节]()）

##### 类型提升和算术类型转换

所有算术类型转换的级别都一样。例如从int转换为unsigned int 与 int 向 double 的转换时相同的级别。具体例子

```c++
void manip(long);
void manip(float);
manip(3.14);
```

3.14的类型是double，它既能转换为long也能转换为float，所以此时会发生二义性调用错误

##### 函数匹配和const实参

如果重载函数的区别在于它们引用类型的形参是否引用了const，或者指针类型的形参是否指向const，当调用发生时编译器通过实参是否是常量来决定选择哪个函数

### 6.7 函数指针

函数指针指向的是函数而非对象。函数指针也指向特定的类型。**函数的类型由它的返回类型和形参类型共同决定与函数名无关**

```c++
bool lengthCompare(const string &, const string &);
```

该函数的类型是bool (const string &, const string &)。

函数指针声明如下：

```c++
bool (*pf)(const string &, const string &);
//pf指向一个函数，该函数的参数是两个const string 的引用，返回值是bool类型。  pf 两端的括号不能少
```

##### 使用函数指针

将函数名字作为一个值使用，该函数自动地转换成指针，

```c++
pf = lengthCompare;
pf = &lengthCompare; //等价操作

bool b1 = pf("hello","good");
bool b2 = (*pf)("hello","good");
bool b3 = lengthCompare("hello","good");
```

指向不同的函数类型的指针之间不存在转换关系

函数指针也可以赋一个nullptr或者0表示未指向任何函数

##### 重载函数指针

使用重载函数的时候，上下文必须清晰地界定到底该选用哪个函数。

```c++
void ff(int*);
void ff(unsigned int);
void (*pf1)(unsigned int) = ff;//指向ff(unsigned int)

void (*pf2)(int) = ff;//错误，没有ff与形参列表匹配
double (*pf3)(int*) = ff;//错误，没有返回类型与此匹配
```

##### 函数指针形参

与数组类型，虽然不能定义函数类型的形参，但是可以定义指向函数的指针作为形参

```c++
//第三个参数是函数类型，会自动转换成函数指针
void useBigger(const string &s1, const string &s2,
              bool pf(const string &,const string&));
void useBigger(const string &s1, const string &s2,
              bool (*pf)(const string &,const string&));
useBigger(s1,s2,lengthCompare);
```

##### 返回指向函数的指针

虽然无法返回一个函数，但是可以返回指向函数的指针。必须将返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。

```c++
using F = int(int*, int); //F是函数类型，不是指针
using PF = int(*)(int*, int); // PF 是指针类型

PF f1(int); //正确，返回指向函数的指针
F f1(int); //错误，不能返回一个函数
F *f1(int); //正确，显式的声明返回类型是指向函数的指针
```



## 第七章 类

类的基本思想是**数据抽象**和**封装**。

数据抽象是一种依赖于接口和实现的分离式编程技术

### 7.1 定义抽象数据类型

定义在类内部的函数是隐式的inline函数

##### 定义成员函数

成员都必须在类内说明，但是成员函数体可以在类外定义

成员函数通过一个`this`的额外隐式参数来访问调用它的那个对象

##### 引入const成员函数

默认的情况下this的类型是指向类类型非常量版本的常量指针。this同样要遵守初始化规则，这意味着默认情况下我们不能把this绑定到一个常量对象上。这也就使得我们无法在常量对象上调用普通成员函数。

**紧跟在参数列表之后的const表示this是一个指向常量的指针**。像这样使用const的成员函数被称作**常量成员函数**。

```c++
class A{
    public:
    int func() const;
}
```

##### 类作用域和成员函数

编译器分两步处理类：

1. 编译成员的声明
2. 然后才轮到成员函数体

因此成员函数体可以随意使用类中的其他成员而无须在意这些成员的出现顺序

##### 在类的外部定义成员函数

在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。也就是说，返回类型、参数列表和函数名都需保持一致。如果成员被声明成常量成员函数，那么它定义也必须在参数列表后明确指定const属性

#### 7.1.4 构造函数

构造函数的任务是初始化类对象的数据成员，无论何时只要类被创建就会执行构造函数

- 构造函数的名字和类名相同

- 构造函数没有返回类型

- 构造函数不能被声明成const。当我们创建类的一个const对象时，知道构造函数完成初始化过程，对象才能真正取得其常量属性，因此构造函数在const对象的构造过程中可以向其写值。

##### 默认构造函数

没有显式定义构造函数的时候，编译器会隐式的定义一个默认构造函数。编译器创建的构造函数又称为合成的默认构造函数。

- 如果存在类内的初始值，用它来初始化成员
- 否则，默认初始化该成员

对于一个普通的类来说，必须定义它自己的默认构造函数。

- 只有当类没有声明任何构造函数的时候，编译器才会自动地生成默认构造函数
- 对于某些类来说，合成的默认构造函数可能执行错误的操作
- 有时候编译器不能为某些类合成默认的构造函数，比如类中成员是一个类，且该类没有默认构造函数

我们可以使用 <span id="=default">=default</span>的方式定义默认构造函数

```c++
Slaes_data() = default;  //要求编译器生成默认构造函数
```

##### <span id="构造函数初始值列表">构造函数初始值列表</span>

```c++
Sales_data(const std::string &s) : bookNo(s){}
```

冒号和花括号之间的代码负责为新创建的对象的一个或几个数据成员赋初值

#### 7.1.5 拷贝、赋值和析构

如果我们不主动定义这些操作，编译器将会替我们合成

### 7.2 访问控制与封装

访问说明符可以加强类的封装性：

- 定义在public说明符之后的成员在整个程序内可以被访问
- 定义在private说明符之后的成员可以被类的成员函数访问

##### class 和 struct

struct的默认访问权限是public的，class的默认访问权限是private的

#### 7.2.1 友元

类可以允许其他类或者函数访问它的非公有成员，增加一条以friend关键字开始的函数声明

友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限

```c++
friend Sales_data add(const Sales_data&,const Sales_data&);
```

### 7.3 类的其他特性

#### 7.3.1 类成员再探

除了定义数据和函数成员之外，类还可以自定义某种类型在类内的别名

```c++
class Screen{
    public:
    	typedef std::string::size_type pos;
    private:
    	pos cursor = 0;
    	pos height = 0;
};
```

##### 可变数据成员

如果我们希望改变类的某个数据成员，即使是在const成员函数内，我们可以在变量声明的时候加入`mutable`关键字

一个可变数据成员永远不会是const的，即使它是const对象的成员

##### 类的声明

能够仅仅声明类而不定义它：

```c++
class Screen;  //只声明
```

对于类型 Screen 来说，在它的声明之后定义之前是一个==不完全类型==

不完全类型只能在有限的情况下使用：

- 可以定义指向这种类型的指针或引用，静态数据类型也可以
- 可以声明(但是不能定义)以不完全类型作为参数或者返回类型的函数

#### 7.3.4 友元再探

##### 类之间的友元

如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员

除了令整个类作为友元之外也可以只为成员函数声明友元

```c++
class Screen{
    friend class Window_mgr;
}; //Window_mgr 的成员可以访问Screen的私有部分
class Screen{
    friend void Window_mgr::clear(ScreenIndex);
};//这个成员函数可以访问Screen的私有部分
```

我们必须按照如下方式设计程序：

- 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen
- 接下来定义Screen，包括对于clear的友元声明
- 最后定义clear，此时它才可以使用Screen的成员

如果一个类想把一组重载函数声明成它的友元，必须对每一个函数分别声明

### 7.4 类的作用域

##### 作用域和定义在类外部的成员

一个类就是一个定义域能够解释为何在类的外部定义成员函数的时候要指明它所属的类（A::func()）。一旦遇到了类名，就知道剩余部分在类的作用域之内了。

函数的返回类型通常出现在函数名之前，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时返回类型必须指明它是那个类的成员

#### 7.4.1 名字查找与类的作用域

名字查找的过程比较直接：

- 首先在名字所在的块中查找声明，只考虑在名字之前出现的声明。
- 如果没找到，继续查找外层作用域
- 如果最终没找到，则报错

但是在类中有所区别：

- 编译成员的声明
- 直到类全部可见后才编译函数体

##### 用于类成员声明的名字查找

这种两阶段的处理方式只适用于成员函数中使用的名字，声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。

### 7.5 构造函数再探

#### 7.5.1 [构造函数初始值列表](#构造函数初始值列表)

==构造函数初始值列表和构造函数体内的赋值是有区别的==，如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。

##### 构造函数的初始值有时必不可少  ⭐

如果成员是const或者引用的话，必须将其初始化。当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。==随着构造函数体一开始执行，**初始化**就完成了==。我们**初始化const或者引用类型的唯一机会**就是通过构造函数初始值列表  :jack_o_lantern:

##### 成员初始化的顺序

成员初始化的顺序与它们在类定义中的顺序一致。构造函数初始值列表中的顺序不会影响实际的初始化顺序。不过最好令构造函数初始值的顺序与成员声明的顺序保持一致🫠

#### 7.5.2 <span id="委托构造函数">委托构造函数</span>

一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程。

委托构造函数也有一个成员初始值的列表和一个函数体。但是**成员初始值列表只有一个唯一的入口**，就是类名本身

```c++
class Sales_data{
    public:
    	Sales_data(std::string s,unsigned cnt,double price):bookNo(s),units_sold(cnt),revenue(cnt * price){}
    	Sales_data():Sales_data("",0,0){} //委托构造函数
    	Sales_data(std::string s):Sales_data(s,0,0){} //委托构造函数
};
```

**执行顺序：**

1. 委托这的构造函数初始值列表
2. 被委托者的构造函数初始值列表
3. 被委托者的构造函数体
4. 委托者的构造函数体

#### 7.5.3 默认构造函数的作用

对象被默认初始化或值初始化时自动执行默认构造函数。

默认初始化在以下情况下发生：

- 当我们在块作用域内不使用任何初始值定义一个非静态变量或者数组时
- 当一个类本身含有类类型的成员且使用合成默认构造函数时
- 当类类型的成员没有在构造函数初始值列表中显式地初始化时

值初始化在以下情况下发生：

- 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时
- 当我们不使用初始值定义一个局部静态变量时
- 当我们通过书写形如T()的表达式显式地请求值初始化时，其中T是类型名，它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化

#### 7.5.4 隐式的类类型转换

```c++
class Sales_data{
    public:
    	Sales_data(std::string s, unsigned cnt, double price): bookNo(s), units_sold(cnt),revenue(cnt * price){}
    	Sales_data(std::string s):Sales_data(s,0,0){}  //这里实际上是叫委托构造函数的东西，但是在这不是重点
    	Sales_data(std::istream&);
};
//看下面的代码
std::string null_book = "9-999-9999-9";
item.combine(null_book); //item 是一个 Sales_data 对象，combine是 Sales_data 的成员其中参数列表是 Sales_data 类型的。
//但是这里能够用一个 string 类型作为实参，是因为发生了隐式类型转换(原因是 Sales_data 类中有使用一个 string 的构造函数)
```

##### 只允许一步类类型转换

```c++
item.combine("9-999-9999-9");  //错误，字符串字面值不是 string 类型的,所以此处需要两次转换
1. 把字符串字面量转换为 string 类型
2. 再将 string 类型转换为 Sales_data类型
这种操作是不允许的，因为编译器只会自动执行一步类型转换
```

##### 抑制构造函数定义的隐式转换

可以通过将构造函数声明为<span id="explicit"> `explicit`</span> 阻止隐式转换

```c++
explicit Sales_data(std::string s):Sales_data(s,0,0){}
```

1. 关键字`explicit`只对一个实参的构造函数有效。多个实参的构造函数不能隐式转换

2. 只能在类内声明处使用`explicit`关键字，在类外定义时不能重复】

3. 尽管编译器不会将`explicit`的构造函数用于隐式转换，但是仍旧能够使用它进行显示的强制转换

   ```c++
   item.combine(static_cast<Sales_data>(cin));
   ```

#### <center id="7.5.5聚合类">7.5.5 聚合类</center>

聚合类具有特殊的初始化语法形式

满足以下条件的类是聚合类

- 所有成员都是 `public` 的
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类，也没有 `virtual` 函数

```c++
struct{
    int ival;
    string s;
};
Data vall = {0, "aaa"}; //保持与声明顺序一致即可初始化，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化
```

显式地初始化类的对象的成员存在三个明显的缺点：

- 要求类的所有成员都是public的
- 将正确初始化每个对象的每个成员的重任交给了类的用户（而非类的作者）。
- 添加或删除一个成员之后，所有的初始化语句都要更新

#### 7.5.6 字面值常量类

数据成员都是字面值类型的聚合类是字面值常量类

如果一个雷不是聚合类，但符合下述要求，也是一个字面值常量类：

- 数据成员都必须是字面值类型
- 类必须至少含有一个constexpr构造函数
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数
- 类必须使用析构函数的默认定义，该成员负责销毁类的对象

##### constexpr构造函数

构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。一个字面值常量类必须至少提供一个constexpr构造函数

constexpr构造函数可以声明成[=default](#=default)的形式或者是删除函数的形式。否则constexpr函数就必须符合构造函数的要求不能有返回值，又符合constexpr函数的要求即唯一的可执行语句是返回语句，综合这两点可知，constexpr构造函数体一般应该是空的。

```c++
class Debug{
    public:
    	constexpr Debug(bool b = ture):hw(b),io(b),other(b){}
}
```



constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数或者是一条常量表达式

### 7.6 类的静态成员

- 在类的外部定义静态成员时，不能重复 `static`关键字，该关键字只出现在类的内部的声明语句
- 不能在类的内部初始化静态成员。必须在类的外部定义和初始化每个静态成员，一个静态数据成员只能定义一次(可以为静态成员提供`const`整数类型的类内初始值，不过要求静态数据成员必须是字面值常量类型的`constexpr`)
- 静态数据成员可以是**不完全类型**。特别的静态数据成员的类型可以是它所属的类型。

------

# 第 II 部分 C++标准库

## 第八章 IO库

### <span id="8.1IO类">8.1 IO类</span>

<center>IO库类型和头文件</center>

| 头文件   |                             类型                             |
| -------- | :----------------------------------------------------------: |
| iostream | istream,wistream 从流读入数据<br />ostream,wostream 向流写入数据<br />iostream,wiostream 读写流 |
| fstream  | ifstream,wifstream 从文件读取数据<br />ofstream，wofstream 向文件写入数据<br />fstream，wfstream 读写文件 |
| sstream  | istringstream，wistringstream 从string读取数据<br />ostringstream，wostringstream 向string写入数据<br />stringstream，wstringstream 读写string |

类型 `ifstream`和`istringstream`都继承自`istream`

##### IO类型间的关系

类型ifstream和istringstream都继承自istream

ofstream和ostringstream都继承自ostream

#### 8.1.1 IO对象无拷贝或赋值

不能拷贝或对IO对象赋值，因此无法将形参或返回类型设置为流类型

进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是`const`

#### 8.1.2 条件状态

<center>IO库条件状态</center>

| 属性和操作        | 含义                                                         |
| ----------------- | ------------------------------------------------------------ |
| strm::iostate     | strm是一种IO类型，在[8.1IO类](#8.1IO类)中列出。iostate是一种机器相关的类型，提供了表达条件状态的完整功能 |
| strm::badbit      | strm::badbit用来指出流已崩溃                                 |
| strm::failbit     | strm::failbit用来指出一个IO操作失败了                        |
| strm::eofbit      | strm::eofbit用来指出流到达了文件结束                         |
| strm::goodbit     | strm::goodbit用来指出流未处于错误状态。此值保证为0           |
| s.eof()           | 若流s的eofbit置位，则返回true                                |
| s.fail()          | 若流s的failbit或badbit置位，返回true                         |
| s.bad()           | 流s的badbit置位返回true                                      |
| s.good()          | 流处于有效状态，返回true                                     |
| s.clear()         | 将流中的所有条件状态复位，将流的状态设置为有效，返回void     |
| s.clear(flag)     | 根据给定的flag标志位，将流s中的对应条件状态位复位。flag的类型为strm::iostate。返回void |
| s.setstate(flags) | 根据给定的标志位flags，将流中对应条件状态位置位。flags的类型strm::iostate。返回void |
| s.rdstate()       | 返回流s的当前条件状态，返回值类型为strm::iostate             |

##### 查询流的状态

IO库定义了一个与机器无关的`iostate`类型，它提供了表达流状态的完整功能。这个类型作为一个位集合来使用

- `badbit`表示系统级错误。通常被置位，流就无法再使用了。
- `failbit`在发生可恢复错误后被置位，如期望读取数值却读入一个字符等错误。
- 如果到达文件结束位置`eofbit`和`failbit`都会被置位。
- `goodbit`的值为0，表示流未发生错误。

如果`badbit`、`failbit`、`eofbit`任一个被置为，检测流状态会返回`false`

标准库还定义了一组函数来查询这些标志位的状态。good()在所有错误位均为置位的情况下返回 true，而bad()、fail()和eof()则在对应错误被置位时返回true。使用流对象.good()的方式调用。

##### 管理条件状态

流对象的rdstate成员返回一个iostate值，对应流的当前状态；setstate操作将给定条件位置位，表示发生了对应的错误。

clear()方法有两个版本：

- 无参版本清除所有的错误标志位
- 接受 iostate 值的版本表示流的状态更新为新的 iostate

#### 8.1.3 管理输出缓冲

导致缓冲刷新得原因有很多：

- 程序正常结束，作为 main 函数得 return 操作的一部分，缓冲刷新被执行

- 缓冲区满时刷新

- 使用操纵符如 endl 显式刷新缓冲区

- 可以设置 `unitbuf`设置流的内部状态来清空缓冲区，默认情况下 cerr 是设置`unitbuf`的

  ```c++
  cout << unitbuf; //所有输出操作后都会立即刷新缓冲区
  cout << nounitbuf; //回到正常的缓冲方式
  ```

- 一个输出流可以关联到另一个流

##### 刷新输出缓冲区

endl:换行并刷新缓冲区

flush:刷新缓冲区，但不输出任何额外的字符

ends:向缓冲区插入一个空字符，然后刷新缓冲区

##### 关联输入和输出流

一个输入流和输出流关联在一起时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。==标准库将 cout 和 cin 关联在一起==

```c++
cin >> ival; //cout 的缓冲区被刷新
```

tie()有两个版本：

1. 无参版本，返回指向输出流的指针。如果对象关联了某个输出流则返回指向该输出流的指针，如果未关联，则返回空指针。
2. 接受一个指向 ostream 的指针，将自己关联到此 ostream。

```c++
cin.tie(&cout); //仅仅是个展示，标准库将cin和cout关联在一起
ostream *old_tie = cin.tie(nullptr); // cin 不再与其他流关联，old_tie此时指向cout
cin.tie(old_tie); //将cin和cout重新关联起来
```

### 8.2 文件输入输出

头文件 fstream 定义了三个类型来支持文件IO：

- `ifstream`从一个给定文件读取数据
- `ofstream`向一个给定文件写入数据
- `fstream`可以读写给定文件

除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。

<center>fstream 特有的操作</center>

| 操作                   |                                                              |
| ---------------------- | ------------------------------------------------------------ |
| fstream fstrm;         | 创建一个未绑定的文件流。fstream是头文件fstream中定义的一个类型 |
| fstream fstrm(s);      | 创建一个fstream，并打开名为s的文件。s可以是string或者C风格字符串的指针。默认的文件模式依赖于fstream |
| fstream fstrm(s,mode); | 按指定mode打开文件                                           |
| fstrm.open(s)          | 打开名为s的文件，并将文件与fstrm绑定。s可以是string或者C风格字符串指针。默认的mode依赖于fstream |
| fstrm.close()          | 关闭与fstrm绑定的文件                                        |
| fstrm.is_open()        | 返回一个bool值，指出与fstrm关联的文件是否成功打开且尚未关闭  |

#### 8.2.1 使用文件流对象

读写文件时，可以定义一个文件流对象，并将对象与文件关联起来。每个文件流对象都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。

如果提供了一个文件名，则open会被自动调用

```c++
ifstream in(ifile);
ofstream out;
```

##### 成员函数open和close

如果定义了一个空文件流对象，可以随后调用open来将它与文件关联起来：如果调用open失败，failbit会被置位

调用close()之后还能够打开新的文件，close会关闭已经关联的文件

当一个fstream被销毁时，close会自动调用

#### 8.2.2 文件模式

每个流都有一个关联的文件模式，用来指出如何使用文件

<center>文件模式</center>

| 模式   | 含义                         |
| ------ | ---------------------------- |
| in     | 以读方式打开                 |
| out    | 以写方式打开                 |
| app    | 每次写操作前均定位到文件末尾 |
| ate    | 打开文件后立即定位到文件末尾 |
| trunc  | 截断文件                     |
| binary | 以二进制方式进行IO           |

指定文件模式有如下限制：

- 只可以对ofstream或fstream对象设定out模式
- 只可以对ifstream或fstream对象设定in模式
- 只有当out也被设定时才可以设定trunc模式
- 只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出方式被打开
- 默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被截断。为了保留以out模式打开的文件的内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作
- ate和binary模式可以用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。

每一个文件流类型都定义了一个默认的文件模式，当未指定文件模式时，以默认方式打开

- 与ifstream关联的文件默认in模式
- 与ofstream关联的文件默认out模式
- 与fstream关联的文件默认in和out模式

**保留被ofstream打开的文件中已有数据的唯一方法是显式指定app或in模式**

每次调用open时都会重新确定文件模式

### 8.3 string 流

- istringstream从string读取数据
- ostringstream向string写入数据
- stringstream既可以从string读数据也可以写入数据

sstream继承自iostream

<center>stringstream特有操作</center>

| 操作             |                                                              |
| ---------------- | ------------------------------------------------------------ |
| sstream strm;    | strm是一个未绑定的stringstream对象，sstream是头文件sstream中定义的一个类型 |
| sstream strm(s); | strm是一个sstream对象，保存string s 的一个拷贝。此构造函数是explicit的 |
| strm.str()       | 返回strm所保存的string的拷贝                                 |
| strm.str(s)      | 将string s 拷贝到strm中，返回void                            |

#### 8.3.1 使用istringstream

#### 8.3.2 使用ofstringstream

## 第九章 顺序容器

### 9.1 顺序容器概述

<center>顺序容器类型</center>

| 容器类型     |                                |
| ------------ | ------------------------------ |
| vector       | 可变大小数组。支持快速随机访问 |
| deque        | 双端队列                       |
| list         | 双向链表                       |
| forward_list | 单向链表                       |
| array        | 固定大小数组                   |
| string       | 与vector相似，但是专门保存字符 |

### 9.2 容器库概览

| 类型别名               |                                                    |
| ---------------------- | -------------------------------------------------- |
| iterator               | 此容器类型的迭代器类型                             |
| const_iterator         | 可以读取元素，但是不能修改元素的迭代器类型         |
| size_type              | 足够保存此种容器类型最大可能容器的大小，无符号整型 |
| difference_type        | 足够保存两个迭代器之间的距离，有符号整型           |
| value_type             | 元素类型                                           |
| reference              | 元素的左值类型；与value_type&含义相同              |
| const_reference        | 元素的const左值类型                                |
| 构造函数               |                                                    |
| C c;                   | 默认构造函数，构造空容器                           |
| C c1(c2);              | 构造c2的拷贝c1                                     |
| C c(b,e)               | 将迭代器b和e指定的范围内的元素拷贝到c中            |
| C c{a,b,d,...}         | 列表初始化                                         |
| 赋值与swap             |                                                    |
| c1 = c2                | 将c1中的元素替换为c2中的元素                       |
| c1 = {a,b,c...}        | 将c1中的元素替换为列表中的元素（不适用array）      |
| a.swap(b)              | 交换a和b中的元素                                   |
| swap(a,b)              | 等价                                               |
| 大小                   |                                                    |
| c.size()               | c中元素的数目                                      |
| c.max_size()           | c可保存的最大元素数目                              |
| c.empty()              | c是否为空                                          |
| 添加/删除元素          |                                                    |
| c.insert(args)         | 将args中的元素拷贝进c                              |
| c.emplace(inits)       | 使用inits**构造**c中的一个元素                     |
| c.erase(args)          | 删除args指定的元素                                 |
| c.clear()              | 删除c中所有的元素，返回void                        |
| 关系运算符             |                                                    |
| == ,!=                 | 所有容器都支持                                     |
| <,<=,>,>=              | 关系运算符                                         |
| 获取迭代器             |                                                    |
| c.being(),c.end()      | 返回指向c首元素和尾后元素的迭代器                  |
| c.cbegin(),c.cend()    | 返回const版本                                      |
| 反向迭代器的额外成员   |                                                    |
| reverse_iterator       | 按逆序寻址元素的迭代器                             |
| const_reverse_iterator | const版本                                          |
| c.rbegin(),c.rend()    | 返回指向c尾元素和首元素之前位置的迭代器            |
| c.crbegin(),c,crend()  | const版本                                          |

#### 9.2.1 迭代器

迭代器范围由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾后位置

#### 9.2.2 容器类型成员

#### 9.2.3 `begin`和`end`成员

以begin()为例：有四种

- begin(),返回 `iterator`
- rbegin(),返回 `reverse_iterator`
- cbegin(),返回`const_iterator`
- crbegin(),返回`const_reverse_iterator`

不以c开头的函数都是被重载过的，即

- 若v为非常量成员,v.begin()返回`iterator`
- 若v为常量成员,v.begin()返回`const_iterator`

#### 9.2.4 容器定义和初始化

##### 将一个容器初始化为另一个容器的拷贝

- 直接拷贝整个容器
- 拷贝一个由迭代器对指定的元素范围

##### 标准库array具有固定大小

标准库array的大小也是类型的一部分

使用array类型，我们必须同时指定元素类型和大小

array大小固定的特性影响了它所定义的构造函数的行为。与其他容器不同，一个默认构造的array是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化（就像内置数组）。如果对array进行列表初始化，那么列表元素数目必须小于等于array的大小，剩余的部分将进行值初始化，并且如果存储的类型是类类型，该类类型还必须有默认构造函数以便能够进行值初始化

#### 9.2.5 赋值和swap

##### swap

```c++
swap(c1,c2);
c1.swap(c2);
```

##### assign

```c++
seq.assign(b,e); //将seq中的元素替换为迭代器b和e范围内的元素。b和e不能指向seq
seq.assign(il); //将seq中的元素替换为列表值
seq.assign(n,t); //将seq中的元素替换为n个t
```

#### 9.2.6 容器大小操作

size()：返回容器中元素的数目

empty()：size为0时返回true

max_size(): 返回一个大于或等于该类型容器所能容纳的最大元素数的值

#### 9.2.7 关系运算符



### 9.3 顺序容器操作

#### 9.3.1 向顺序容器添加元素

forward_list有自己专有版本的insert 和 emplace [9.3.4节](#9.3.4)

forward_list不支持push_back和emplace_back

vector和string不支持push_front和emplace_back

| 操作                 |                                           |
| -------------------- | ----------------------------------------- |
| c.push_back()        | 尾部添加一个值为t的元素                   |
| c.emplace_back(args) | 尾部添加一个由args创建的元素              |
| c.push_front         |                                           |
| c.emplcae_front()    |                                           |
| c.insert(p,t)        | 插入元素的几种方式，都是在迭代器p之前插入 |
| c.emplace(p,args)    |                                           |
| c.insert(p,b,e)      |                                           |
| c.insert(p,il)       |                                           |
| c.insert(p,n,t)      |                                           |

#### 9.3.2 访问元素

at和下标操作只适用于string、vector、deque和array

back不适用于fordward_list

| 操作      |                                               |
| --------- | --------------------------------------------- |
| c.back()  | 返回c中尾元素的**引用**                       |
| c.front() | 返回c中首元素的引用                           |
| c[n]      | 返回c中下标为n的元素的引用，n是一个无符号整数 |
| c.at(n)   | 返回下标为n的元素的引用                       |

**访问成员函数返回的是引用**，如果我们使用auto来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须将变量定义为引用类型。否则默认是拷贝

#### 9.3.3 删除元素

array无法删除元素

forward_list 有特殊版本的erase [9.3.4节](#9.3.4)

froward_list 不支持pop_back

vector和string不支持pop_front

| 操作          |                                                              |
| ------------- | ------------------------------------------------------------ |
| c.pop_back()  | 删除c中尾元素                                                |
| c.pop_front() | 删除c中首元素                                                |
| c.erase(p)    | 删除迭代器p指定的元素，返回一个指向被删除元素之后元素的迭代器 |
| c.erase(b,e)  | 删除迭代器b和e范围内的元素，返回一个指向最后一个被删除元素之后元素的迭代器 |
| c.clear()     | 删除c中所有元素                                              |

#### <span id="9.3.4">9.3.4 特殊的forward_list操作</span>

| 操作                    |                                                              |
| ----------------------- | ------------------------------------------------------------ |
| lst.before_begin()      | 返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用 |
| lst.cbefore_begin()     | 返回const版本迭代器                                          |
| lst.insert_after(p,t)   | 在迭代器p之后的位置插入元素（其他容器是在p之前插入）         |
| lst.insert_after(p,n,t) |                                                              |
| lst.insert_after(p,b,e) |                                                              |
| lst.insert_after(p,il)  |                                                              |
| emplace_after(p,args)   | 使用args参数创建元素，插入到p之后                            |
| lst.erase_after(p)      | 删除p指向的位置之后的元素，或删除从b之后直到e之间的元素。返回被删除元素之后元素的迭代器 |
| lst.erase_after(b,e)    |                                                              |

#### 9.3.5 改变容器大小

可以使用resize来增大或缩小容器。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部

| 操作          |                                                       |
| ------------- | ----------------------------------------------------- |
| c.resize(n)   | 调整c的大小为n个元素                                  |
| c.resize(n,t) | 调整c的大小为n个元素，任何**新添加**的元素都初始化为t |

#### 9.3.6 容器操作可能使迭代器失效

向容器添加元素后：

- 如果容器时vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前元素的迭代器、指针和引用仍旧有效，但指向插入位置之后元素的迭代器、指针和引用将会失效
- 对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效
- 对于list和forward_list，指向容器的迭代器、指针和引用仍然有效

删除一个元素后：

- 对于list、forward_list，指向容器其他位置的迭代器、引用和指针仍旧有效
- 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用和指针也会失效。如果是删除deque的尾元素，则尾后迭代器失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不受影响
- 对于vector和string，指向被删除元素之前元素的迭代器、引用和指针仍有效

### 9.4 vector对象是如何增长的

shrink_to_fit只适用于vector、string和deque

capacity和reserve只适用于vector和string

| 方法            |                                       |
| --------------- | ------------------------------------- |
| shrink_to_fit() | 请将capacity()减少为与size()相同大小  |
| c.capacity()    | 不重新分配内存的话，c可以保存多少元素 |
| c.reserve(n)    | 分配至少能容纳n个元素的内存空间       |

reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间

### 9.5 额外的string操作

#### 9.5.1 构造string的其他方法

| 构造string             |                                                              |
| ---------------------- | ------------------------------------------------------------ |
| string s(cp,n)         | s是cp指向的数组中前n个字符的拷贝。此数组应该至少包含n个字符  |
| string s(s2,pos2)      | s是string s2从下标pos2开始的字符的拷贝                       |
| string s(s2,pos2,len2) | s是string s2从下标pos2开始的len2个字符的拷贝（最多也就拷到末尾） |

##### substr操作

substr返回一个string，它是原始string的一部分或全部的拷贝。可以传递给substr一个可选的开始位置和计数值：

```c++
s.substr(pos,n);
```

#### 9.5.2 改变string的其他方法

除了之前接受迭代器的insert和erase版本，string还提供了接受下标的版本

| 操作                  |                                                              |
| --------------------- | ------------------------------------------------------------ |
| s.insert(pos,args)    | 在pos之前插入args指定的字符（pos可以是下标或者迭代器，接受下标的版本返回指向s的引用，接受迭代器的版本返回指向第一个插入字符的迭代器） |
| s.erase(pos,len)      | 删除从pos开始的len个字符，返回一个指向s的引用                |
| s.assign(args)        | 将s中的字符替换为args指定的字符                              |
| s.append(args)        | 将args追加到s                                                |
| s.replace(range,args) | 删除s中范围range内的字符，替换为args指定的字符               |

args可以是下列形式之一；append和assign可以使用所有形式

```c++
str   字符串str
str,pos,len    str中从pos开始的至多len个字符
cp,len		cp是字符数组
n,c		n个字符c
b,e	 	b,e之间的范围
初始化列表
```

#### 9.5.3 string搜索操作

每个搜索操作都返回**string::size_type**值，表示匹配发生位置的下标

find函数完成最简单的搜索。查找指定的字符串，若找到返回第一个匹配位置的下标，否则返回npos（标准库将npos定义为const string::size_type 并初始化为-1），搜索是大小写敏感的

rfind函数则查找s中指定字符串最后一次出现的位置

| 查找操作                  |                                                 |
| ------------------------- | ----------------------------------------------- |
| s.find(args)              | 查找s中args第一次出现的位置                     |
| s.rfind(args)             | 查找s中args最后一次出现的位置                   |
| s.find_first_of(args)     | 在s中查找args中任何一个字符第一次出现的位置     |
| s.find_last_of(args)      | 在s中查找args中任何一个字符最后一次出现的额位置 |
| s.find_first_not_of(args) | 在s中查找第一个不在args中的字符                 |
| s.find_last_not_of(args)  | 在s中查找最后一个不在args中的字符               |

可以传递给find操作一个可选的开始位置，指定从什么位置开始搜索，默认为0

#### 9.5.4 compare函数

根据s是等于、大于、小于指定字符串分别返回0、整数或负数

#### 9.5.5 数值转换

| 数值转换       |                                                              |
| -------------- | ------------------------------------------------------------ |
| to_string(val) | 一组重载函数，返回数值val的string表示                        |
| stoi(s,p,b)    | 返回s的起始子串（表示整数内容）的数值，返回类型分别为Int、long、unsigned long、long long、unsigned long long。b表示转换所用的基数，默认为10。p是size_t指针，用来保存s中第一个非数值字符的下标，默认为0，即函数不保存下标 |
| stol(s,p,b)    |                                                              |
| stoul(s,p,b)   |                                                              |
| stoll(s,p,b)   |                                                              |
| stoull(s,p,b)  |                                                              |
| stof(s,p)      | 浮点类型 float、double、long double                          |
| stod(s,p)      |                                                              |
| stold(s,p)     |                                                              |

### 9.6 容器适配器

标准库定义了三个顺序容器适配器：stack、queue和priority_queue

```c++
//栈 默认基于deque实现，也可以在list或vector上实现
stack<int> intStack;
intStack.pop();
intStack.push(item);
intStack.emplace(args);
intStack.top();
//队列 queue默认基于deque实现，priority_queue默认基于vector实现
q.pop();  //返回queue首元素或priority_queue最高优先级元素
q.front(); 
q.back();
q.top();
q.push(item);
q.emplace(args);
```

## 第十章 泛型算法

### 10.1 概述

大多数算法都定义在`algorithm`中，标准库还在头文件`numeric`中定义了一组数值泛型算法

一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围

##### <span id="算法永远不会执行容器的操作">算法永远不会执行容器的操作</span>

> 泛型算法本身不会执行容器操作，它们只会运行于迭代器智商，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素，也可能在容器中移动元素，但永远不会添加和删除元素

### 10.2 初始泛型算法

#### 10.2.1 只读算法

##### 1) find算法

find 的前两个参数是表示范围的迭代器，第三个参数是一个值。find将范围中的元素逐个与val比较，返回第一个等于给定值的元素的迭代器,如果查找失败，返回第二个元素

```c++
find(iterator,iterator,val);
```

##### 2) accumulate

accumulate定义在头文件numeric中。前两个参数是需要求和的元素范围，第三个参数是和的初值

```c++
accumulate(iterator,iterator,val);
```

##### 3) equal

用于确定两个序列是否保存相同的值

接受三个迭代器，前两个表示第一个序列中的元素范围，第三个表示第二个序列的首元素。它假定第二个序列至少与第一个序列一样长

#### 10.2.2 写容器元素算法

[算法不会执行容器操作，因此它们自身不可能改变容器大小](#算法永远不会执行容器的操作)

##### 1) fill

fill接受一对迭代器表示的范围，还接受一个值。fill将此值赋予序列中的每个元素

```c++
fill(vec.begin(),vec.end(),0);
```

##### 2) copy

拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法

前两个迭代器表示一个输入范围，第三个表示目的序列的起始位置

##### 3) replace

replace算法读入一个序列，并将其中所有等于给定值的元素都修改为另一个元素

接受四个参数：

- 前两个是迭代器，表示范围
- 要搜索的值
- 替换的值

```c++
replace(list.begin(),list.end(),0,42);
```

#### 10.2.3 重排容器元素的算法

![image-20230502103517544](https://nrwflqzr.oss-cn-beijing.aliyuncs.com/typora-img/image-20230502103517544.png)

最终的目标是生成如下的vector

![image-20230502103544964](https://nrwflqzr.oss-cn-beijing.aliyuncs.com/typora-img/image-20230502103544964.png)

##### 1) sort

sort算法接收两个迭代器表示排序元素的范围，结果应如下（相同的单词放在了一起）

![image-20230502103611371](https://nrwflqzr.oss-cn-beijing.aliyuncs.com/typora-img/image-20230502103611371.png)

##### 1) stable_sort

稳定排序，能够维持相等元素的原有顺序

##### 2) unique

unique算法重排输入序列，能够将相邻的重复项“消除”，并返回一个指向不重复值范围末尾的迭代器

![image-20230502103650859](https://nrwflqzr.oss-cn-beijing.aliyuncs.com/typora-img/image-20230502103650859.png)

此时vector的大小并未改变，得到指向不重复值范围末尾的迭代器之后再调用erase方法逐个删除，即可达到效果

### 10.3 定制操作

默认情况下，比较输入序列元素的方法使用元素类型的<，=运算符完成比较。我们也可以定制额外的版本

#### 10.3.1 向算法传递函数

##### 谓词

**一元谓词：**只接受单一参数

**二元谓词：**它们有两个参数

```c++
bool isShorter(const string &s1,const string &s2){
    return s1.size() < s2.size();
}
sort(words.begin(),words,end(),isShorter);
```

#### 10.3.2 lambda表达式

传递给算法的谓词必须严格接受一个或两个参数。我们可以使用lambda表达式完成更复杂的功能

一个lambda表达式表示一个可调用的代码单元。可以将其理解为未命名的内联函数

一个lambda具有一个返回类型、一个参数列表和一个函数体

```c++
[capture list](parameter list) -> return type {function body}
```

其中capture list 是一个lambda所在函数中定义的局部变量的列表。

**lambda必须使用尾置返回**，我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体

```c++
auto f = []{return 42;};
cout << f() << endl;
```

**lambda不能有默认参数**

#### 10.3.3 lambda捕获和返回

当定义一个lambda时，编译器生成一个与lambda对应的新的类类型，将在14.8.1节介绍如何生成。

默认情况下，从lambda生成的类都包含一个对应该lambda所捕获变量的数据成员

##### 值捕获

被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝

此时修改该变量不会影响原来的值

##### 引用捕获



##### 隐式捕获

除了显式列出我们需要的变量之外，还可以让编译器根据lambda体中的代码来推断我们要使用的变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。&告诉编译器捕获采用引用方式，=告诉编译器捕获采用值方式

当我们混合使用隐式捕获或者显式捕获时，捕获列表中的第一个元素必须是一个&**或**=，指定默认捕获方式是什么

##### 可变lambda

默认情况下对于值被拷贝的变量，lambda不会改变其值。如果我们希望能够改变一个被捕获变量的值，就必须在参数列表首加上关键字`mutable`

```c++
void fun3(){
    size_t v1 = 42;
    auto f = [v1]() mutable {return ++v1;};
    v1 = 0;
    auto j = f(); //j为43
}
```

一个引用捕获的变量是否能够修改取决于此引用指向的是const类型还是非const

##### 指定lambda返回类型

默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void

#### 10.3.4 参数绑定

##### 标准库bind函数

定义在头文件functional中，可以将bind看做通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表

```c++
auto newCallable = bind(callable,arg_list);
```

当我们调用newCallable时,newCallable会调用callable，并传递给它arg_list中的参数

arg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是占位符，表示newCallable的参数，它们占据了传递给newCallable的参数的位置。\_1表示第一个参数，\_2表示第二个参数

```c++
bool check_size(const string &s, string::size_type sz){
    return s.size() >= sz;
}
auto check6 = bind(check_size, _1 ,6);
//只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数
string s = "hello";
bool b1 = check6(s); //check6会调用check_size(s,6)
```

##### bind的参数

```c++
auto g = bind(f,a,b,_2,c,_1);
//生成一个新的可调用对象，它有两个参数，分别用占位符_2、_1表示。
//即第一个g的参数将会绑定到f的最后一个参数上，第二个g的参数将会绑定到f的第三个参数上
```

##### 绑定引用参数

- ref()
- cref()

```c++
for_each(words.begin(),words.end(),bind(print, ref(os), _1, ' '));
//因为bind拷贝其参数，但是对于ostream的对象os来说无法拷贝，可以使用ref函数返回一个引用，这个返回的对象是可以拷贝的
//还有一个cref()可以返回const引用
```

### 10.4 再探迭代器

标准库在头文件iterator中还定义了额外几种迭代器

- 插入迭代器：这些迭代器被绑定到一个容器上，可以用来向容器插入元素
- 流迭代器：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流
- 反向迭代器：这些迭代器向后而不是向前移动，除了forward_list之外的标准库容器都有反向迭代器
- 移动迭代器：这些专用的迭代器不是拷贝其中的元素，而是移动它们 [13.6.2节]

#### 10.4.1 插入迭代器

- back_inserter创建一个使用push_back的迭代器
- front_inserter创建一个使用push_front的迭代器
- inserter创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前

插入迭代器的工作过程：

1. 当调用inserter(c,iter)时，我们得到一个迭代器
2. 使用它时，会将元素插入到iter原来所指向的元素之前的位置

如果it是由inserter生成的迭代器，则下面的赋值语句

```c++
*it = val;
```

效果与下述代码相同

```c++
it = c.insert(it,val);
++it; //递增it使它指向原来的元素
```

#### 10.4.2 iostream迭代器

- istream_iterator读取输入流
- ostream_iterator向输出流写入数据

##### istream_iterator操作

当创建一个流迭代器时，必须指定**迭代器将要读写的对象类型**。使用>>来读取流

- 当创建一个istream_iterator时，我们可以将它绑定到一个流。
- 也可以默认初始化，这样得到一个可以当做尾后值使用的迭代器

```c++
istream_iterator<int> in_iter(cin);
istream_iterator<int> eof; //尾后迭代器
while(in_iter != eof)
    vec.push_back(*in_iter++);
```

##### ostream_iterator操作

| 操作                              |                                                              |
| --------------------------------- | ------------------------------------------------------------ |
| ostream_iterator\<T> out(os);     | out将类型为T的值写入到os中                                   |
| outstream_iterator\<T> out(0s,d); | out将类型为T的值写到输出流os中，每个值后面都输出一个d。d指向一个空字符结尾的字符数组 |
| out = val                         | 将val写入到out绑定的ostream中                                |

#### 10.4.3 反向迭代器

反向迭代器就是容器中从尾元素向首元素反向移动的迭代器



### 10.5 泛型算法结构

| 迭代器类型     |                                      |
| -------------- | ------------------------------------ |
| 输入迭代器     | 只读、不写；单遍扫描，只能递增       |
| 输出迭代器     | 只写、不读；单遍扫描，只能递增       |
| 前向迭代器     | 可读写；多遍扫描，只能递增           |
| 双向迭代器     | 可读写；多遍扫描，可递增递减         |
| 随机访问迭代器 | 可读写；多遍扫描，支持全部迭代器运算 |

#### 10.5.1 5类迭代器

C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。例如，find算法在一个序列上进行一遍扫描，对元素进行只读操作，因此至少需要输入迭代器

1. 输入迭代器，可以读取序列中的元素。一个输入迭代器必须支持

   - 用于比较两个迭代器的相等和不相等运算符（==、!=）
   - 用于推进迭代器的前置和后置递增运算（++）
   - 用于读取元素的解引用运算符（*）：解引用只会出现在赋值运算符的右侧（不能修改？）
   - 箭头运算符(->)，等价于（*it).member，即，解引用迭代器，并提取对象的成员

   输入迭代器只能用于单遍扫描算法，如find、accumulate；istream_iterator是一种输入迭代器

2. 输出迭代器：可以看做输入迭代器功能上的补集 --- 只写而不读元素

   - 用于推进迭代器的前置和后置递增运算符
   - 解引用运算符，只支出现在赋值运算符的左侧

   我们只能像一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器，如copy算法的第三个参数就是输出迭代器。ostream_iterator是一种输出迭代器

3. 前向迭代器，可以读写元素，这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素

4. 双向迭代器：可以正向/反向读写序列中的元素。除了支持所有前向迭代器操作之外，双向迭代器还支持前置和后置递减运算符

5. 随机访问迭代器：提供在常量时间内访问序列中任意元素的能力。此迭代器支持双向迭代器的所有功能，此外还支持

   - 用于比较两个迭代器相对位置的关系运算符(<,<=，>,>=)
   - 迭代器和一个整数值的加减运算
   - 用于两个迭代器上的减法运算
   - 下表运算符

#### 10.5.2 算法形参模式

#### 10.5.3 算法命名规范



### 10.6 特定容器算法

##### list和forward_list成员函数版本算法

| 操作                 |                                                              |
| -------------------- | ------------------------------------------------------------ |
| lst.merge(lst2)      | 将来自lst2的元素合并入lst。lst和lst2都必须是有序的。元素将从lst2中删除。在合并之后lst2变为空。第一个版本使用<运算符；第二个版本使用给定的比较运算符 |
| lst.merge(lst2,comp) |                                                              |
| lst.remove(val)      | 调用erase删除掉与给定值相等或令一元谓词为真的每个元素        |
| lst.remove_if(pred)  |                                                              |
| lst.reverse()        | 反转lst中元素的顺序                                          |
| lst.sort()           | 使用<或给定比较操作排序元素                                  |
| list.sort(comp)      |                                                              |
| lst.unique()         | 调用erase删除同一个值的连续拷贝。                            |
| lst.unique(pred)     | 二元谓词版                                                   |

##### splice成员

lst.splice(args)或flst.splice_after(args)

| splice成员   |                                                              |
| ------------ | ------------------------------------------------------------ |
| (p,lst2)     | p是一个指向lst中元素的迭代器，或一个指向flst首前位置的迭代器。函数将lst2的所有元素移动到lst中p之前的位置或是flst中p之后的位置，将lst2元素删除 |
| (p,lst2,p2)  | p2是一个指向lst2中位置的有效的迭代器。将p2指向的元素移动到lst中，或将p2之后的元素移动到flst中。lst2可以是与lst或flst相同的链表 |
| (p,lst2,b,e) | b和e表示lst2中的合法范围。将给定范围中的元素从lst2移动到lst或flst |

**链表的成员函数版本算法与模板算法的区别是能够改变容器**

## 第十一章 关联容器

关联容器中的元素是按关键字来保存和访问的。

两个主要的关联容器是map和set

| 有序容器 |                           |
| -------- | ------------------------- |
| map      | 关联数组，保存关键字-值对 |
| set      | 关键字即值                |
| multimap | 关键字可重复出现的map     |
| multiset | 关键字可重复出现的set     |

| 无序容器           |                                 |
| ------------------ | ------------------------------- |
| unordered_map      | 用哈希函数组织的map             |
| unordered_set      | 用哈希函数组织的set             |
| unordered_multimap | 哈希组织的map；关键字可重复出现 |
| unordered_multiset | 哈希组织的set；关键字可重复出现 |

### 11.1 使用关联容器

### 11.2 关联容器概述

关联容器的迭代器都是双向的

#### 11.2.1 定义关联容器

##### 初始化map和set

定义map时，必须指明关键字类型和值类型

定义set时，必须指明关键字类型

默认初始化是一个指定类型的空容器，我们可以将关联容器初始化为另一个同类型容器的拷贝，或者是从一个值范围来初始化关联容器

##### 初始化multimap或multiset

如果初始化的初值中具有相同的元素（对于multimap来说是相同的key），multimap和multiset与map和set的不同是map和set只会保留一份内容，但是multimap和multiset可以全部保留

#### 11.2.2 关键字类型要求

对于无序容器中关键字的要求将在11.4节介绍

对于有序容器——map、multimap、set以及multiset，**关键字类型必须定义元素比较的方法**。默认情况下使用关键字的<运算符来比较两个关键字

##### 有序容器的关键字类型

可以自己定义操作来代替关键字上的<运算符。所提供的操作必须在关键字类型上定义一个**严格弱序**（小于等于）。这个比较函数必须具备如下基本性质：

- 两个关键字不能同时“小于等于”对方；如果k1“小于等于”k2，那么k2决不能“小于等于”k1
- 如果k1小于等于k2，k2小于等于k3，那么k1必须小于等于k3
- 如果存在两个关键字，任何一个都不小于等于另一个，那么称这两个关键字是等价的

##### 使用关键字类型的比较函数

**用来组织一个容器中元素的操作的类型也是该容器类型的一部分**。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。

在尖括号中出现的每个类型，就仅仅是个类型而已。当我们创建一个容器是，才会以构造函数的形式提供真正的比较操作

```c++
bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs){
    return lhs.isbn() < rhs.isbn();
}
multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);
```

#### 11.2.3 pair类型

定义在utility中，first是第一个元素，second是第二个元素

pair的数据成员是public的

map的元素是pair

**make_pair**(first,second)能够返回一个pair

### 11.3 关联容器操作

| 操作        |                                                              |
| ----------- | ------------------------------------------------------------ |
| key_type    | 此容器类型的关键字类型                                       |
| mapped_type | 每个关键字关联的类型；只适用于map                            |
| value_type  | 对于set，与key_type相同<br />对于map，为pair<const key_type,mapped_type> |

#### 11.3.1 关联容器迭代器

当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是pair类型，关键字是const的。对于set来说iterator和const_iterator都不能改变set中的关键字（都是const的）

#### 11.3.2 添加元素

关联容器的insert成员向容器添加一个元素或一个元素范围。插入一个已存在的元素（对关键字而言）对容器没有任何影响。

insert有两个版本，分别接受一对迭代器，或是一个初始化器列表。

##### 检测insert的返回值

insert返回的值依赖于容器类型和参数，对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，告诉我们插入是否成功。pair的first是一个迭代器，指向具有给定关键字的元素，second是一个bool值，指出元素是插入成功还是已经存在在容器中（false元素已经在容器中，true插入成功）

##### 向multiset或multimap添加元素

接受单个元素的insert操作返回一个指向新元素的迭代器（无须返回bool值，因为总会成功）

#### 11.3.3 删除元素

关联容器定义了三个版本的erase

- erase一个迭代器
- erase一个迭代器范围
- 接受一个key_type参数，此版本删除所有匹配给定关键字的元素，返回实际删除的元素的数量。

#### 11.3.4 map的下标操作

map下标运算接受一个索引，获取与此关键字相关联的值，如果关键字并不在map中，会为他创建一个元素并插入到map中，关联值将进行值初始化

```c++
map<string,size_t> word_count;
word_count["Anna"] = 1;
```

将会执行如下操作：

- 在word_count中搜索关键字为Anna的元素
- 将一个新的关键字值对插入到word_count中。关键字是一个const string，保存Anna。值进行值初始化，在上述代码中为0
- 提取出新插入的元素，并将值1赋予它

只能对非const的map执行下标操作

#### 11.3.5 访问元素

| 操作                                                |                                                              |
| --------------------------------------------------- | ------------------------------------------------------------ |
| **lower_bound和upper_bound不适用于无序容器**        |                                                              |
| **下标和at操作只适用于非const的map和unordered_map** |                                                              |
| c.find(k)                                           | 返回一个迭代器，指向第一个关键字为k的元素，若未找到，返回尾后迭代器 |
| c.count(k)                                          | 返回关键字等于k的元素的数量                                  |
| c.lower_bound(k)                                    | 返回一个迭代器，指向第一个关键字不小于k的元素                |
| c.upper_bound(k)                                    | 返回一个迭代器，指向第一个关键字大于k的元素                  |
| c.equal_range(k)                                    | 返回一个迭代器pair，表示关键字等于k的元素的范围，若不存在，pair的两个成员均等于c.end() |

### 11.4 无序容器

4个无序关联容器，这些容器不是使用比较运算符组织元素的，而是使用一个哈希函数和关键字类型的==运算符

##### 管理桶

无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。

为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将一个具有特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会出现在同一个桶中。无序容器的性能依赖于哈希函数的质量和桶的数量和大小

| 桶接口                |                                                              |
| --------------------- | ------------------------------------------------------------ |
| c.bucket_count()      | 正在使用的桶的数目                                           |
| c.max_bucket_count()  | 容器能容纳的最多的桶的数量                                   |
| c.bucket_size(n)      | 第n个桶中有多少个元素                                        |
| c.bucket(k)           | 关键字为k的元素在那个桶中                                    |
| 桶迭代                |                                                              |
| local_iterator        | 可以用来访问桶中元素的迭代器类型                             |
| const_local_iterator  | 桶迭代器的const版本                                          |
| c.begin(n),c.end(n)   | 桶n的首元素迭代器和尾后迭代器                                |
| c.cbegin(n),c.cend(n) | 与前两个函数类似，返回的是cosnt_local_iterator               |
| 哈希策略              |                                                              |
| c.load_factor()       | 每个桶的平均元素数量，返回float值                            |
| c.max_load_factor()   | c试图维护的平均桶大小，返回float值。c会在需要时添加新的桶，以使得load_factor <= max_local_factor |
| c.rehash(n)           | 重组存储，使得bucket_count >= n 且 bucket_count > size/max_load_factor 🤔 |
| c.reserve(n)          | 重组存储，使得c可以保存n个元素且不必rehash                   |

##### 无序容器对关键字类型的要求

默认情况下，无序容器使用关键字类型==运算符来比较元素，使用一个hash<key_type>类型的对象来生成每个元素的hash值。**内置类型、string、智能指针**已经提供了hash模板

- 在16.5节介绍如何自定义hash模板

- 使用另一种方式，类似于为有序容器重载关键字类型的默认比较操作，我们提供函数替代==和哈希值计算

  ```c++
  size_t hasher(const CSales_data &sd){
      return hash<string>()(sd.isbn());
  }
  bool eqOp(const Sales_data &lhs, const Sales_data &rhs){
      return lhs.isbn() == rhs.isbn();
  }
  
  using SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>;
  SD_multiset bookstore(42,hasher,eqOp);
  ```

  如果我们的类定义了==运算符，也可以只重载哈希函数



## 第十二章 动态内存

除了自动和static对象外，C++还支持动态分配对象。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁

为了更安全地使用动态对象，标准库定义了两个只能指针类型来管理动态分配的对象。当一个对象应该被释放时，指向它的只能指针可以确保自动地释放它

- 静态内存：保存局部static对象，类static数据成员以及定义在任何函数之外的变量
- 栈内存：用来保存定义在函数内的非static对象

分配在静态内存和栈内存的对象由编译器创建和销毁。栈对象在程序块运行时创建，程序块结束时销毁；static对象在使用之前分配，在程序结束时销毁。

除了静态内存和栈内存，每个程序还拥有一个**内存池。**这部分被称作自由空间或堆。程序用堆来存储动态分配的对象。

### 12.1 动态内存与智能指针

- new 在动态内存中为对象分配空间并返回一个指向该对象的指针
- delete 接受一个动态对象的指针，销毁该对象，并释放与之关联的内存

**智能指针**的行为类似常规指针，区别是它负责自动释放所指向的对象。定义在memory头文件

-  shared_ptr 允许多个指针指向同一个对象
- unique_ptr “独占”所指向的对象
- weak_ptr 是一种弱引用，指向shared_ptr 所管理的对象

#### 12.1.1 shared_ptr类

```c++
shared_ptr<string> p1;
shared_ptr<list<int>> p2;
```

默认初始化的智能指针中保存着一个空指针

解引用一个智能指针返回它指向的对象

<center>shared_ptr和unique_ptr都支持的操作</center>

| 操作                                     |                                                              |
| ---------------------------------------- | ------------------------------------------------------------ |
| shared_ptr\<T> sp<br />unique_ptr\<T> up | 空智能指针，可以指向类型为T的对象                            |
| p                                        | 将p作为条件判断，若p指向一个对象则为true                     |
| *p                                       | 对p解引用，获取指向的对象                                    |
| p->mem                                   |                                                              |
| p.get()                                  | 返回p中保存的指针（内置指针）。若智能指针释放了其对象，则返回的指针所指对象也消失了 |
| swap(p,q)<br />p.swap(q)                 | 交换p和q中的指针                                             |

<center>shared_ptr独有的操作</center>

| shared_ptr独有操作    |                                                              |
| --------------------- | ------------------------------------------------------------ |
| make_shared\<T>(args) | 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象（调用构造器） |
| shared_ptr\<T>p(q)    | p是shared_ptr q 的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T* |
| p = q                 | p 和 q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放 |
| p.unique()            | 若p.use_count()为1，返回true；否则返回false                  |
| p.use_count()         | 返回与p共享对象的智能指针数量；可能很慢，主要用于调试        |

##### make_shared函数

此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。定义在memory头文件中

```c++
shared_ptr<int> p3 = make_shared<int>(42);
shared_ptr<string> p4 = make_shared<string>(10,'9');
```

使用括号内的参数构造对象（调用对应的构造器）。如果不传递参数，则进行值初始化。

通常使用auto配合make_shared

##### shared_ptr的拷贝和赋值

每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象，通常称其为**引用计数**。

一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象

##### shared_ptr自动销毁所管理的对象

通过**析构函数**完成销毁工作的

shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存

##### 使用了动态生存期的资源的类

程序使用动态内存出于以下三种原因之一：

1. 程序不知道自己需要使用多少对象
2. 程序不知道所需对象的准确类型
3. 程序需要在多个对象间共享数据

#### 12.1.2 直接管理内存

##### 使用new动态分配和初始化对象

在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针

```c++
int *pi = new int;
```

动态分配的对象是**默认初始化**的，即内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化

使用直接初始化方式初始化一个动态分配的对象，可以使用传统的构造方式，也可以使用列表初始化

也可以对动态分配的内存使用**值初始化**，只需要在类型名后面跟一个空括号即可，我们当然建议值初始化，因为这样对象才有良好的定义

```c++
string *ps1 = new string; //默认初始化为空string
string *ps = new string(); //值初始化为空string
```

如果我们提供了一个括号包围的初始化器，就可以使用auto从此初始化器来推断我们想要分配的对象的类型，只有当括号中仅有单一初始化器时才可以使用auto

```c++
auto p1 = new auto(obj); //p指向一个与obj同类型的对象，该对象用obj进行初始化
```

##### 动态分配的const对象

用new分配const对象是合法的

```c++
const int *pci = new const int(1024);
```

一个动态分配的const对象必须进行初始化。对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显式初始化

##### 内存耗尽

一旦一个程序用完了所有可使用的内存，new表达式就会失败。

默认情况下，如果new不能分配所要求的内存空间，它会抛出一个**bad_alloc**的异常。可以通过改变使用new的方式组织其抛出异常。

```c++
int *p1 = new int; //分配失败时，抛出std::bad_alloc异常
int *p2 = new (nothrow) int; //分配失败时，new返回一个空指针
```

称这种形式的new为**定位new**，在19.1.2节解释。

定位new表达式允许我们向new传递额外的参数

##### 释放内存delete

delete表达式接受一个指针，指向我们想要释放的对象

delete表达式执行两个动作：

- 销毁给定的指针指向的对象
- 释放对应的内存

##### 指针值和delete

传递给delete的指针必须指向动态分配的内存，或者是一个空指针。释放并非new分配的内存，或者将相同的指针值释放多次，是未定义的。

编译器不能分辨一个指针指向的是静态还是动态分配的对象。编译器也不能分辨一个指针指向的内存是否已经被释放了。这些行为能够编译通过，但是是错误的

##### 动态对象的生命周期直到被释放

由内置指针（不是智能指针）管理的动态内存在被显示释放前一直都会存在

#### 12.1.3 shared_ptr和new结合使用

我们可以用new返回的指针来初始化智能指针

```c++
shared_ptr<int> p2(new int(42));
```

接受指针参数的智能指针构造函数是[explicit](#explicit)的，所以我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针

```c++
shared_ptr<int> p1 = new int(1024); //错误，必须使用直接初始化形式
shared_ptr<int> p2(new int(1024)); //正确
```

默认情况下，**一个用来初始化智能指针的普通指针必须指向动态内存**，因为智能指针默认使用delete释放它所关联的对象。可以将智能指针绑定到一个指向其他类型的资源的指针上（非动态内存的指针），我们需要提供自己的操作代替delete（12.1.4节）

<center>表12.3 定义和改变shared_ptr的其他方法</center>

| 定义和改变shared_ptr的其他方法 |                                                              |
| ---------------------- | ------------------------------------------------------------ |
| shared_ptr\<T> p(q)    | p管理内置指针q指向的对象；q必须指向new分配的内存，且能够转换为T* |
| shared_ptr\<T> p(u)    | p从unique_ptr u 那里接管了对象的所有权；将u置为空            |
| shared_ptr\<T> p(q,d)  | p接管了内置指针q，q需要能转换为T*。p使用可调用对象d代替delete |
| shared_ptr\<T> p(p2,d) | p是shared_ptr p2的拷贝（？ 计数是独立的还是？），唯一的区别是p将可调用对象d代替delete |
| p.reset()              | 若p是唯一指向其对象的shared_ptr,reset会释放此对象。          |
| p.reset(q)             | 若传递了可选的参数内置指针q，p将会指向q，否则p置为空（q应该会释放掉） |
| p.reset(q,d)           | 若还传递了可调用对象d，将会调用d代替delete来释放**q**        |

##### 不要混合使用普通指针和智能指针

shared_ptr可以协调对象的析构，但是仅限于其自身的拷贝（也是shared_ptr）之间

```c++
void process(shared_ptr<int> ptr){
    
}// ptr离开作用域，被销毁
shared_ptr<int> p(new int(42));//引用计数为1
process(p);//引用计数为2
int i = *p; //正确，引用计数为1
//虽然无法传递给process一个内置指针（因为构造函数是explicit的），但是可以传递给它一个临时的使用内置指针初始化的shared_ptr

int *x(new int(1024));
process(x); //错误
process(shared_ptr<int>(x));//合法的，但是内存会被释放  process执行结束退出的时候引用计数-1，这条调用结束的时候引用计数又-1，此时引用计数为0，内存会被释放，但是x仍旧指向这块内存，称为悬空指针
int j = *x; //x此时是一个悬空指针
```

**我们将shared_ptr绑定普通指针后，就将内存的管理责任交给了shared_ptr,之后我们就不应该再使用内置指针来访问shraed_ptr指向的内存了✨**

##### 不要使用get初始化另一个智能指针或为智能指针赋值

get()返回一个内置指针，是为了向无法使用智能指针的代码传递一个内置指针。使用get返回的指针的代码不能delete此指针

将另一个智能指针绑定到get返回的指针上是错误的行为

```c++
shared_ptr<int> p(new int(42));
int *q = p.get();
{
    shared_ptr<int>(q);
}//q被释放
int foo = *p; //错误，p指向的内存被释放了
```

p和q指向了相同的内存，但是是独立的所以引用计数都是1，在退出程序块时，内存已经被释放

#### 12.1.4 智能指针和异常



#### 12.1.5 unique_ptr

##### unique_str操作

某个时刻只能有一个unique_ptr指向一个给定对象。

没有类似make_shared的函数，定义unique_ptr时，需要将其绑定到一个new返回的指针上。初始化unuque_ptr也必须直接初始化

| unique_str操作                                  |                                                              |
| ----------------------------------------------- | ------------------------------------------------------------ |
| unique_ptr\<T> u1                               | 空unique_ptr，可以指向类型为T的对象。u1会使用delete释放指针；u2使用可调用对象D来释放它的指针 |
| unique_ptr\<T,D> u2                             |                                                              |
| unique_ptr\<T,D> u(d)                           | 空unique_str，指向类型为T的对象，用类型为D的对象d代替delete  |
| u = nullptr                                     |                                                              |
| u.release()                                     | u放弃对指针的控制权，返回指针，并将u置空                     |
| u.reset()<br />u.reset(q)<br />u.reset(nullptr) | 释放u指向的对象，如果提供了内置指针q，将u指向q，否则将u置空  |

```c++
unique_str<string> p2(p1.release());//指针的控制权发生了转移
```

##### 传递unique_str参数和返回unique_str

不能拷贝unique_str的规则有一个例外：**我们可以拷贝或赋值一个即将销毁的unique_str。**

```c++
unique_str<int> clone(int p){
    return unique_str<int>(new int(p));
}
```

这种特殊的拷贝将在13.6.2节介绍

##### 向unique_str传递删除器

unique_str管理删除器的方式与shared_ptr不同（在16.1.6节介绍）

```c++
unique_str<objT,delT> p (new objT,fcn);
```

这种方式与重载关联容器的比较操作类似

#### 12.1.6 weak_ptr

weak_ptr是一种**不控制所指对象生存期**的智能指针，它指向一个由shared_ptr管理的对象。将一个weak_ptr绑定到shared_ptr不会改变shared_ptr的引用计数。最后一个指向对象的shared_ptr被销毁，对象就会被释放（即使weak_ptr指向对象）

| weak_ptr操作                           |                                                              |
| -------------------------------------- | ------------------------------------------------------------ |
| weak_ptr\<T> w<br />weak_ptr\<T> w(sp) | 空weak_ptr可以指向类型为T的对象<br />与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型（是不是说反了？） |
| w = p                                  | p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象      |
| w.reset()                              | 将w置为空                                                    |
| w.use_count()                          | 与w共享对象的shared_ptr的数量                                |
| w.expired()                            | 若w.use_count()为0，返回true，否则返回false                  |
| w.lock()                               | 如果expired为true，返回一个空shared_ptr；否则返回一个指向w对象的shared_ptr |

由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock

### 12.2 动态数组

标准库提供了两种一次分配一个对象数组的方法。**C++语言定义了另一种new表达式语法，可以分配并初始化一个对象数组**。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力，原因见12.2.2节

使用容器的类可以使用默认版本的拷贝、赋值和析构操作。分配动态数组的类必须定义自己版本的操作，在拷贝、复制以及销毁对象时管理关联的内存

#### 12.2.1 new和数组

在类型名之后跟一对方括号，在其中指明要分配的对象的数目

```c++
int *pia = new int[get_size()];
```

由于返回的是一个元素类型的指针，不是一个数组类型（要注意二者的区别，数组类型与数组元素类型的指针是有区别的✨），因此不能对动态数组调用begin或end。这些函数使用数组维度（维度也是数组类型的一部分）来返回首元素和尾后元素指针。也不能使用范围for语句

==动态数组并不是数组类型✨==

##### 初始化动态分配对象的数组

默认情况下，new分配的对象，都是默认初始化的。可以对数组中的元素进行值初始化

```c++
int *pia = new int[10];
int *pia2 = new int[10](); //值初始化
string *psa = new string[10];
string *psa2 = new string[10]();
```

还可以提供一个**元素初始化器的花括号列表**。如果初始化器数目大于元素数目，new表达式失败，不会分配任何内存，抛出`bad_array_new_length`异常

##### 动态分配一个空数组是合法的

```c++
char arr[0];//错误，不能定义长度为0的数组
char *cp = new char[0]; //正确，但是cp不能解引用
```

##### 释放动态数组

使用delete[]释放动态数组

```c++
delete p; //p必须指向一个动态分配的对象或为空
delete [] pa; //pa必须指向一个动态分配的数组或为空
```

**数组中的元素按逆序销毁**

##### 智能指针和动态数组

标准库提供了可以管理new分配的数组的unique_ptr版本

```c++
unique_ptr<int[]> up(new int[10]);
up.release(); //自动用delete[]销毁其指针
```

当unique_ptr指向一个数组时无法使用点和箭头运算符，但是可以使用下标运算符来访问数组中的元素。

如果想使用shared_ptr管理一个动态数组，必须提供自己定义的删除器

```c++
shared_ptr<int> sp(new int[10], [](int *p){delete[] p;});
sp.reset();//使用lambda释放数组
```

shared_ptr未定义下标运算符，而且智能指针不支持指针算术运算。因此只能使用get获取一个内置指针，然后用它访问元素

#### 12.2.2 allocator类

new灵活上的局限之一是它将内存分配和对象构造组合在了一起。类似的delete将对象析构和内存释放组合到了一起

对于大块内存的分配，我们可能希望将内存分配和对象构造分离，这可以让我们在真正需要时才执行对象创建操作

其他的不重要，但是使用new对于没有默认构造函数的类就不能动态分配数组了。✨

##### allocator类

定义在头文件memory中

提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的

```c++
allocator<string> alloc;
auto const p = alloc.allocate(n); //分配n个未初始化的string
```

<center>标准库allocator类及其算法</center>

| 标准库allocator类及其算法 |                                                              |
| ------------------- | ------------------------------------------------------------ |
| allocator\<T> a     | 定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存 |
| a.allocate(n)       | 分配一段原始的、未构造的内存，保存n个类型为T的元素           |
| a.deallocate(p,n)   | 释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy |
| a.construct(p,args) | p必须是一个类型为T*的指针，指向一块**原始内存**；arg被传递给类型为T的构造函数，用来在p指向的内存中构造**一个**对象 |
| a.destroy(p)        | p为T*类型的指针，此算法对p指向的对象执行析构函数             |

##### allocator分配未构造的内存

还未构造对象的情况下使用原始内存是错误的，我们必须用construct构造对象。

当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。只能对真正构造了的元素使用destroy。

元素被销毁后，可以重新使用这部分内存保存其他对象，也可以使用deallocate归还给系统

##### 拷贝和填充未初始化内存的算法

| 拷贝和填充未初始化内存的算法 |                                                              |
| ---------------------------- | ------------------------------------------------------------ |
| uninitialized_copy(b,e,b2)   | 从迭代器b和e指出的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中。b2指向的内存必须足够大能够容纳这么多元素，返回递增后的目的迭代器 |
| uninitialized_copy_n(b,n,b2) | 从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中         |
| uninitialized_fill(b,e,t)    | 在迭代器b和e指向的原始内存中创建对象，对象的值均为t的拷贝    |
| uninitialized_fill_n(b,n,t)  | 从迭代器b指向的内存地址开始创建n个对象。b必须指向足够大的未构造的原始内存，能够容纳给定数量的对象 |

### 12.3 使用标准库：文本查询程序

```c++
#include <fstream>
#include <iostream>
#include <map>
#include <memory>
#include <set>
#include <sstream>
#include <vector>
class QueryResult;
class TextQuery {
public:
    using line_no = std::vector<std::string>::size_type;
    TextQuery(std::ifstream&);
    QueryResult query(const std::string&) const; // 常量成员函数

private:
    std::shared_ptr<std::vector<std::string>> file; // 输入文件
    std::map<std::string, std::shared_ptr<std::set<line_no>>> wm;
};
// 读取输入文件并建立单词到行号的映射
TextQuery::TextQuery(std::ifstream& is)
    : file(new std::vector<std::string>)
{
    std::string text;
    while (getline(is, text)) { // 读取文件中每一行
        file->push_back(text);
        int n = file->size() - 1; // 当前的行号
        std::istringstream line(text); // 将当前行文本给到string流
        std::string word;
        while (line >> word) {
            auto& lines = wm[word]; // 通过key获取值
            if (!lines) {
                lines.reset(new std::set<line_no>);
            }
            lines->insert(n); // 将行号插入set中
        }
    }
}
// 这个const限定的是this指针
QueryResult TextQuery::query(const std::string& sought) const
{
    // 未找到一个单词对应的行号的时候，返回一个指向空set的智能指针
    static std::shared_ptr<std::set<line_no>> nodata(new std::set<line_no>);
    auto loc = wm.find(sought);
    if (loc == wm.end()) {
        return QueryResult(sought, nodata, file); // 未找到
    } else {
        return QueryResult(sought, loc->second, file);
    }
}

class QueryResult {
    friend std::ostream& print(std::ostream&, const QueryResult&);

public:
    using line_no = std::vector<std::string>::size_type;
    QueryResult(std::string s, std::shared_ptr<std::set<line_no>> p, std::shared_ptr<std::vector<std::string>> f)
        : sought(s)
        , lines(p)
        , file(f)
    {
    }

private:
    // 表示要查询的单词、行号集合、文本;使用智能指针，就不需要复制文本和行号的内容，节省空间
    std::string sought;
    std::shared_ptr<std::set<line_no>> lines;
    std::shared_ptr<std::vector<std::string>> file;
};

std::ostream& print(std::ostream& os, const QueryResult& qr)
{
    os << qr.sought << " occurs " << qr.lines->size() << " " << make_plural(qr.lines->size(), "time", "s") << std::endl;
    for (auto num : *qr.lines)
        os << "\t(line " << num + 1 << ") " << *(qr.file->begin() + num) << std::endl;
    return os;
}
std::string make_plural(int i, const std::string& s1, const std::string& s2)
{
    return i > 1 ? s1 : s1 + s2;
}
```

# 第 III 部分 类设计者的工具

## 第十三章 拷贝控制

当定义一个类时，我们能够显式或隐式的指定在此类型的对象**拷贝、移动、赋值和销毁**时做什么。通过定义**拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符**和**析构函数**控制这些操作

- 拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。

- 拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。（初始化与赋值不一样）

- 析构函数定义了对象销毁时做什么

上述操作称为**拷贝控制操作**，如果未定义这些操作，编译器会自动定义缺失的操作

### 13.1 拷贝、赋值与销毁

#### 13.1.1 拷贝构造函数

一个构造函数的**第一个参数是自身类类型的引用，且任何额外的参数都有默认值**，则此构造函数是**拷贝构造函数**。拷贝构造函数的第一个参数必须是一个引用类型（一般是const的），在几种情况下会被隐式的使用，所以通常不是[explicit](#explicit)的。

##### 合成拷贝构造函数

即使我们定义了其他的构造函数，编译器也会合成一个拷贝构造函数（这点与默认构造函数不同）

合成拷贝构造函数对于某些类用来阻止我们拷贝该类类型的对象（见13.1.6节）。一般情况下，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中将非static成员拷贝到正在创建的对象中。

成员的类型决定了如何被拷贝：

- 对类类型成员，使用拷贝构造函数来拷贝
- 对内置类型直接拷贝
- 对数组类型，合成拷贝构造函数会逐一拷贝数组类型的成员（我们无法直接拷贝一个数组）；如果数组元素是类类型，使用元素的拷贝构造函数

##### 拷贝初始化

**直接初始化**要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数

**拷贝初始化**要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换

拷贝初始化通常使用拷贝构造函数来完成（有的情况下使用移动构造函数[13.6.2节]）

拷贝初始化在下列情况下会发生：

- 用=定义变量时
- 从一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个[聚合类](7.5.5聚合类)中的成员

##### 拷贝初始化参数为什么必须是引用类型？

拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远不会成功

##### 编译器可以绕过拷贝构造函数

在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象

```c++
string null_book = "9-999-99999-9"; //拷贝初始化
//改写为
string null_book("9-999-99999-9");//编译器略过了拷贝构造函数
```

**但是**，即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的

#### 13.1.2 拷贝赋值运算符

类可以控制其对象如何赋值

```c++
Sales_data trans, accum;
trans = accum;  //使用Sales_data的拷贝赋值运算符
```

与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它**合成**一个

##### 重载赋值运算符

详细内容见第十四章

重载运算符本质上是函数，其名字由`operator`关键字后接表示要定义的运算符的符号组成

重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数。对于二元运算符，右侧运算对象作为显示参数传递

**拷贝赋值运算符接受一个与其所在类类型相同的参数**，**赋值运算符通常应该返回一个指向其左侧运算对象的引用**

##### 合成拷贝赋值运算符

对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值[13.1.6]

如果拷贝赋值运算符不是上述目的，他会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

#### 13.1.3 析构函数

析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，外加一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。

析构函数没有返回值和参数，所以析构函数只有一个无法重载

==**构造函数中，成员的初始化是在函数体执行之前完成的，按照在类中出现的顺序进行初始化**==

==**析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁**==

> 1. 析构函数释放对象在生存期分配的所有资源
> 2. 不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。
> 3. 销毁类类型的成员需要执行成员自己的析构函数。
> 4. 内置类型没有析构函数所以什么也不做
> 5. 销毁一个内置指针类型的成员不会delete它所指向的对象
> 6. 智能指针是类类型，所以具有析构函数，智能指针成员在析构阶段会自动销毁

##### 什么时候会调用析构函数

- 变量在离开其作用域时
- 当一个对象被销毁时，其成员被销毁
- 容器（标准库和数组）被销毁时，元素被销毁
- 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
- 对于临时对象，创建它的完整表达式结束时被销毁

```c++
{	//新作用域
    Sales_data *p = new Sales_data;
    auto p2 = make_shared<Sales_data>(); //p2指向一个Sales_data类型的对象，make_shared会返回一个指向动态分配对象的shared指针
    Sales_data item(*p);
    vector<Sales_data> vec;
    vec.push_back(*p2);
    delete p;
}//退出局部作用域；对item、vec、p2调用析构函数
//销毁p2会递减其引用计数；如果引用计数为0，对象被释放
//销毁vec会销毁它的元素，它的元素是*p2的拷贝
```

**当指向一个对象的引用或指针离开作用域时，析构函数不会执行**，那就需要我们delete释放

##### 合成析构函数

对于某些类，合成析构函数用来阻止对象被销毁[13.1.6]。如果不是这种情况，合成析构函数的函数体为空

**析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的。**

#### 13.1.4 三/五法则

拷贝构造函数、拷贝赋值运算符和析构函数外加移动构造函数、移动赋值运算符

C++并不要求我们定义所有的这些操作，但是这些操作通常应该被看做一个整体。只需要其中一个操作，而不需要定义所有操作的情况是很少见的

##### 需要析构函数的类也需要拷贝和赋值操作

当我们决定一个类是否需要定义自己版本的拷贝控制成员时**，一个基本原则是首先确定这个类是否需要析构函数**

##### 需要拷贝操作的类也需要赋值操作，反之亦然

#### 13.1.5 使用=default

我们可以将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本

```c++
class Sales_data{
    public:
    	Sales_data() =default; //合成构造函数
    	Sales_data(const Sales_data&) = default; //合成拷贝构造函数
    	Sales_data& operator=(const Sales_data &) = default; //合成拷贝赋值运算符
    	~Sales_data() = default; //合成析构函数
}
```

当我们在类内声明=default时，合成的函数会隐式的声明成内联。如果不想合成的成员是内联的，应该只对成员的类外定义使用=default

#### 13.1.6 阻止拷贝

有些类的拷贝和操作没有意义，比如ostream。所以需要采用某种机制阻止拷贝或赋值

##### 定义删除的函数

我们可以将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**来阻止拷贝

删除的函数：我们虽然定义了它们，但不能以任何方式使用它们，在函数的参数列表后加上=delete来指出我们希望定义为删除的

```c++
struct NoCopy{
    NoCopy() = default;
    NoCopy(const NoCopy &) = delete; //阻止拷贝
    NoCopy operator=(const NoCopy&) = delete;//阻止赋值
};
```

与=default不同=delete必须出现在函数第一次声明的时候

##### 析构函数不能是删除的

```c++
struct NoDtor{
    NoDtor() = default;
    ~NoDtor() = delete;
};
NoDtor nd;  //错误，NoDtor的析构函数是删除的，所以不能定义该类的变量或临时对象
NoDtor *p = new NoDtor();//正确，虽然不能定义这种类型的变量或成员，但是可以动态分配  但是不能delete
delete p;//错误
```

##### 合成的拷贝控制成员可能是删除的

如果我们未定义拷贝控制成员，编译器会为我们定义合成的版本。如果一个类未定义构造函数，编译器会为其合成一个默认构造函数。对某些类来说，编译器将这些合成的成员定义为删除的函数：

- 如果类的某个成员的析构函数时删除的或不可访问的（private），则类的合成析构函数被定义为删除的**（析构函数被定义为删除的）**
- 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的**（拷贝构造函数被定义为删除的）**
- 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的**（拷贝赋值运算符被定义为删除的）**
- 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器（类内初始值），或是类有一个const成员，它没有类内初始化器且类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的**（构造函数被定义为删除的）**

这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的；成员有删除的或不可访问的析构函数会导致合成的默认构造函数和拷贝构造函数被定义为删除的，防止我们定义出来无法销毁的对象；对于具有引用或const成员的类，编译器不会合成默认构造函数；如果一个类有const成员，则它不能使用合成的拷贝赋值运算符，因为不能给const赋值新值；虽然能够赋值给引用一个新值，但是是改变了所引用对象的值，而无法使得两个类引用同一个值，所以合成的拷贝赋值运算符被定义为删除的

##### private拷贝控制

在新标准之前，类是通过将拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝。为了阻止友元和成员函数的访问，我们只声明不定义它们（声明但不定义一个成员函数是合法的，有一个例外见[15.2.1]）

### 13.2 拷贝控制和资源管理

通常，**管理类外资源的类**必须定义拷贝控制成员

定义拷贝操作，使得类的行为像一个值或像一个指针

类的行为像一个值，则拷贝一个对象时，副本和原对象是独立的，改变副本不会改变原对象

类的行为像一个指针，则拷贝一个对象时，副本和原对象指向的是同样的底层结构，改变副本也就改变了原对象

#### 13.2.1 行为像值的类

类值版本的HasPtr

```c++
class HasPtr{
    public:
    HasPtr(const std::string &s = std::string()):ps(new std::string(s)),i(0){}
    HasPtr(const HasPtr &p):ps(new std::string(*p.ps)),i(p.i){} //拷贝的时候重新分配一个string对象
    HasPtr& operator=(const HasPtr &);
    ~HasPtr() {delete ps;}
    private:
    std::string *ps;
    int i;
}
```

##### 类值拷贝赋值运算符

赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据

```c++
HasPtr& HasPtr::operator=(const HasPtr &rhs){
    auto newp = new string(*rhs.ps);
    delete ps;
    ps = newp;
    i = rhs.i;
    return *this;
}
```

#### 13.2.2 定义行为像指针的类

- 使用shared_ptr管理类中的资源（析构的时候比较方便）
- 引用计数（专门使用一个值来记录有多少个对象指向相同的内存，这样在析构的时候才知道能不能释放内存，相当于shared_ptr的简单实现思路）

### 13.3 交换操作

除了定义拷贝控制成员，管理资源的类通常还定义一个名为swap的函数。

有时我们需要定义自己的swap，因为有时交换指针（不直接交换对象）更加的有效率

##### swap函数应该调用swap而不是std::swap

假定我们有一个命名为Foo的类，它有一个类型为HasPtr的成员h，如果我们没有定义Foo版本的swap，那就会使用标准库版本的swap。标准库版本swap对HasPtr管理的string进行不必要的拷贝（因为对于指针我们可以直接交换指针），不需要如下操作

```c++
HasPtr temp = v1;
v1 = v2;
v2 = temp;
```

这会对HasPtr对象进行一次拷贝和两次赋值

如果我们为Foo编写的swap是如下的代码，编译器能够通过且正常运行，但是人就是与简单的默认版本的swap一样没有使用HasPtr定义的swap方法

```c++
void swap(Foo &lhs, Foo &rhs){
    std::swap(lhs.h, rhs.h);
}
```

正确的swap函数如下

```c++
void swap(Foo &lhs, Foo &rhs){
    using std::swap;
    swap(lhs.h, rhs.h);//使用了HasPtr的版本
}
```

每个swap的调用应该都是未加限定的。每个调用都应该是swap而不是std::swap。如果存在特定的swap版本则会调用特定版本否则调用标准库版本，因为其匹配程度高于std中定义的版本[16.3]

至于为什么using声明没有覆盖HasPtr版本的swap声明将在[18.2.3]解释

##### 在赋值运算符中使用swap

定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了**拷贝并交换**的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换。

这种技术的有趣之处是**自动处理了自赋值情况且天然就是异常安全的**。通过在改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确；代码中会发生异常的是拷贝构造函数的new表达式，如果真发生了异常，它也会在我们改变左侧运算对象之前发生。

### 13.4 拷贝控制示例

### 13.5 动态内存管理类

某些类需要自己进行内存分配，这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存

##### 移动构造函数和std::move

移动构造函数通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象。而且标准库保证移后源string仍然保持一个有效地、可析构的状态。对于string，我们可以想象每个string都有一个指向char数组的指针。可以假定string的移动构造函数进行了指针的拷贝，而不是为字符分配内存空间然后拷贝字符

**move函数**：定义在头文件`utility`中

- 当reallocate在新内存中构造string时，必须调用move来表示希望使用string的移动构造函数。如果漏掉了move的调用，将会使用拷贝构造函数。
- 使用move时通常不提供using声明，当我们使用move时，直接调用std::move而不是move

### 13.6 对象移动

移动而非拷贝对象会大幅度提升性能。

两个原因：

1. 在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素
2. IO类或unique_ptr这样的类，它们都包含不能被共享的资源，这些类型不能拷贝但可以移动

#### 13.6.1  右值引用

为了支持移动操作，引入了新的引用类型——**右值引用**：所谓右值引用就是必须绑定到右值的引用。我们通过&&来获得右值引用

右值引用有一个重要的性质——**只能绑定到一个将要销毁的对象**，因此可以自由的将一个右值引用的资源“移动”到另一个对象中

左值引用不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。

右值引用可以绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上

```c++
int i = 42;
int &r = i; //正确：r引用i
int &&rr = i;// 错误：不能将一个右值引用绑定到一个左值上
int &r2 = i * 42;//错误： i * 42 是一右值
const int &r3 = i * 42;//正确：可以将一个const的引用绑定到一个右值上
int &&rr2 = i * 42;//正确：将rr2绑定到乘法结果上
```

返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上

返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。不能将左值引用绑定到这类表达式上，但是可以将const的左值引用或者一个右值引用绑定到这类表达式上

##### 左值持久；右值短暂

左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象

右值引用只能绑定到临时对象，我们得知

- 所引用的对象将要被销毁
- 该对象没有其他用户

这意味着使用右值引用的代码可以自由地接管所引用的对象的资源

##### 变量是左值

变量可以看作只有一个运算对象而没有运算符的表达式。变量表达式都是左值。所以我们不能将一个右值引用绑定到一个右值引用类型的变量上

```c++
int &&rr1 = 42;
int &&rr2 = rr1; //错误，表达式rr1是左值
```

##### 标准库move函数

我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用`move`的新标准库函数来获得绑定到左值上的右值引用，此函数定义在utility中。move函数使用了我们将在16.2.6节中描述的机制来返回给定对象的右值引用

```c++
int &&rr3 = std::move(rr1); //ok
```

move告诉编译器我们有一个左值，但是希望像一个右值一样处理它。move意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它。在调用move之后，我们不能对移后源对象的值做任何假设

#### 13.6.2 移动构造函数和移动赋值运算符

移动构造函数的第一个参数是该类类型的一个引用。这个**引用参数在移动构造函数中是一个右值引用**。与拷贝构造函数一样，任何额外的参数都必须有默认实参。

除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象。

##### 移动操作、标准库容器和异常

noexcept是我们承诺一个函数不抛出异常的一种方法。我们在一个函数的参数列表和初始化列表开始的冒号之间指定noexcept

**我们必须在类头文件的声明中和定义中都指定noexcept**

##### 移动赋值运算符

移动赋值运算符执行与析构函数和移动构造函数相同的工作。如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为noexcept

##### 移后源对象必须可析构

当我们编写一个移动操作时，必须保证移后源对象进入一个可析构的状态

除此之外，移动操作还必须保证对象仍然是有效的（对象有效是指可以安全的为其赋予新值或者可以安全地使用而不依赖其当前值）。另一方面，移动操作对移后源对象中留下的值没有任何要求

##### 合成的移动操作

编译器也会合成移动构造函数和移动赋值运算符。但是合成移动操作的条件与合成拷贝操作的条件大不相同。与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。**只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会合成移动构造函数或移动赋值运算符**。编译器能够移动内置类型，如果一个类类型有对应的移动操作，编译器也能够移动这个成员。

移动操作和合成的拷贝控制成员间还有最后一个相互作用关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符也会被定义为删除的

##### 移动右值，拷贝左值

如果一个类既有移动构造函数又有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数

##### 如果没有移动构造函数，右值也会被拷贝

##### 拷贝并交换赋值运算符和移动操作

HasPtr定义了一个拷贝并交换赋值运算符，如果我们加入一个移动构造函数，它实际上也会获得一个移动赋值运算符

```c++
class HasPtr{
    public:
    HasPtr(HasPtr &&p) noexcept:ps(p.ps),i(p.i){p.ps = 0;}
    HasPtr& operator=(HasPtr rhs){swap(*this,rhs);return *this;}
};
```

对于这个赋值运算符，有一个非引用参数，意味着此参数要进行拷贝初始化，要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动（因为赋值运算右侧运算对象是左值，那么它是不能传递给右值引用的，只能使用合成拷贝构造函数拷贝并且执行赋值操作，如果右侧运算对象是一个右值引用，那么在传入的时候能够调用移动构造函数，然后再执行赋值运算符的函数体），所以单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。

移动操作永远不会隐式定义为删除的函数。如果我们显式的要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。除了一个重要例外，什么时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则。

- 与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似
- 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的
- 类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的
- 类似拷贝赋值运算符，如果有类成员是const的或是引用，则类的移动赋值运算符被定义为删除的。

##### 移动迭代器

一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说一个迭代器的解引用运算符返回一个指向元素的左值。移动迭代器的解引用运算符生成一个右值引用。我们通过标准库的`make_move_iterator`函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器

#### 13.6.3 右值引用和成员函数

如果一个成员函数同时提供拷贝和移动版本，它也能从中受益。这种允许移动的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的参数模式——一个版本接受一个指向const 的左值引用，第二个版本接受一个指向非const的右值引用。例如

```c++
void push_back(const X&);
void push_back(X&&);
```

我们能够将转换为X类型的任何对象传递给第一个版本的push_back。对于第二个版本我们只可以传递给它非const的右值，此版本与非const的右值是精确匹配的

##### 右值和左值引用成员函数(引用限定符)

```c++
string s1 = "a value", s2 = "anothrer";
s1 + s2 = "wow"; //旧标准中是ok的，新标准兼容了这个操作，但是可以在自己的类中阻止这种用法
```

我们能够强制左侧运算对象是一个左值。我们指出this的左值/右值属性的方式与定义const成员函数相同，即，在参数列表后放置一个**引用限定符**

```c++
class Foo{
	public:
    Foo &operator=(const Foo&) &;
}
```

引用限定符可以是&或者&&，分别指出this可以指向一个左值或右值，必须同时出现在函数的声明和定义中

引用限定符必须跟随在const限定符之后（如果有的话）

##### 重载和引用函数

引用限定符也可以区分重载版本，而且如果一个版本加了引用限定符，那么所有的版本都要加（这一点与const限定符不同）

## 第十四章 操作重载与类型转换

### 14.1 基本概念

重载的运算符名字由关键字operator和其后要定义的运算符号共同组成

一元运算符有一个参数，二元运算符有两个；

对于二元运算符来说，**左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数；**

​								      **如果一个运算符是成员函数，则它的第一个运算对象绑定到this指针上**

除了重载的函数调用运算符之外，其他重载运算符不能含有默认实参

| 可以被重载的运算符 |      |      |       |        |          |
| :----------------: | :--: | :--: | :---: | :----: | -------- |
|         +          |  -   |  *   |   /   |   %    | ^        |
|         &          |  \|  |  ~   |   !   |   ，   | =        |
|         <          |  >   |  <=  |  >=   |   ++   | --       |
|         <<         |  >>  |  ==  |  !=   |   &&   | \|\|     |
|         +=         |  -=  |  /=  |  %=   |   ^=   | &=       |
|        \|=         | *=*  | <<=  |  >>=  |   []   | ()       |
|         ->         | ->*  | new  | new[] | delete | delete[] |
| 不能被重载的运算符 |      |      |       |        |          |
|         ::         |  .*  |  .   |  ? :  |        |          |

##### 直接调用一个重载的运算符函数

可以像调用普通函数一行调用运算符函数

```c++
data1 + data2;
operator+(data1, data2); //等价的
```

```c++
data1 += data2;
data1.operator+=(data2); //等价的成员函数版
```

##### 某些运算符不应该被重载

某些运算符指定了运算对象求值的顺序。因为重载运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别的**逻辑与运算符、逻辑或运算符**和**逗号运算符**的运算对象求值顺序规则无法保留下来。**||**和**&&**的**短路求值属性**也无法保留，两个运算对象总是会被求值。上述运算符重载版本无法与习惯相同，因此**不建议**重载它们。

我们一般不重载逗号运算符和取地址运算符：c++语言定义了这两种运算符用于类类型对象时的特殊含义

##### 赋值和复合赋值运算符

赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用。

如果类含有算术运算符或者位运算符，则最好也提供对应的复合赋值运算符

##### 选择作为成员或者非成员

下面的准则有助于我们将运算符定义为成员函数还是非成员函数：

- **赋值（=）、下标（[]）和成员访问运算符**（->）必须是**成员**
- 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同
- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员
- 具有对称性的运算符可能转换任意一端的运算对象，因此它们通常应该是普通的非成员

```c++
string s = "world";
string t = s + "!";
string u = "hi" + s;
```

如果将string的+定义为成员函数，那么第三条语句将会报错（因为当运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象）

### 14.2 输入输出运算符

#### 14.2.1 重载输出运算符<<

输出运算符的**第一个形参**是一个**非常量ostream对象的引用**。ostream是非常量是因为写入内容会改变其状态，**第二个形参**一般来说是**常量引用**。返回值是它的ostream形参

```c++
ostream& operator<<(ostream &os, const Sales_data &item){
    //输出操作
    return os;
}
```

##### 输入输出运算符必须是非成员函数

如果是成员函数

```c++
Sales_data data;
data << cout; //如果operator<<是Sales_data的成员
```

假设输入输出运算符是某个类的成员，我们想按默认的方式使用，则它们必须是istream或ostream的成员。但是我们无法为其添加任何成员

IO运算符通常定义为友元，因为会读取非公有成员

#### 14.2.2 重载输入运算符>>

第一个形参要读取的流的引用，第二个形参将要读入到的对象的引用（不是常量，因为数据要读入到这个对象）

##### 输入时的错误

在执行输入运算符时可能发生下列错误：

- 当流含有错误类型的数据时读取操作可能失败
- 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败

### 14.3 算术和关系运算符

通常情况下，我们将算术运算符和关系运算符定义成非成员函数以允许对左侧或右侧对象的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。

一般类定义了算术运算符，也会定义对应的复合赋值运算符。此时最有效的方式是使用复合赋值来定义算术运算符。

#### 14.3.1 相等运算符

设计准则：

- 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成operator==而非一个普通的命名函数：因为用户肯定希望能使用\==比较对象，所以提供了\==就意味着用户无须在费力学习并记忆一个全新的函数名字
- 如果类定义了operator==，则该运算符应该能判断一组给定对象中是否含有重复数据
- 通常情况下，相等运算符应该具有传递性，a==b和b\==c都为真，则a\==c也应该为真
- 如果类定义了operator==，也应该定义operator!=
- 相等运算符和不等运算符中的一个应该把工作委托给另外一个，这意味着其中一个运算符应该负责实际比较对象的工作

#### 14.3.2 关系运算符

通常情况下关系运算符应该

1. 定义顺序关系，令其与关联容器中对关键字的要求一致
2. 如果类同时也含有==运算符的话，则定义一种关系令其与\==保持一致，特别是如果两个对象是!=的，那么其中一个应该<另一个

### 14.4 赋值运算符

除了拷贝赋值和移动赋值（一般是同类型对象的赋值），类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象（比如vector除了拷贝赋值和移动赋值外，还能够接受花括号内的元素列表作为参数）

##### 复合赋值运算符

复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部。

### 14.5 下标运算符

表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。

为了和下标的原始定义兼容，**下标运算符通常以所访问元素的引用作为返回值**，这样做的好处是下标可以出现在赋值运算符的任意一端。我们最好**同时定义下标运算符的常量版本和非常量版本**，当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。

```c++
class StrVec{
    public:
    std::string& operator[](std::size_t n){
        return elements[n];
    }
    const std::string& operator[](std::size_t n) const{
        return elements[n];
    }
};
```

### 14.6 递增和递减运算符

C++并不要求递增和递减运算符必须是类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数

##### 定义前置递增/递减运算符

```c++
class StrBolbPtr{
    public:
    StrBlobPtr& operator++();
    StrBolbPtr& operator--();
};
```

为了与内置版本保持一致，==**前置运算符应该返回递增或递减后对象的引用**==。注意递增和递减实现上的差别

```c++
StrBlobPtr& StrBlobPtr::operator++(){
    check(curr,"msg"); //检查curr的索引值是否有效
    ++curr;
    return *this;
}
StrBlobPtr& StrBlobPtr::operator--(){
    --curr; //如果curr是0，递减会产生一个表示无效下标的非常大的值
    check(curr,"msg"); //检查curr的索引值是否有效
    return *this;
}
```

##### 区分前置和后置运算符

为了解决区分前置和后置的问题，后置版本接受一个额外的（不被使用）int类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参

```c++
class StrBolbPtr{
    public:
    StrBlobPtr operator++(int);
    StrBolbPtr operator--(int);
};
```

为了与内置版本一致，**==后置运算符应该返回对象的原值==（**而非引用，因为原值是要被改变的，实际上这里返回的是一个右值，用完即止）。

对于后置版本，在递增对象之前需要先记录对象的状态

```c++
StrBlobPtr StrBlobPtr::operator++(int){
    StrBlobPtr ret = *this;
    ++*this;
    return ret;
}
StrBlobPtr StrBlobPtr::operator--(int){
    StrBlobPtr ret = *this;
    --*this;
    return ret;
}
```

后置运算符调用各自的前置版本来完成实际的工作

##### 显式地调用后置运算符

如上所述，我们如果想显式调用后置++，为它的整型参数传入一个值

```c++
p.operator++(0);
p.operator++();
```

### 14.7 成员访问运算符

解引用运算符和箭头运算符

解引用运算符首先检查curr是否仍在作用范围内，如果是，则返回curr所指元素的一个引用。箭头运算符不执行自己的操作，通过调用解引用运算符并返回解引用结果元素的地址。

**箭头运算符必须是类的成员**，解引用运算符通常也是

##### 对箭头运算符返回值的限定

**箭头运算符不能丢掉成员访问这个最基本的含义**。当我们重载箭头时，可以改变的是箭头从那个对象当中获取成员，而箭头获取成员这一事实永远不变。

对于形如point->mem的表达式来说，point必须是指向类对象的指针或者是一个重载了operator->的类的对象。根据point类型的不同，point->mem分别等价于

```c++
(*point).mem;
point.operator()->mem;
```

point->mem的执行过程如下所示：

1. 如果point是指针，则我们应用**内置的箭头运算符**，表达式等价于(*point).mem
2. 如果point是定义了operator->的类的一个对象，则我们使用point.operator->()的结果来获取mem。其中如果该结果是一个指针，则执行第一步；如果该结果本身含有重载的operator->()，则重复调用当前步骤。最终，当这一过程结束时程序或者返回了所需的内容，或者返回一些表示程序错误的信息。

### 14.8 函数调用运算符

类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。

```c++
class absInt{
    int operator()(int val) const{
        return val < 0 ? -val : val;
    }
};
int i = -42;
absInt absObj;
int ui = absObj(i);
```

函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符

如果类定义了调用运算符，则该类的对象称作**函数对象**。

#### 14.8.1 lambda是函数对象

当我们编写一个lambda后，编译器将该表达式翻译成一个**未命名类的未命名对象**。在lambda表达式产生的类中**含有一个重载的函数调用运算符**

```c++
stable_sort(words.begin(),words.end(),[](const string &a, const string&b){
    return a.size() < b.size();
});
//行为类似于下面这个类的未命名对象
class ShorterString{
    public:
    bool operator()(const string &a, const string&b) const{
        return a.size() < b.size();
    }
};
```

默认情况下lambda不能改变它捕获的变量，因此在默认情况下，由lambda产生的类当中的函数调用运算符是一个const成员函数。如果lambda被声明为可变的，则调用运算符就不是const的了

```c++
stable_sort(words.begin(),words.end(),ShorterString);
```

##### 表示lambda及相应捕获行为的类

上述的lambda没有捕获变量，所以只生成了函数调用运算符

当一个lambda表达式通过**引用捕获**变量时，将由程序负责确保lambda执行时引用所引对象确实存在，因此编译器可以直接使用该引用而**无须在lambda产生的类中将其存储为数据成员**

当一个lambda表达式通过**值捕获**时，该值被拷贝到lambda中，因此lambda生成的类**必须为捕获的值生成对应的数据成员**，同时创建**构造函数**来初始化数据成员

lambda产生的类不含默认构造函数、赋值运算符及默认析构函数；是否含有拷贝/移动构造函数则通常要视捕获的数据成员类型而定

#### 14.8.2 标准库定义的函数对象

标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。

头文件functional

| 算术              | 关系                 | 逻辑               |
| ----------------- | -------------------- | ------------------ |
| plus\<Type>       | equal_to\<Type>      | logical_and\<Type> |
| minus\<Type>      | not_equal_to\<Type>  | logical_or\<Type>  |
| multiplies\<Type> | greater\<Type>       | logical_not\<Type> |
| divides\<Type>    | greater_equal\<Type> |                    |
| modulus\<Type>    | less\<Type>          |                    |
| negate\<Type>     | less_equal\<Type>    |                    |

##### 在算法中使用标准库函数对象

表述运算符的函数对象常用来替换算法中默认的运算符

```c++
sort(svec.begin(),svec.end(),greater<string>());
```

标准库规定其函数对象对于指针同样适用。比较两个无关指针将产生未定义的行为，然而我们可能会希望通过比较指针的内存地址来sort指针的vector。直接这么做将产生未定义的行为，因此可以使用一个标准库函数对象来实现该目的：

```c++
vector<string*> nameTable;  //指针的vector
//错误：nameTable中的指针彼此之间没有关系，所以<产生未定义的行为
sort(nameTable.begin(),nameTable.end(),[](string *a,string *b){return a < b;});
sort(nameTable.begin(),nameTable.end(),less<string*>()); //正确
```

#### 14.8.3 可调用对象与function

可调用对象有**函数、函数指针、lambda表达式、bind创建的对象**（用来适配参数列表）以及**重载了函数调用运算符的类**

可调用对象也有类型。lambda有自己唯一的类类型，函数及函数指针的类型由返回值类型和实参类型决定。两个不同类型的可调用对象可能共享同一种**调用形式**。调用形式指明了调用返回类型以及传递给调用的实参类型。一种调用形式对应一个函数类型

```c++
int(int,int) //是一个函数类型，接受两个int，返回一个int
```

##### 不同类型可能具有相同的调用形式

对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把它们看成具有相同的类型

```c++
int add(int i, int j){return i + j;}
auto mod = [](int i,int j){return i % j;}
struct divide{
    int operator()(int i, int j){
        return i/j;
    }
};
//这几个对象共享同一种调用形式：int(int,int)
```

**函数表**：用于存储指向这些可调用对象的“指针”，c++中函数表容易通过map实现，表示运算符的string作为键，实现运算符的函数作为值

```c++
map<string,int(*)(int,int)> binops;
binops.insert({"+", add}); //正确
binops.insert({"%", mod}); //错误：mod不是一个函数指针
```

##### 标准库function类型

我们使用function的标准库解决上述的问题

|         function的操作         |                                                              |
| :----------------------------: | :----------------------------------------------------------: |
|        function\<T> f;         | f是一个用来存储可调用对象的空function，这些可调用对象的调用形式应该与函数类型T相同（即T是retType(args)） |
|    function\<T> f(nullptr);    |                   显式的构造一个空function                   |
|      function\<T> f(obj);      |                 在f中存储可调用对象obj的副本                 |
|               f                |           将f作为条件：当f含有一个可调用对象时为真           |
|            f(args)             |                  调用f中的对象，参数是args                   |
| 定义为function\<T>的成员的类型 |                                                              |
|          result_type           |            该function类型的可调用对象的返回的类型            |
|         argument_type          | 当T有一个或两个实参时定义的类型。如果T只有一个实参，则argument_type是该类型的同义词；如果T有两个实参，则first_argument_type和second_argument_type分别代表两个实参的类型 |
|      first_argument_type       |                                                              |
|      second_argument_type      |                                                              |

```c++
function<int(int,int)>
function<int(int,int)> f1 = add;
function<int(int,int)> f2 = divide();
function<int(int,int)> f3 = [](int i,int j){return i * j;};
cout << f1(4,2) <<endl;
cout << f2(4,2) <<endl;
cout << f3(4,2) <<endl;
```

直接使用function能够调用，**function重载了调用运算符**。使用function我们可以重新定义map

```c++
map<string,function<int(int,int)>> binops;
```

##### 重载的函数与function

我们不能（直接）将重载函数名字存入function类型的对象中，**解决二义性的问题的一条途径是存储函数指针**而非函数名字

```c++
int (*fp)(int,int) = add;
binops.insert({"+",fp}); //fp就限制了我们到底存储的那个版本的重载
```

也可以**使用lambda来消除二义性**

```c++
binops.insert({"+",[](int a,int b){return add(a,b);}});
```

### 14.9 重载、类型转换与运算符

转换构造函数和类型转换运算符共同决定了**类类型转换**，也称为用户定义的类型转换

#### 14.9.1 类型转换运算符

类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。

```c++
operator type() const;
```

其中type表示某种类型。类型转换运算符可以面向任意类型（除了void）进行定义，只要**该类型能够作为函数的返回类型**。（所以数组和函数类型是不可以的）允许转换成**指针或引用类型**

**类型转换运算符没有显式的返回类型，也没有形参，而且必须定义成类的成员函数**。一般不会改变待转换对象内容，所以一般定义为const

##### 定义含有类型转换运算符的类

```c++
class SmallInt{
    public:
    SmallInt(int i = 0):val(i){
        if(i<0||i>255)
            throw std::out_of_range("xxx");
    }
    operator int() const{return val;}
    private:
    	std::size_t val;
};
```

既定义了**向类类型的转换**（构造函数），也定义了从**类类型向其他类型的转换**（类型转换运算符）。

尽管编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准类型转换之前或之后

```c++
SmallInt si = 3.14; //正确的
si + 3.14; //先将si转换为int，然后再内置转换为double进行相加
```

因为类型转换运算符是隐式执行的，所以无法传递实参，故不能在类型转换运算符的定义中使用任何形参。同时尽管类型转换函数不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型的值

##### 类型转换运算符可能产生意外结果

一般类很少提供类型转换运算符，大多数情况下，类型转换自动发生，用户可能会感觉比较意外，而不是感觉受到了帮助。然后这条经验法则存在例外情况，对于类来说，**定义向bool的类型转换还是比较普遍的现象**。

意向不到的结果有可能会发生（在C++标准的早期版本中），例如，如果istream含有向bool的类型转换时，下面的代码将编译通过：

```c++
int i = 42;
cin << i;
```

输出运算符被用到输入流上理应报错，但是如果cin发生了隐式的类型转换转换为bool，进而提升为int，然后移位42位，这样就不会报错，但是与我们的期望**大相径庭**（因为bool是一种算术类型，能够被用在任何需要算术类型的上下文中）

##### 显式的类型转换运算符

C++11引入了**显式的类型转换运算符**

```c++
class SmallInt{
    public:
    //编译器不会自动执行这一类型转换
    explicit operator int() const{return val;}
};
SmallInt si = 3; //正确，构造函数没有被explicit修饰
si + 3; //错误
static_cast<int>(si) + 3; //正确：显式地请求类型转换
```

当然存在例外，如果表达式被用于条件，编译器会将显式类型转换自动的应用。即在下列位置时，显式的类型转换将被隐式执行

- if、while及do语句的条件部分
- for语句头的条件表达式
- 逻辑非运算符、逻辑或运算符、逻辑与运算符的运算对象
- 条件运算符的条件表达式

##### 转换为bool

向bool的类型转换一般发生在条件部分，所以oerator bool 一般定义为explicit的

#### 14.9.2 避免有二义性的类型转换

两种情况下可能产生多重转换路径

- 两个类提供了相同的类型转换：当A类定义了接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符时，我们就说它们提供了相同的类型转换。（都是B转换为A）
- 类定义了多个转换规则：这些转换设计的类型本身可以通过其他类型转换联系在一起。

##### 实参匹配和相同的类型转换

定义两种从B到A的转换

```c++
struct B;
struct A{
    A() = default;
    A(const B&);
};
struct B{
    operator A() const;
};
A f(const A&);
B b;
A a = f(b); //二义性错误，编译器不知道用哪个
A a1 = f(b.opeartor A()); //正确
A a2 = f(A(b)); //正确
```

##### 二义性与转换目标为内置类型的多重类型转换

如果类定义了一组类型转换，它们的转换源或者转换目标类型本身可以通过其他类型转换联系在一起，同样会产生二义性问题。经常出现在多个算数类型上

##### 重载函数和转换构造函数

```c++
struct C{
    C(int);
};
struct D{
    D(int);
};
void manip(const C&);
void manip(const D&);
manip(10); //二义性
manip(C(10)); //正确
```

##### 重载函数与用户定义的类型转换

当调用重载函数时，如果两个（多个）用户定义的类型转换都提供了可行（不是一致）匹配，则我们认为这些转换类型一样好。不会考虑可能出现的标准类型转换的级别。

```c++
struct E{
    E(double);
};
void manip(const C&);
void manip(const E&);
manip(10); //同样二义性，因为我们认为两个转换是一样好的，尽管10还需要强制转换为double(10)
```

#### 14.9.3 函数匹配与重载运算符

重载的运算符也是重载的函数，所以通用的函数匹配规则同样适用于判断在给定的表达式中到底应该使用内置运算符还是重载的运算符。

当运算符函数出现在表达式中时，候选函数集的规模要比我们使用调用运算符调用函数时更大。例如a是一种类类型则a sym b可能是

```c++
a.operatorsym(b); //成员函数
operatorsym(a,b); //普通函数
```

我们**不能通过调用形式区分当前调用是成员还是非成员**

重载运算符作用于类类型对象时，候选函数中来源有三

- 非成员版本
- 内置版本
- 如果左侧运算对象是类类型，还有定义在类中的重载版本

## 第十五章 面向对象程序设计（OOP）

面向对象程序设计基于三个基本概念：**数据抽象、继承和动态绑定**（封装、继承、多态）

继承和动态绑定对程序的编写有两方面的影响：

1. 我们可以更容易的定义与其他类相似但不完全相同的新类
2. 在使用这些相似的类编写程序时，一定程度上能够忽略它们的区别

### 15.1 OOP概述

通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似但有区别的类型；使用动态绑定，可以一定程度上忽略相似类型的区别，以统一的方式使用它们的对象

##### 继承

定义Quote表示基类，Bulk_quote表示派生类

C++中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明为**虚函数**

```c++
class Quote{
    public:
    	std::string isbn() const;
    	virtual double net_price(std::size_t n) const;
};
```

派生类通过**派生类列表**明确指出它是从哪个（哪些）基类继承而来的。

派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上`virtual`关键字，但是不是非得这么做。

C++11标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，在形参列表之后增加`override`关键字。

##### 动态绑定



### 15.2 定义基类和派生类

#### 15.2.1 定义基类

```c++
class Quote{
    public:
    	Quote() = default;
    	Quote(const std::string &book, double slaes_price):
    		bookNo(book), price(sales_price){}
    	std::string isbn() const {return bookNo;}
    	virtual double net_price(std::size_t n) const {return n * price;}
    	virtual ~Quote() = default;
    private:
    	std::string bookNo;
    protected:
    	double price = 0.0;
};
```

作为继承关系中根节点的类通常会定义一个虚析构函数

##### 成员函数与继承

遇到如 net_price 这样与类型相关的操作时，派生类必须对其重新定义

基类必须将它的两种成员函数区分开来：

- 基类希望其派生类进行覆盖的函数（通常定义为虚函数）
- 基类希望派生类直接继承而不要改变的函数

**任何构造函数之外的非静态函数都可以是虚函数**，关键字`virtual`只能出现在类的声明语句之前而不能用于类外部的函数定义。如果一个函数在基类中声明成了虚函数，则该函数在派生类中隐式地也是虚函数[15.3]

##### 访问控制与继承

派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。[15.5]节介绍关于受保护成员的知识

#### 15.2.2 定义派生类

派生类必须将其继承而来的成员函数中需要覆盖的那些**重新声明**。

我们能将**公有派生**类型的对象绑定到基类的引用或指针上

大多数类都只继承自一个类，这种形式的继承被称作单继承，派生列表中含有多于一个基类的情况将在[18.3]中介绍

##### 派生类中的虚函数

派生类经常（但不总是）覆盖它集成的虚函数。如果派生类没有覆盖则该虚函数的行为类似于其他成员，派生类继承基类的版本

##### 派生类对象及派生类向基类的类型转换

一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象。

![image-20230514181105605](https://nrwflqzr.oss-cn-beijing.aliyuncs.com/typora-img/image-20230514181105605.png)

继承自基类的部分和派生类自定义部分不一定是连续存储的，我们能够把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上

##### 派生类构造函数

派生类无法直接初始化基类成员，只能**使用基类的构造函数来初始化它的基类部分**。派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。

```c++
Bulk_queto(const std::string& book, double p, std::size_t qty, double disc):Quote(book,p),min_qty(qty),discount(disc){}
```

首先初始化基类部分，然后按照声明的顺序依次初始化派生类的成员

##### 派生类使用基类成员

派生类可以访问基类的公有成员和受保护成员

##### 继承与静态成员

如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。

静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它

##### 派生类的声明

==**声明中包含类名但是不包含它的派生列表**==

##### 被用作基类的类

**如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明**

一个类是基类也可以是派生类

```c++
class Base{};
class D1:public Base{};
class D2:public D1{};
```

Base是D1的**直接基类**，同时是D2的**间接基类**

##### 防止继承的发生

使用`final`阻止其他类继承该类

```c++
class NoDerived final {};
```

#### 15.2.3 类型转换与继承

##### 静态类型与动态类型

当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的**静态类型**与该表达式表示对象的**动态类型**区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型，直到运行时才可知

如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致

##### 不存在基类向派生类的隐式类型转换

存在派生向基类的类型转换是因为每个派生类都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上。但是反过来不存在

即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类到派生类的转换

```c++
Bulk_quote bulk;
Quote *itemP = &bulk; //正确
Bulk_quote *bulkP = itemP; //错误
```

编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。如果在基类中含有一个或多个虚函数，我们可以使用dynamic_cast[19.2.1]请求一个类型转换，该转换的安全检查将在运行时执行。如果我们已知某个基类向派生类的转换是安全的，则可以使用static_cast[4.11.3]来强制覆盖掉编译器的检查工作

##### 在对象之间不存在类型转换

派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。

### 15.3 虚函数

当我们使用基类引用或指针调用一个虚函数时会执行动态绑定。我们直到运行时才能知道到底调用了哪个版本的虚函数，所以**所有虚函数都必须有定义**

##### 对虚函数的调用可能在运行时才被解析

##### 派生类中的虚函数

当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。这么做非必须，因为**一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数**

一个派生类的函数如果覆盖了某个继承而来的虚函数，则**它的形参类型必须与被它覆盖的基类函数完全一致**

派生类中虚函数的**返回类型也必须与基类函数匹配**（当类的虚函数返回类型是类本身的指着或引用时，这一规则无效，即如果D由B派生得到，则基类的虚函数可以返回B\*而派生类的对应函数可以返回D*，只不过这样的返回类型要求从D到B的类型转换时可访问的）

##### final和override说明符

如果派生类定义的函数名字与虚函数相同但是形参列表不同是合法的，但是有时可能是因为我们编写代码时发生了错误，所以提供了override显式表明我们的意图，让编译器替我们检查

final修饰的函数不能被覆盖，尝试覆盖该函数的操作都将引发错误

final和override说明符出现在形参列表以及尾置返回类型之后

##### 虚函数与默认实参

虚函数也可以有默认实参，如果某次调用使用了默认实参，则该实参值由本次调用的**静态类型**决定，即如果通过基类引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本。

##### 回避虚函数的机制

使用**作用域运算符**可以让虚函数的调用不要进行动态绑定，强迫其执行虚函数的某个特定版本

```c++
double undiscounted = baseP->Quote::net_price(42);
```

该代码强调使用Quote的net_price函数，而不管baseP实际指向的对象类型是什么

### 15.4 抽象基类

##### 纯虚函数

一个纯虚函数无须定义，我们通过在函数体的位置（声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数，=0只能出现在类内部的虚函数声明语句处

```c++
double net_price(std::size_t) const = 0;
```

可以为纯虚函数提供定义，不过函数体必须定义在类的外部

##### 含有纯虚函数的类是抽象基类

含有（或者未经覆盖直接继承）纯虚函数的类是**抽象基类**。抽象基类负责定义接口，其他的类可以覆盖该接口。**不能（直接）创建一个抽象基类的对象**。

派生类必须给出纯虚函数的定义（覆盖它），否则它们仍将是抽象基类

##### 派生类构造函数只初始化它的直接基类

### 15.5 访问控制与继承

##### 受保护的成员

一个类使用`protected`关键字来声明哪些它希望与派生类分享但是不想被其他公共访问使用的成员。protected说明符可以看做是public和private中和后的产物：

- 和私有成员类似，受保护的成员对于类的用户来说是不可访问的

- 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的

- 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。

  ```c++
  class Base{
      protected:
      	int prot_mem;
  };
  class Sneaky:public Base{
      friend void clobber(Sneaky&);
      friend void clobber(Base&);
      int j;
  };
  void clobber(Sneaky &s){s.j = s.prot_mem = 0;} //正确
  void clobber(Base &b){b.prot_mem = 0;} //错误
  ```

##### ==公有、私有和受保护继承==

1. 基类中成员的访问说明符
2. 派生类的派生列表中的访问说明符

派生访问说明符对于派生类的成员（及友元）能否访问其**直接基类**的成员没有什么影响。对基类成员的访问权限只与基类中的访问说明符有关。**派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限**。

**公有继承**中，则成员将遵循其**原有**的访问说明符；

**私有继承**中，基类的成员是全部**私有**的，因此类的用户不能访问其成员

**保护继承**中，**公有成员是受保护的**（保护访问权限用户是无法访问的，但是成员和友元可以访问）

**基类的私有成员派生也不能访问的**

##### ==派生类向基类转换的可访问性==

派生类向基类的转换是否可访问由使用该转换的代码界定，同时派生类的访问说明符也会有影响。假定D继承自B:

- 只有当D公有继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是保护或私有的，则用户代码不能使用该转换
- 不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的
- 如果D继承B的方式是公有的或受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用

##### 友元与继承

友元关系不能继承。每个类负责控制各自成员的访问权限

##### 改变个别成员的可访问性

可以通过使用using声明改变继承的某个名字的访问级别

```c++
class Base{
    public:
    	std::size_t size() const { return n; }
    protected:
    	std::size_t n;
};
class Derived : private Base{
    public:
    	using Base::size;
    protected:
    	using Base::n;
};
```

Derived使用了私有继承，所以默认情况下的size和n是私有成员。我们使用using声明语句改变了可访问性

只能够改变该类的直接或间接基类中的任何可访问成员（因为基类private权限的派生类也无法访问）。

using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。

**private部分的using声明，只能被类成员和友元访问**

**public部分的using声明，类的所有用户都可以访问**

**protected部分的using声明，类的成员、友元和派生类可以访问**

##### 默认的继承保护级别

class关键字定义的派生类是私有继承的；使用struct关键字定义的派生类是公有继承

```c++
class Base{};
struct D1 : Base {};
class D2 : Base {};
```

### 15.6 继承中的类作用域

每个类定义自己的作用域，在这个作用域中定义类的成员。当存在继承关系时，派生类的作用域嵌套在基类的作用域之内，如果一个名字在派生类的作用域内无法解析，编译器将继续在外层的基类作用域中寻找该名字的定义

##### 在编译时进行名字查找

一个对象、引用或指针的**静态类型决定了该对象的哪些成员是可见的**。即使静态类型与动态类型可能不一致，但是我们能使用哪些成员仍然是由静态类型决定的

例如，如果`Quote` -> `Disc_quote` -> `Bulk_quote`是继承关系，其中Disc_quote中有成员discount_policy()

```c++
Bulk_quote bulk;
Bulk_quote *bulkP = &bulk;
Quote *itemP = &bulk;
bulkP->discount_policy(); //正确
itemP->discount_policy()；//错误
```

即使bulk中确实有discount_policy()成员，但是对于静态类型Quote它是不可见得

##### 名字冲突与继承

派生类能重用定义在其直接基类或间接基类中的名字，此时==定义在内层作用域（派生类）的名字将**隐藏**定义在外层作用域（基类）的名字==

##### 通过作用域运算符来使用隐藏的成员

```c++
struct Derived:Base{
    int get_base_mem{return Base::mem;}
};
```

派生类最好不要重用定义在基类中的名字

> **名字查找与继承**
>
> 理解函数调用的解析过程对于理解C++的继承至关重要，假定我们调用p->mem()，则依次执行以下四个步骤：
>
> 1. 确定p的静态类型。因为我们调用的是一个成员，所以该类型必须是类类型
> 2. 在p的静态类型对应的类中查找mem。如果找不到在其直接基类中不断查找直到到达继承链的顶端。如果找遍了整个继承层次仍然找不到，则编译器将报错
> 3. 一旦找到了mem，就进行常规的类型检查以确认对于当前找到的mem，本次调用是否合法
> 4. 假设调用合法，则编译器根据调用的是否是虚函数而产生不同的代码
>    - 如果mem是虚函数且我们是通过引用或指针调用的，则编译器根据对象的动态类型确定运行该虚函数的那个版本
>    - 如果mem不是虚函数或者我们是通过对象进行的调用，编译器将产生一个常规函数调用

##### 名字查找先于类型检查

声明在内层作用域的函数并不会重载声明在外层作用域的函数，所以**定义派生类中的函数也不会重载其基类中的成员**（即使形参列表不同）

##### 虚函数与作用域

##### 通过基类调用隐藏的虚函数

调用的如果是非虚函数，不会发生动态绑定。实际调用的函数版本由指针的静态类型决定

##### 覆盖重载的函数

成员函数无论是否是虚函数都能够被重载。派生类可以覆盖重载函数的0个或多个实例。如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖

**如果仅需覆盖重载集合中的一些而非全部函数，那么就不得不覆盖基类中的每个版本，这样做非常的繁琐**

一个**解决方案**是**为重载的成员提供一条using声明语句**，这样就无须覆盖基类中的每一个版本了。using声明语句指定一个名字不指定形参列表，所以一条基类成员函数的using声明语句就把该函数的所有重载版本实例添加到派生类作用域中，此时派生类只需要定义特有的函数就可以了。

### 15.7 构造函数与拷贝控制

#### 15.7.1 虚析构函数

继承关系对基类拷贝控制最直接的影响是基类通常应该定义虚析构函数，这样我们就能动态分配继承体系中的对象了

原因是当delete一个动态分配的对象的指针时将执行析构函数。如果该指针指向的是继承体系中的某个类型，那就可能出现指针的静态类型和被删除对象的动态类型不符的情况，所以我们需要**虚析构函数**（确保析构函数能够执行正确的版本）

**与其他虚函数一样，虚析构函数的虚属性也会被继承**。所以派生类使用合成的析构函数还是定义自己的析构函数，都将是虚析构函数

##### 虚析构函数将阻止合成移动操作

基类需要一个虚析构函数还会对基类和派生类的定义产生另外一个间接的影响：如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类生成合成移动操作

#### 15.7.2 合成拷贝控制与继承

基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁操作。此外，合成的成员还负责使用直接基类的对应操作对一个对象的基类部分初始化、赋值或销毁

无论基类是合成的版本还是自定义的版本都没有太大影响。唯一的要求是相应的成员应该可访问并且不是一个被删除的函数

##### 派生类中删除的拷贝控制与基类的关系

基类或派生类在某些情况下将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数。此外某些定义基类的方式也有可能导致派生类成员是被删除的

- 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除或者不可访问的，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作
- 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分
- 编译器不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类该函数将是被删除的，原因是派生类对象的基类部分不可移动。如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是删除的

如果基类中没有默认、拷贝或移动构造函数，一般情况下派生类也不会定义相应的操作

##### 移动操作与继承

大多数基类都会定义一个虚析构函数。因此默认情况下基类不会有合成的移动操作，而且派生类中也没有合成的移动操作

**基类缺少移动操作会阻止派生类拥有自己的合成移动操作**，所以当我们确实需要执行移动操作时应该**先在基类中定义**，基类中可以使用合成的版本，但是需要**显式**地定义，**一旦基类定义了自己的移动操作，那么必须同时显式地定义拷贝操作**

#### 15.7.3 派生类的拷贝控制成员

派生类的构造函数在初始化阶段不但要**初始化派生类自己的成员**，还**负责初始化派生类对象的基类部分**。拷贝和移动构造函数也类似

析构函数只负责销毁派生类自己分配的资源，对象的成员是被隐式销毁的，了诶死的，派生类对象的基类部分也是自动销毁的

##### 定义派生类的拷贝或移动构造函数

当为派生类定义拷贝或移动构造函数时，通常使用对应的基类构造函数初始化对象的基类部分

```c++
class Base{};
class D : public Base{
    public:
    	D(const D& d):Base(d); //会自动将D中的基类部分拿出来为Base做初始化
    	D(D&& d) : Base(std::move(d));
};
```

##### 派生类赋值运算符

与拷贝和移动构造函数一样，派生类的赋值运算符也必须**显式**地为其基类部分赋值

```c++
Base::operator=(const Base&)//不会被自动调用
D &D::operator=(const D&rhs){
    Base::operator=(rhs); //会自动将rhs中的基类部分拿出来操作
    return *this;
}
```

##### 派生类析构函数

派生类析构函数只负责销毁由派生类自己分配的资源

```c++
class D : public Base{
    public:
    	~D(){}
};
```

#### 15.7.4 继承的构造函数

一个类只继承其直接基类的构造函数（因为一个类只初始化它的直接基类）。类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些，编译器将为它和成它们

派生类继承基类构造函数的方式是提供一条注明了基类名的using声明

```c++
class B : public D{
    public:
    using D::D;
    //xxx
};
```

**对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数**。编译器生成的构造函数形如：

```c++
derived(parms) : base(args){}
```

如果派生类有自己的数据成员，则这些成员将被默认初始化（因为这种生成的构造函数只有基类所需的参数）

##### 继承的构造函数的特点

与普通成员的using声明不一样，一个构造函数的using声明不会改变构造函数的访问级别

一个using声明语句**不能指定eexplicit或constexpr**，如果基类的构造函数有这些属性，继承的构造函数也拥有相同的属性

**当一个基类构造函数含有默认实参时，这些实参并不会被继承**。相反，**派生类将得到多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参**。例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参（没有默认实参），一个构造函数只接受一个形参

基类含有几个构造函数时，除了下述情况，派生类会继承所有这些构造函数

- 派生类定义的构造函数与基类的构造函数具有相同的形参列表，则该构造函数不会被继承。定义在派生类中的构造函数将替换继承而来的额构造函数
- 默认、拷贝和移动构造函数不会被继承。按照正常的规则被合成

### 15.8 容器与继承

当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式。因为**不允许在容器中保存不同类型的元素**，所以**不能把具有继承关系的多种类型的对象直接存放在容器中**

假定一个vector保存派生类对象，那么我们**不能将基类对象放入容器中**（因为基类对象无法转换为派生类对象）；也不能使用vector保存基类对象，虽然此时可以将派生类对象放置在容器中，但是**拷贝给容器时只有基类部分被拷贝，派生类部分被忽略掉**

##### 在容器中放置（智能）指针而非对象

在容器中放置基类对象的指针（智能指针）更好，这样继承层次中的类都能够加入到容器中

无法直接使用对象进行面向对象编程，必须使用指针和引用

## 第十六章 模板与泛型编程

OOP和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：**OOP能处理程序在运行之前都不知道类型的情况；泛型编程则在编译时就能获知类型**

### 16.1 定义模板

#### 16.1.1 函数模板

一个函数模板就是一个公式，可以用来生成针对特定类型的函数版本

```c++
template <typename T>
int compare(const T &v1, const T &v2){
    if(v1 < v2) return -1;
    if(v2 < v1) return 1;
    return 0;
}
```

模板定义以关键字`template`开始，后跟一个模板参数列表

##### 实例化函数模板

当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参

```c++
cout << compare(1,0) << endl; //T为int
```

编译器用推断出的模板参数来为我们实例化一个特定版本的函数。

##### 模板类型参数

可以将类型参数看做类型说明符，就像内置类型或类类型说明符一样使用

类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换

类型参数前必须使用关键字`class`或`typename`

##### 非类型模板参数

除了定义类型参数，还可以在模板中定义**非类型参数**。非类型参数表示一个值而非一个类型。我们通过一个**特定的类型名**而非关键字class或typename来指定非类型参数

当一个模板被实例化时，非类型参数被一个**用户提供的或编译器推断出的值**所代替，这些值必须是**常量表达式**。

例如，由于不能拷贝数组（所以用指针或者数组的引用），我们可以定义两个非类型的参数来表示不同长度的字符串字面量

```c++
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M]){
    return strcmp(p1,p2);
}
```

当我们调用这个版本的compare时，编译器会用字面常量的大小代替N和M

```c++
compare("hi", "mom");
```

一个非类型参数可以是一**整型**，或者是一个**指向对象或函数类型的指针**或（左值）**引用**。

绑定到非类型整型参数的实参必须是一个**常量表达式。**

绑定到指针或引用非类型参数必须具有**静态的生存期**。我们不能用一个普通（非static）局部变量或动态对象作为指针或引用非类型模板参数的实参。

指针参数也可以用nullptr或一个值为0的常量表达式来实例化。

##### inline和constexpr的函数模板

函数模板可以声明为inline或constexpr的，如同非模板函数一样。inline或constexpr放在**模板参数列表之后，返回类型之前**

##### 编写类型无关的代码

泛型代码的两个重要原则：

- 模板中的函数参数是const的引用
- 函数体中的条件判断仅使用<比较运算符

通过将函数参数设定为const的引用，我们保证了函数可以用于不能拷贝的类型，并且如果用来处理大对象，这种方式还能够提高效率

##### 模板编译

编译器遇到一个模板定义时，并不生成代码。只有当我们实例化出模板的特定版本时，编译器才会生成代码。

为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，模板的头文件通常既包括声明也包括定义

##### 大多数编译错误在实例化期间报告

通常，编译器会在三个阶段报告错误

1. 编译模板本身时，编译器此时能够检查语法错误
2. 编译器遇到模板使用时，对于函数模板调用，编译器通常会检查实参数目是否正确。参数类型是否匹配；对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此
3. 模板实例化时，这时才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。



#### 16.1.2 类模板

编译器不能像函数模板一样为类模板推断模板参数类型，使用类模板必须在尖括号中提供额外信息

##### 实例化类模板

一个类模板的每个实例都形成一个独立的类。类型Blob\<string>与其他Blob类型都没有关联，也不会对其他任何Blob类型的成员有特殊访问权限

##### 类模板的成员函数

类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己的版本成员函数。类模板的成员函数具有和模板相同的模板参数，因此定义类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表

当类外定义一个成员时，必须说明成员属于那个类。而且，从一个模板生成的类的名字中必须包含其模板实参

##### 类模板成员函数的实例化

默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。

如果一个成员函数没有被使用，则它不会被实例化。成员函数只有在被用到时才进行实例化，这一个特性使得即使某种类型不能完全符合模板操作的要求，我们仍能用该类型实例化类

##### 在类代码内简化模板类名的使用

使用一个类模板时必须提供模板实参，但是有一个例外，在类模板自己的作用域中，我们可以直接使用模板名而不提供实参

```c++
template <typename T> class BlobPtr{
	public:
    	BlobPtr() : curr(0){}
    	//xxx
    	BlobPtr& operator++();
    	//xxx
};
```

BlobPtr的前置递增运算符返回BlobPtr&而不是BlobPtr\<T>，这样是可以的编译器处理时就像我们提供了与模板参数匹配的实参一样

##### 在类模板外使用类模板名

当我们在类模板外定义其成员时，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域

```c++
template <typename T>
BlobPtr<T> BlobPtr<T>::operator++(int){
    BlobPtr ret = *this; //这里在类的作用域
}
```

返回类型位于类的作用域之外，我们必须指出返回类型是一个实例化的BlobPtr，它所用类型与类实例化所用类型一致。在函数体内我们已经进入类作用域，因此定义ret时无需重复模板实参

##### 类模板和友元

当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。

- 如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。
- 如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例

###### 一对一友好关系

类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系





