[TOC]

# 一、链表算法

## 1.1 环形链表

[环形链表II](#142、环形链表 II)快慢指针求环的开始位置

## 1.2 链表转线性表

[重排链表](#143、重排链表) 通过将链表封装到线性表中，使得链表能够方便的使用下标访问，但是又不破坏链表结构

# 二、快慢指针

[环形链表II](#142、环形链表 II)快慢指针求环的开始位置

# 三、双指针

[合并两个有序数组](#88、合并两个有序数组)采用了逆向双指针来完成两个数组的合并

[移除元素](#27、移除元素)、[删除有序数组中的重复项](#26、删除有序数组中的重复项)，这两个题目比较相似，都是用双指针来判断待处理元素和待处理元素满足条件要放置的位置

[接雨水](#42、接雨水)

[移动零](#283、移动零)

[比较含退格的字符串](844、比较含退格的字符串)

[长度最小的子数组](#209、长度最小的子数组)

# 四、前缀和


​	**前缀和**（Prefix Sum），也称为累积和，是一种在计算机科学和数学中常用的概念。它用于**快速计算数组或序列中一段连续元素的和**。

假设有一个数组或序列 `arr`，其元素为 `[a[0], a[1], a[2], ..., a[n-1]]`，前缀和数组 `prefix_sum` 可以这样计算得到：

1. 初始化一个长度为 `n` 的前缀和数组 `prefix_sum`，其中 `prefix_sum[0] = a[0]`。
2. 对于 `i` 从 `1` 到 `n-1`，执行 `prefix_sum[i] = prefix_sum[i-1] + a[i]`。

现在，`prefix_sum[i]` 表示原数组中从索引 0 到索引 `i` 的元素和。

前缀和的作用有以下几个方面：

1. **快速计算子数组和：** 前缀和可以帮助我们在 O(1) 的时间内计算出任意子数组的和。例如，要计算从 `arr[i]` 到 `arr[j]` 的子数组和，只需计算 `prefix_sum[j] - prefix_sum[i-1]`（如果 `i` 不为 0 的话）。
2. **优化区间查询：** 对于一些问题，如果需要频繁查询不同区间的和，通过预先计算前缀和，可以大幅减少重复计算，从而优化查询性能。
3. **累积统计：** 前缀和还可以用于累积统计，例如统计一个数组中小于等于某个特定值的元素个数。
4. **子数组问题：** 许多子数组问题，如连续子数组的最大/最小和、最长等差子数组等，可以利用前缀和技巧来解决。

[英雄的力量](#2681、英雄的力量)

[除自身以外数组的乘积](#238、除自身以外数组的乘积)，这个使用的是前缀积和后缀积

# 五、动态规划

[英雄的力量](#2681、英雄的力量)

[买卖股票的最佳时机](#121、买卖股票的最佳时机)

[买卖股票的最佳时机II](#122、买卖股票的最佳时机II)

[接雨水](#42、接雨水)

# 六、贪心算法

[买卖股票的最佳时机II](#122、买卖股票的最佳时机II)

[英雄的力量](#2681、英雄的力量)

[跳跃游戏](#55、跳跃游戏)

[跳跃游戏II](#45、跳跃游戏II)

[分发糖果](#135、分发糖果)

# 七、字符串相关操作算法

## 7.1 StringBuffer和StringBuilder

对于需要逐字符判断的算法使用StringBuffer和StringBuilder有一定优势

[删除注释](#722、删除注释)，使用StringBuilder逐行来判断代码是否在注释中

[字符串中的查找与替换](#833、字符串中的查找与替换)，使用了StringBuilder逐个添加合适的字符或者字符串

# 八、排序方式

## 8.1 对多个数组排序

### 8.1.1 多个对应的数组排序，保持对应关系不变

[字符串中的查找与替换](#833、字符串中的查找与替换)，其中indices、sources、targets三个数组长度相同，并且每一列的元素有对应的关系，如果对三个数组都排序可能比较繁琐，可以采用该算法中的方式，重新new一个新的数组，对其中的下标进行排序，这样indices、sources、targets数组中的顺序不变，但是获得了一个按某种方式有序的下标

```java
public String findReplaceString(String s, int[] indices, String[] sources, String[] targets) {
        int n = s.length(), m = indices.length;
		// 下面这段做了一个排序操作，对indices、sources、targets都做排序操作也是可以的，但是这里使用了一种巧妙地方法
        List<Integer> ops = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            ops.add(i);
        }
        ops.sort((i, j) -> indices[i] - indices[j]);
        ...
}
```

# 九、数学

[轮转数组](#189、轮转数组)使用了**最大公约数**

# 十、位运算

[错误的集合](#645、错误的集合)

# 十一、数据结构应用类算法

## 11.1 哈希表

哈希表的特性是能够在O(1)的时间内通过键获取元素

[O(1)时间插入、删除和获取随机元素](#380、O(1)时间插入、删除和获取随机元素)

[错误的集合](#645、错误的集合)

[数组的度](#697、数组的度)

[缺失的第一个正数](#41、缺失的第一个正数)

## 11.2 变长数组

变长数组的特性是能够在O(1)的时间内随机获取元素

[O(1)时间插入、删除和获取随机元素](#380、O(1)时间插入、删除和获取随机元素)

## 11.3 栈

[比较含退格的字符串](844、比较含退格的字符串)

### 11.3.1 单调栈

>   什么是单调栈？
>
>   -   从名字上就听的出来，单调栈中存放的数据应该是有序的，所以单调栈也分为**单调递增栈**和**单调递减栈**
>       -   单调递增栈：单调递增栈就是从栈底到栈顶数据是从大到小
>       -   单调递减栈：单调递减栈就是从栈底到栈顶数据是从小到大

[接雨水](#42、接雨水)



# 十二、数据结构实现类算法

[O(1)时间插入、删除和获取随机元素](#380、O(1)时间插入、删除和获取随机元素)

# 十三、二分法

>   使用二分法的特点：
>
>   1.   数组有序
>   2.   查找 target 位置
>
>   注意点：边界处的确定

[搜索插入位置](#35、搜索插入位置)

[在排序数组中查找元素的第一个和最后一个位置](#34、在排序数组中查找元素的第一个和最后一个位置)

[x的平方根](#69、x的平方根)



# 十四、滑动窗口

[长度最小的子数组](#209、长度最小的子数组)

[水果成篮](#904、水果成篮)

[最小覆盖子串](#76、最小覆盖子串)

# 十三、一些特殊的方法

## 13.1 `System.arraycopy` 方法

```java
public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)

    src:源数组;
    srcPos:源数组要复制的起始位置;
    dest:目的数组;
    destPos:目的数组放置的起始位置;
    length:复制的长度.
```

# 题目

## Easy

### 88、合并两个有序数组

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = m - 1, p2 = n - 1;
        int tail = m + n - 1;
        int cur;
        while (p1 >= 0 || p2 >= 0) { //这里的循环也解决了如果其中一个数组已经完整转移，然后在将另一个数组剩余元素转移
            if (p1 == -1) {
                cur = nums2[p2--];
            } else if (p2 == -1) {
                cur = nums1[p1--];
            } else if (nums1[p1] > nums2[p2]) {
                cur = nums1[p1--];
            } else {
                cur = nums2[p2--];
            }
            nums1[tail--] = cur;
        }
    }
}
```

### 27、移除元素

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

官方题解：

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int left = 0;
        int right = nums.length;
        while (left < right) {
            if (nums[left] == val) {
                nums[left] = nums[right - 1];
                right--;
            } else {
                left++;
            }
        }
        return left;
    }
}
```

```java
class Solution {
        public int removeElement(int[] nums, int val) {
        int i = 0, j = nums.length - 1;
        int temp;
        int valCount = 0;
        while (i < j) {
            while (i < j && nums[i] != val) {
                ++i;
            }
            while (i < j && nums[j] == val) {
                --j;
            }  //改进，不需要交换  ，但是官方题解即使right是val也需要交换
            temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
            --j;
            i++;
        }
        for (int k = nums.length - 1; k >= 0; --k) {
            if (nums[k] == val) {
                ++valCount;
            } else {
                break;
            }
        }
        return nums.length - valCount;
    }
}
// 更精简的写法，fast 指向的是新数组中需要的元素， slow 是新元素要放置的位置
class Solution {
        public int removeElement(int[] nums, int val) {
            int fast = slow = 0;
            for(;fast < nums.length; fast++){
                if(nums[fast] ! = val){
                    nums[slow++] = nums[fast];
                }
            }
            return slow;
        }
}
```

[移动零](#367、移动零)

### 26、删除有序数组中的重复项

给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

```java
class Solution {
    //思路其实也是双指针，index指示的是元素应该放置的位置，而num指示的是正在判断的位置，因为数组有序，并且只需要关注最终结果一定小于等于原始数组，所以直接覆盖元素即可
    public int removeDuplicates(int[] nums) {
        int element = nums[0];
        int index = 1;
        for (var num : nums) {
            if (num != element) { //非重复元素,直接覆盖即可
                nums[index++] = num;
                element = num; //修改重复元素
            }
            //如果是重复元素则什么也不做
        }
        return index;
    }
}
```

### 121、买卖股票的最佳时机

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

#### 方法一：暴力

双层循环，会超时

```java
public int maxProfit(int[] prices) {
    int max = 0;
    for (int i = 0; i < prices.length; ++i) {
        for (int j = i + 1; j < prices.length; ++j) {
            if (prices[j] > prices[i]) {
                max = Math.max((prices[j] - prices[i]), max);
            }
        }
    }
    return max;
}
```

#### 方法二：动态规划

只遍历一遍，记录当前的最小股价，并不断更新最大收益

```java
public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice) {
                minprice = prices[i];
            } else if (prices[i] - minprice > maxprofit) {
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;
    }
}
```

[买卖股票的最佳时机II](#买卖股票的最佳时机II)

### 645、错误的集合

>   集合 `s` 包含从 `1` 到 `n` 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 **丢失了一个数字** 并且 **有一个数字重复** 。
>
>   给定一个数组 `nums` 代表了集合 `S` 发生错误后的结果。
>
>   请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。
>
>   **示例 1：**
>
>   ```
>   输入：nums = [1,2,2,4]
>   输出：[2,3]
>   ```
>
>   **示例 2：**
>
>   ```
>   输入：nums = [1,1]
>   输出：[1,2]
>   ```
>
>   **提示：**
>
>   -   `2 <= nums.length <= 104`
>   -   `1 <= nums[i] <= 104`

#### 方法：哈希表

重复的数字在数组中出现 2 次，丢失的数字在数组中出现 0 次，其余的每个数字在数组中出现 1 次。因此可以使用哈希表记录每个元素在数组中出现的次数，然后遍历从 1 到 n 的每个数字，分别找到出现 2 次和出现 0 次的数字，即为重复的数字和丢失的数字。

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int[] errorNums = new int[2];
        int n = nums.length;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        for (int i = 1; i <= n; i++) {
            int count = map.getOrDefault(i, 0);
            if (count == 2) {
                errorNums[0] = i;
            } else if (count == 0) {
                errorNums[1] = i;
            }
        }
        return errorNums;
    }
}
```

#### 方法：位运算

![image-20231220150353006](%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3.images/image-20231220150353006-17030558386441.png)

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        for (int i = 1; i <= n; i++) {
            xor ^= i;
        }
        int lowbit = xor & (-xor);
        int num1 = 0, num2 = 0;
        for (int num : nums) {
            if ((num & lowbit) == 0) {
                num1 ^= num;
            } else {
                num2 ^= num;
            }
        }
        for (int i = 1; i <= n; i++) {
            if ((i & lowbit) == 0) {
                num1 ^= i;
            } else {
                num2 ^= i;
            }
        }
        for (int num : nums) {
            if (num == num1) {
                return new int[]{num1, num2};
            }
        }
        return new int[]{num2, num1};
    }
}
```

### 697、数组的度

>   给定一个非空且只包含非负数的整数数组 `nums`，数组的 **度** 的定义是指数组里任一元素出现频数的最大值。
>
>   你的任务是在 `nums` 中找到与 `nums` 拥有相同大小的度的最短连续子数组，返回其长度。
>
>   **示例 1：**
>
>   ```
>   输入：nums = [1,2,2,3,1]
>   输出：2
>   解释：
>   输入数组的度是 2 ，因为元素 1 和 2 的出现频数最大，均为 2 。
>   连续子数组里面拥有相同度的有如下所示：
>   [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
>   最短连续子数组 [2, 2] 的长度为 2 ，所以返回 2 。
>   ```
>
>   **示例 2：**
>
>   ```
>   输入：nums = [1,2,2,3,1,4,2]
>   输出：6
>   解释：
>   数组的度是 3 ，因为元素 2 重复出现 3 次。
>   所以 [2,2,3,1,4,2] 是最短子数组，因此返回 6 。
>   ```
>
>   **提示：**
>
>   -   `nums.length` 在 `1` 到 `50,000` 范围内。
>   -   `nums[i]` 是一个在 `0` 到 `49,999` 范围内的整数。

#### 方法一：哈希表

思路及解法

记原数组中出现次数最多的数为 x，那么和原数组的度相同的最短连续子数组，必然包含了原数组中的全部 x，且两端恰为 x 第一次出现和最后一次出现的位置。

因为符合条件的 x 可能有多个，即多个不同的数在原数组中出现次数相同。所以为了找到这个子数组，我们需要**统计每一个数出现的次数，同时还需要统计每一个数第一次出现和最后一次出现的位置**。

在实际代码中，我们使用哈希表实现该功能，每一个数映射到一个长度为 3 的数组，数组中的三个元素分别代表这个数出现的次数、这个数在原数组中第一次出现的位置和这个数在原数组中最后一次出现的位置。当我们记录完所有信息后，我们需要遍历该哈希表，找到元素出现次数最多，且前后位置差最小的数。

```java
class Solution {
    public int findShortestSubArray(int[] nums) {
        Map<Integer, int[]> frequency = new HashMap<>();
        for(int i = 0; i < nums.length; ++i){
            if(frequency.containsKey(nums[i])){
                frequency.get(nums[i])[0]++;  //
                frequency.get(nums[i])[2] = i; // 记录出现的最后一次位置
            }else{
                // 第一次出现
                frequency.put(nums[i], new int[]{1, i, i});
            }
        }
        int occMax = 0, minLen = nums.length; // 记录度和最小长度
        for(Map.Entry<Integer, int[]> entry: frequency.entrySet()){
            if(entry.getValue()[0] > occMax){ //如果度的大小改变，那么最小长度也无效了，因此直接将最小长度更新为新度的长度
                occMax = entry.getValue()[0];
                minLen = entry.getValue()[2] - entry.getValue()[1] + 1;
            }
            if(entry.getValue()[0] == occMax && minLen > (entry.getValue()[2] - entry.getValue()[1] + 1)){
                minLen = entry.getValue()[2] - entry.getValue()[1] + 1;
            }
        }

        return minLen;
    }
}
```

### 35、搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

**示例 1:**

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

**示例 2:**

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```

**示例 3:**

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

**提示:**

-   `1 <= nums.length <= 104`
-   `-104 <= nums[i] <= 104`
-   `nums` 为 **无重复元素** 的 **升序** 排列数组
-   `-104 <= target <= 104`

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1, mid = (right - left) / 2, flag = 0;
        while (left <= right) {
            if (nums[mid] > target) {
                right = mid - 1;
                mid = left + (right - left) / 2;
                //flag = 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
                mid = left + (right - left) / 2;
                //flag = 2;
            } else
                return mid;
        }
        /**
        if (flag == 1)
            return left;
        if (flag == 2)
            return left;
        **/
        return left;
    }
}
```

>   这是一个简单的二分法查找元素的问题，需要找到元素需要放置的位置，最终的结果是返回 left 的位置，原因如下：
>
>   首先这里的排序数组是小->大排列，那么
>
>   1.   如果 nums[mid] < target，则 target 要放在 mid + 1 的位置上
>   2.   如果 nums[mid] > target，则target 要放在 mid 的位置上
>
>   这两个位置都是 left 因此其实不需要 flag 进行标记直接返回 left 仍能得到正确的结果，如果是大->小则结论相反。

### 34、在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

**提示：**

-   `0 <= nums.length <= 105`
-   `-109 <= nums[i] <= 109`
-   `nums` 是一个非递减数组
-   `-109 <= target <= 109`

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = 0, right = nums.length - 1, mid = (right - left) / 2;
        int targetIndex = -1;
        while (left <= right) {
            if (nums[mid] > target) {
                right = mid - 1;
                mid = left + (right - left) / 2;
            } else if (nums[mid] < target) {
                left = mid + 1;
                mid = left + (right - left) / 2;
            } else{
                targetIndex = mid;
                break;
            }
        }
        int resultLeft = -1, resultRight = -1;
        if(targetIndex != -1){
            resultLeft = targetIndex - 1;
            resultRight = targetIndex + 1;
            while(resultLeft >=0 && nums[resultLeft] == target) resultLeft--;
            while(resultRight < nums.length && nums[resultRight] == target) resultRight++;
            return new int[]{resultLeft+1, resultRight - 1};
        }else{
            return new int[]{-1, -1};
        }
    }
}
```

### 69、x的平方根

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 

**示例 1：**

```
输入：x = 4
输出：2
```

**示例 2：**

```
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被去。
```

**提示：**

-   `0 <= x <= 231 - 1`

>   二分法查找满足 k ** 2 <= x 的最大的 k

```java
class Solution {
    public int mySqrt(int x) {
        int l = 0, r = x, ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((long) mid * mid <= x) { // 强转为 long 避免溢出
                ans = mid; // 记录目前最符合要求的 k 值
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
}
```

### 367、有效的完全平方数

给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。

**完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

不能使用任何内置的库函数，如 `sqrt` 。

**示例 1：**

```
输入：num = 16
输出：true
解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。
```

**示例 2：**

```
输入：num = 14
输出：false
解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。
```

**提示：**

-   `1 <= num <= 231 - 1`

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        int left = 0, right = num;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if ((long) mid * mid > num) {
                right = mid - 1;
            }
            if ((long) mid * mid < num) {
                left = mid + 1;
            }
            if ((long) mid * mid == num)
                return true;
        }
        return false;
    }
}
```

[x的平方根](#69、x的平方根)



### 283、移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

**提示**:

-   `1 <= nums.length <= 104`
-   `-231 <= nums[i] <= 231 - 1`

 ```java
 class Solution {
     public void moveZeroes(int[] nums) {
         int fast = 0, slow = 0;
         while (fast < nums.length) {
             if (nums[fast] != 0) {
                 nums[slow] = nums[fast];
                 slow++;
             }
             fast++;
         }
         for (; slow < nums.length; slow++) {
             nums[slow] = 0;
         }
     }
 }
 ```

[移除元素](#27、移除元素)



### 844、比较含退格的字符串

给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

**注意：**如果对空文本输入退格字符，文本继续为空。

**示例 1：**

```
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
```

**示例 2：**

```
输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
```

**示例 3：**

```
输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
```

**提示：**

-   `1 <= s.length, t.length <= 200`
-   `s` 和 `t` 只含有小写字母以及字符 `'#'`

#### 方法一：双指针

>   一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。
>
>   具体地，我们定义 skip 表示当前待删除的字符的数量。每次我们遍历到一个字符：
>
>   若该字符为退格符，则我们需要多删除一个普通字符，我们让 skip 加 1；
>
>   若该字符为普通字符：
>
>   若 skip 为 0，则说明当前字符不需要删去；
>
>   若 skip 不为 0，则说明当前字符需要删去，我们让 skip 减 1。
>
>   这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。



![fig1](%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3.images/1.gif)

```java
class Solution {
    public boolean backspaceCompare(String S, String T) {
        int i = S.length() - 1, j = T.length() - 1;
        int skipS = 0, skipT = 0;

        while (i >= 0 || j >= 0) {
            while (i >= 0) {
                if (S.charAt(i) == '#') {
                    skipS++;
                    i--;
                } else if (skipS > 0) {
                    skipS--;
                    i--;
                } else {
                    break;
                }
            }
            while (j >= 0) {
                if (T.charAt(j) == '#') {
                    skipT++;
                    j--;
                } else if (skipT > 0) {
                    skipT--;
                    j--;
                } else {
                    break;
                }
            }
            if (i >= 0 && j >= 0) {
                if (S.charAt(i) != T.charAt(j)) {
                    return false;
                }
            } else {
                if (i >= 0 || j >= 0) {
                    return false;
                }
            }
            i--;
            j--;
        }
        return true;
    }
}
```

#### 方法二：栈

```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        Stack<Character> s1 = new Stack<Character>();
        Stack<Character> s2 = new Stack<Character>();
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '#' && !s1.isEmpty()) {
                s1.pop();
            }
            if (s.charAt(i) == '#')
                continue;
            if (s.charAt(i) != '#')
                s1.push(s.charAt(i));

        }
        for (int i = 0; i < t.length(); i++) {
            if (t.charAt(i) == '#' && !s2.isEmpty()) {
                s2.pop();
            }
            if (t.charAt(i) == '#')
                continue;
            if (t.charAt(i) != '#')
                s2.push(t.charAt(i));
        }
        if (s1.size() != s2.size())
            return false;
        while (!s1.isEmpty() && !s2.isEmpty()) {
            if (s1.peek() == s2.peek()) {
                s1.pop();
                s2.pop();
            } else {
                return false;
            }
        }
        return true;
    }
}
```



## Medium

### 142、环形链表 II

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**思路：**

一般环形链表的解决方式是快慢指针，令 fast、slow 指针分别指向 head，fast 每次走两步，slow 每次走一步，那么 fast 每回合比 slow 多走一步，如果链表有环必然 fast 会追上 slow

1. fast.next == null or fast.next.next == null

	此时链表无环

2. fast == slow

	链表有环，那么此时记 fast 走了 f 步，slow 走了 s 步，则易有
	$$
	f = 2s  \label{eq1}
	$$
	而 f 相比于 s 多走了 n 倍的环的长度（记为 b），则有
	$$
	f = s + bn \label{eq2}
	$$
	由$\eqref{eq1}$ $\eqref{eq2}$可知，$s = bn$，理论上，指针每走 $k = a + bn (n = 0,1,2,...)$ 步能够到达环，那么 slow 继续走 a 步就能够到达环的起始位置，那么问题就变为求解 a。

	a 即为从 head 开始走到环起始位置的步数，因此只需要再使用一个指针从 head 出发，每回合走一步（slow 同时也走一步），直到二者相等此时 slow 的位置即为环的起始位置

```java
public ListNode detectCycle(ListNode head) {
    // 首先判断链表是否为空或者只有一个节点
    if(head == null || head.next == null) return null;
    ListNode fast, slow;
    fast = slow = head;
    while(fast.next != null && fast.next.next != null){
        fast = fast.next.next;  // 走两步
        slow = slow.next;	//走一步
        if(fast.next == null || fast.next.next == null)
            return null;
        if(fast == slow){	//二者第一次相遇
            fast = head;	//将 fast 从 head 开始
            while(fast != slow){	//直到再次相遇，此时获得环的起始位置
                fast = fast.next;
                slow = slow.next;
            }
            return slow;
        }
    }
    return null;
}
class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
        next = null;
    }
}
```

### 143、重排链表

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

```
L0 → L1 → … → Ln - 1 → Ln
```

请将其重新排列后变为：

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

**示例 1：**

![img](%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3.images/1626420311-PkUiGI-image.png)

```
输入：head = [1,2,3,4]
输出：[1,4,2,3]
```

```java
class Solution {
    public void reorderList(ListNode head) {
        if (head == null) {
            return;
        }
        // 将每个节点逐一加入到线性表中，方便用下标访问，对于需要移动链表节点的问题会有帮助
        List<ListNode> list = new ArrayList<ListNode>();
        ListNode node = head;
        while (node != null) {
            list.add(node);
            node = node.next;
        }
        int i = 0, j = list.size() - 1;
        while (i < j) {
            list.get(i).next = list.get(j);
            i++;
            if (i == j) {
                break;
            }
            list.get(j).next = list.get(i);
            j--;
        }
        list.get(i).next = null;
    }
}
```

### 722、删除注释

给一个 C++ 程序，删除程序中的注释。这个程序`source`是一个数组，其中`source[i]`表示第 `i` 行源码。 这表示每行源码由 `'\n'` 分隔。

在 C++ 中有两种注释风格，行内注释和块注释。

- 字符串`//`表示行注释，表示`//`和其右侧的其余字符应该被忽略。
- 字符串`/*` 表示一个块注释，它表示直到下一个（非重叠）出现的`*/`之间的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串`/*/`并没有结束块注释，因为注释的结尾与开头相重叠。

第一个有效注释优先于其他注释。

- 如果字符串`//`出现在块注释中会被忽略。
- 同样，如果字符串`/*`出现在行或块注释中也会被忽略。

如果一行在删除注释之后变为空字符串，那么**不要**输出该行。即，答案列表中的每个字符串都是非空的。

样例中**没有**控制字符，**单引号或双引号**字符。

> 所以这里没有考虑字符串中包含下述字符的样例，如果需要考虑需要在字符串中的注释，添加另外一个标记来判断是否在字符串中

- 比如，`source = "string s = "/* Not a comment. */";"` 不会出现在测试样例里。

此外，没有其他内容（如定义或宏）会干扰注释。

我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的`/*`总是开始新的注释。

最后，隐式换行符**可以**通过块注释删除。 有关详细信息，请参阅下面的示例。

从源代码中删除注释后，需要以相同的格式返回源代码。

```java
class Solution {
    public List<String> removeComments(String[] source) {
        List<String> res = new ArrayList<String>();
        StringBuilder newLine = new StringBuilder();
        boolean inBlock = false;
        for (String line : source) {
            for (int i = 0; i < line.length(); i++) {
                if (inBlock) {
                    if (i + 1 < line.length() && line.charAt(i) == '*' && line.charAt(i + 1) == '/') {
                        inBlock = false;
                        i++;
                    }
                } else {
                    if (i + 1 < line.length() && line.charAt(i) == '/' && line.charAt(i + 1) == '*') {
                        inBlock = true;
                        i++;
                    } else if (i + 1 < line.length() && line.charAt(i) == '/' && line.charAt(i + 1) == '/') {
                        break;
                    } else {
                        newLine.append(line.charAt(i));  //如果不在注释内直接加入到这一行里
                    }
                }
            }
            if (!inBlock && newLine.length() > 0) {
                res.add(newLine.toString());
                newLine.setLength(0);
            }
        }
        return res;
    }
}
```

### 833、字符串中的查找与替换

你会得到一个字符串 `s` (索引从 0 开始)，你必须对它执行 `k` 个替换操作。替换操作以三个长度均为 `k` 的并行数组给出：`indices`, `sources`, `targets`。

要完成第 `i` 个替换操作:

1. 检查 **子字符串** `sources[i]` 是否出现在 **原字符串** `s` 的索引 `indices[i]` 处。
2. 如果没有出现， **什么也不做** 。
3. 如果出现，则用 `targets[i]` **替换** 该子字符串。

例如，如果 `s = "abcd"` ， `indices[i] = 0` , `sources[i] = "ab"`， `targets[i] = "eee"` ，那么替换的结果将是 `"eeecd"` 。

所有替换操作必须 **同时** 发生，这意味着替换操作不应该影响彼此的索引。测试用例保证元素间**不会重叠** 。

- 例如，一个 `s = "abc"` ， `indices = [0,1]` ， `sources = ["ab"，"bc"]` 的测试用例将不会生成，因为 `"ab"` 和 `"bc"` 替换重叠。

*在对 `s` 执行所有替换操作后返回 **结果字符串** 。*

**子字符串** 是字符串中连续的字符序列。

> 这i个操作是无序的

```java
class Solution {
    public String findReplaceString(String s, int[] indices, String[] sources, String[] targets) {
        int n = s.length(), m = indices.length;
		// 下面这段做了一个排序操作，对indices、sources、targets都做排序操作也是可以的，但是这里使用了一种巧妙地方法
        List<Integer> ops = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            ops.add(i);
        }
        ops.sort((i, j) -> indices[i] - indices[j]);

        StringBuilder ans = new StringBuilder();
        int pt = 0; // pt指向的就是即将要做的操作
        for (int i = 0; i < n;) {
            while (pt < m && indices[ops.get(pt)] < i) {
                pt++;  //如果这个操作对应的下标在i之前，则已经做过了，直接跳过该操作
            }
            boolean succeed = false;
            // 这里为什么是一个循环操作，就是虽然成功的操作不会重叠，但是失败的操作可能是重叠的。即indices可能是[1,1,1,1]这种，但是它们对应的sources是不同的，有可能匹配上，也有可能全都匹配不上
            while (pt < m && indices[ops.get(pt)] == i) {
                if (s.substring(i, Math.min(i + sources[ops.get(pt)].length(), n)).equals(sources[ops.get(pt)])) {
                    succeed = true;
                    break;
                }
                pt++;
            }
            if (succeed) {
                ans.append(targets[ops.get(pt)]);
                // 因为成功操作是不会重叠的，所以i可以向后移动多次
                i += sources[ops.get(pt)].length();
            } else {
                ans.append(s.charAt(i));
                i++;
            }
        }
        return ans.toString();
    }
}
```

### 189、轮转数组

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例 1:**

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

**示例 2:**

```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

#### 解决方法一：使用额外数组

使用额外的数组，完全没有算法思想。亮点是使用了`arraycopy`方法

```java
public void rotate(int[] nums, int k) {
    int[] aNums = new int[nums.length];
    for (int i = 0; i < nums.length; ++i) {
        aNums[(i + k) % nums.length] = nums[i];
    }
    System.arraycopy(aNums, 0, nums, 0, nums.length);
}
```

#### 解决方法二：环状替换

可以将被替换的元素保存在一个临时变量中，这样能够避免开辟额外的数组空间。但是，从 index = 0 回到 index = 0 时，可能有些元素还没有遍历到，此时应该从下一个位置开始这一重复过程，直到遍历完所有的数字。

我的思路是使用一个count变量来判断遍历了多少元素，如果还有元素未判断则继续循环

官方思路是使用数学推导出需要多少次循环。

> 从 index = 0 回到 index = 0，则容易得到 $an = bk$，其中 a 是走过多少遍数组（圈数），b 是判断的元素的个数，则我们知道 an 是 n 和 k 的公倍数，又因为我们是第一次回到 index = 0 ，所以是最小公倍数 lcm(n,k)，b就为 lcm(n,k)/k，所以一次循环就遍历 b 个元素，一共需要
>
> $$\frac{b}{\frac{lcm(n,k)}{k}} = \frac{bk}{lcm(n,k)} = gcd(n,k)$$ 次
>
> gcd(n,k) 是最大公约数

```java
public void rotate(int[] nums, int k) {
    int temp1 = nums[0], temp2;
    int index = 0;
    int iniIndex = index;  //记录每次循环的开头位置
    int count = 0;
    while (count < nums.length) {
        temp2 = nums[(index + k) % nums.length];
        nums[(index + k) % nums.length] = temp1;
        temp1 = temp2;
        ++count;
        index = (index + k) % nums.length;
        if (count < nums.length && index == iniIndex) {
            ++index;
            iniIndex = index;
            temp1 = nums[index];
        }
    }
}

// 官方题解
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;
        int count = gcd(k, n); //计算得到需要遍历的次数
        for (int start = 0; start < count; ++start) { // 通过++则自动完成了后移
            int current = start;
            int prev = nums[start];
            do {
                int next = (current + k) % n;
                int temp = nums[next];
                nums[next] = prev;
                prev = temp;
                current = next;
            } while (start != current);
        }
    }

    public int gcd(int x, int y) {
        return y > 0 ? gcd(y, x % y) : x;
    }
}

```

#### 解决方法三：翻转数组

该方法基于如下的事实：当我们将数组的元素向右移动 k 次后，尾部 k  mod  n 个元素会移动至数组头部，其余元素向后移动 k mod n 个位置。

该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的 k  mod  n 个元素就被移至数组头部，然后我们再翻转 [0, k mod n-1] 区间的元素和[k mod n,n−1] 区间的元素即能得到最后的答案。

我们以 n=7，k=3 为例进行如下展示：

| 操作               | 结果          |
| ------------------ | ------------- |
| 原始数组           | 1 2 3 4 5 6 7 |
| 翻转所有元素       | 7 6 5 4 3 2 1 |
| 翻转[0, k mod n-1] | 5 6 7 4 3 2 1 |
| 翻转[k mod n,n−1]  | 5 6 7 1 2 3 4 |

> nums = "----->-->"; k =3 
>
> result = "-->----->"; 
>
> 
>
> reverse "----->-->" we can get "<--<-----" 
>
> reverse "<--" we can get "--><-----" 
>
> reverse "<-----" we can get "-->----->" 
>
> this visualization help me figure it out :)

```java
class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }

    public void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start += 1;
            end -= 1;
        }
    }
}
```

### 122、买卖股票的最佳时机II

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
```

#### 解决方法一：动态规划

我们使用 `dp[i][0]`、`dp[i][1]` 表示第 i 天持有股票和不持有股票的收益。考虑 `dp[i][0]`：当天不持有股票有两种情况，一种为前一天不持有股票 `dp[i-1][0]`，且今天不买入，一种为前一天持有股票。但是今日卖出 `dp[i-1][1] + prices[i]`，我们取两者的最大值；考虑 `dp[i][1]`：当天持有股票有两种情况，一种为前一天不持有股票，当日买入 `dp[i-1][0] - prices[i]`，一种为前一天持有股票今日不卖出 `dp[i-1][1]`，同样取两者最大值

```java
public int maxProfit(int[] prices) {
    int[][] dp = new int[prices.length][2];
    // 初始化
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for (int i = 1; i < prices.length; ++i) {
        // 通过转移方程计算 dp[i][0]、dp[i][1]
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    return dp[prices.length - 1][0];   //dp[prices.length-1][1] 要么是持有没卖出，要么是今日刚买入，一定没有 dp[prices.length-1][0]的收益高
}
```

**动态规划空间复杂度优化**

当日收益只与前一天收益有关，所以可以优化算法

```java
public int maxProfit(int[] prices) {
    int lastday0 = 0, lastday1 = -prices[0];
    for (int i = 1; i < prices.length; ++i) {
        // 通过转移方程计算 dp[i][0]、dp[i][1]
        int day0 = Math.max(lastday0, lastday1 + prices[i]);
        int day1 = Math.max(lastday1, lastday0 - prices[i]);
        lastday0 = day0;
        lastday1 = day1;
    }
    return lastday0;
}
```

#### 解决方法二：贪心算法

由于股票的购买没有限制，因此整个问题等价于寻找 x 个不相交的区间 (l~i~, r~i~] 使得如下的等式最大化

​                                             $$ {\textstyle \sum_{i=1}^{x}}a[r_i]-a[l_i] $$

其中 l~i~ 表示在第 l~i~ 天买入，r~i~ 表示在第 r~i~ 天卖出。同时我们注意到对于 (l~i~, r~i~] 这一个区间贡献的价值 a[r~i~]−a[l~i~]，其实等价于 (l~i~,l~i+1~],(l~i+1~,l~i+2~],…,(r~i−1~,r~i~] 这若干个区间长度为 1 的区间的价值和，即 a[r~i~]−a[l~i~]=(a[r~i~]−a[r~i−1~])+(a[r~i−1~]−a[r~i−2~])+…+(a[l~i+1~]−a[l~i~]),因此问题可以简化为找 x 个长度为 1 的区间 (l~i~,l~i~+1], 使得 $ {\textstyle \sum_{i=1}^{x}a[l_{i}+1] - a[l_i]} $价值最大化.

那么从贪心的角度讲，只要当天的股价比前一天的股价高就可以考虑买入卖出等

<img src="%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3.images/image-20230823102414684.png" alt="image-20230823102414684" style="zoom:50%;" />

只要是上坡就可以考虑买入卖出，所有上坡都买入卖出得到的利润就是最高的利润。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0;
        int n = prices.length;
        for (int i = 1; i < n; ++i) {
            ans += Math.max(0, prices[i] - prices[i - 1]);
        }
        return ans;
    }
}
```

### 55、跳跃游戏

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

```java
class Solution {
    public boolean canJump(int[] nums) {
        TreeSet<Integer> integerSet = new TreeSet<>(); //起跳位置List，也是到达位置
        boolean[] isJump = new boolean[nums.length];
        isJump[0] = true;
        integerSet.add(0);
        while (!integerSet.isEmpty()) {
            int index = integerSet.first();
            if (index == nums.length - 1) { //如果获取到最终位置，则表明可以达到，直接true
                return true;
            }
            int jump = nums[index];  //否则获取能够走的步数，因为前面的位置肯定可以到达，所以向后走
            while (jump != 0) {
                if (index + jump < nums.length && !isJump[index + jump]) {//在范围内
                    integerSet.add(index + jump);
                    isJump[index + jump] = true;
                }
                --jump;
            }
            integerSet.remove(index);  //移除已经判断过的元素
        }
        return false;
    }
} //最后一个用例超时
```

#### 方法一：贪心

我们可以用贪心的方法解决这个问题。

设想一下，对于数组中的任意一个位置 y，我们如何判断它是否可以到达？根据题目的描述，只要存在一个位置 x，它本身可以到达，并且它跳跃的最大长度为 x+nums[x]，这个值大于等于 y，即 x+nums[x]≥y，那么位置 y 也可以到达。

换句话说，对于每一个可以到达的位置 x，它使得 x+1,x+2,⋯ ,x+nums[x]这些连续的位置都可以到达。

这样以来，我们依次遍历数组中的每一个位置，并实时维护最远可以到达的位置。对于当前遍历到的位置 x，如果它在 最远可以到达的位置的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 x+nums[x] 更新最远可以到达的位置。

在遍历的过程中，如果最远可以到达的位置大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 True 作为答案。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。

```java
public class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int rightmost = 0;
        for (int i = 0; i < n; ++i) {
            if (i <= rightmost) {
                rightmost = Math.max(rightmost, i + nums[i]);
                if (rightmost >= n - 1) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

### 45、跳跃游戏II

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

#### 方法一：反向查找出发位置

我们的目标是到达数组的最后一个位置，因此我们可以考虑最后一步跳跃前所在的位置，该位置通过跳跃能够到达最后一个位置。

如果有多个位置通过跳跃都能够到达最后一个位置，那么我们应该如何进行选择呢？直观上来看，我们可以**「贪心」**地选择距离最后一个位置最远的那个位置，也就是对应下标最小的那个位置。因此，我们可以从左到右遍历数组，选择第一个满足要求的位置。

> 为什么应该选择下标最小的那个位置？
>
> 因为**「贪心」**的来看全部能够到达最后位置的下标中，对应下标最小的那个下标 i，到达下标 i 可能会需要更少的跳跃次数。而这样将该问题缩小为了规模更小的相同问题

找到最后一步跳跃前所在的位置之后，我们继续贪心地寻找倒数第二步跳跃前所在的位置，以此类推，直到找到数组的开始位置。

```java
class Solution {
    public int jump(int[] nums) {
        int position = nums.length - 1;
        int steps = 0;
        while (position > 0) {
            for (int i = 0; i < position; i++) { //从前往后不断遍历
                if (i + nums[i] >= position) {
                    position = i;
                    steps++;
                    break;
                }
            }
        }
        return steps;
    }
}
```

#### 方法二：正向查找可到达的最大位置

方法一虽然直观，但是时间复杂度比较高，有没有办法降低时间复杂度呢？

如果我们「贪心」地进行正向查找，每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。

例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。

从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。

![fig1](%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3.images/45_fig1-17031302576063.png)

在具体的实现中，我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。

在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。

```java
class Solution {
    public int jump(int[] nums) {
        int length = nums.length;
        int end = 0;
        int maxPosition = 0; 
        int steps = 0;
        for (int i = 0; i < length - 1; i++) {
            maxPosition = Math.max(maxPosition, i + nums[i]); 
            if (i == end) {
                end = maxPosition;
                steps++;
            }
        }
        return steps;
    }
}
```

> 方法二的官方思路与我的思路相同，但是实现更加的精简
>
> 不需要判断下一次起跳在什么位置，只要知道跳了一次和跳到哪里就可以了

```java
public int jump(int[] nums) {
    if (nums.length == 1) {
        return 0;
    }
    
    int[] jumpedNums = new int[nums.length];
    for (int i = 0; i < nums.length; ++i) {
        jumpedNums[i] = i + nums[i];  //记录每个索引能够跳跃的最远位置
    }

    int count = 0;
    int tempIndex = 0;  // 记录临时最远位置
    for (int i = 0; i < jumpedNums.length; ++i) {
        count++; //跳跃一次，但是跳跃到何处还未知
        tempIndex = jumpedNums[i]; // 在当前位置能够跳跃的最远位置
        if(tempIndex >= jumpedNums.length - 1){
            return count;
        }
        int nextJump = i + 1; //下一跳跳到哪里？
        for (int j = i + 2; j < jumpedNums.length && j <= tempIndex; j++) { //寻找要跳跃到的位置，该位置应该使得下一次跳跃位置最远
            if (jumpedNums[j] > jumpedNums[nextJump]) {
                nextJump = j; //找到合适的下一跳位置
            }
        }
        i = nextJump - 1;
        if (i == jumpedNums.length - 2) {
            return count;
        }
    }
    return count;
}
```

### 380、O(1)时间插入、删除和获取随机元素

实现`RandomizedSet` 类：

- `RandomizedSet()` 初始化 `RandomizedSet` 对象
- `bool insert(int val)` 当元素 `val` 不存在时，向集合中插入该项，并返回 `true` ；否则，返回 `false` 。
- `bool remove(int val)` 当元素 `val` 存在时，从集合中移除该项，并返回 `true` ；否则，返回 `false` 。
- `int getRandom()` 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 **相同的概率** 被返回。

你必须实现类的所有函数，并满足每个函数的 **平均** 时间复杂度为 `O(1)` 。

**示例：**

```
输入
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
输出
[null, true, false, true, 2, true, false, 2]

解释
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。
randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。
randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。
randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。
randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。
randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。
randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。
```

#### 方法一：变长数组 + 哈希表

这道题要求实现一个类，满足插入、删除和获取随机元素操作的平均时间复杂度为 O(1)

**变长数组**可以在 O(1) 的时间内完成获取随机元素操作，但是由于无法在 O(1) 的时间内判断元素是否存在，因此不能在 O(1) 的时间内完成插入和删除操作。**哈希表**可以在 O(1) 的时间内完成插入和删除操作，但是由于无法根据下标定位到特定元素，因此不能在 O(1) 的时间内完成获取随机元素操作。为了满足插入、删除和获取随机元素操作的时间复杂度都是 O(1)，需要将变长数组和哈希表结合，**变长数组中存储元素，哈希表中存储每个元素在变长数组中的下标**。

**插入**操作时，首先判断 val 是否在哈希表中，如果已经存在则返回 false，如果不存在则插入 val，操作如下：

1. 在变长数组的末尾添加 val；
2. 在添加 val 之前的变长数组长度为 val 所在下标 index，将 val 和下标 index 存入哈希表；
3. 返回 true。

**删除**操作时，首先判断 val 是否在哈希表中，如果不存在则返回 false，如果存在则删除 val，操作如下：

1. 从哈希表中获得 val 的下标 index；
2. 将变长数组的最后一个元素 last 移动到下标 index 处，在哈希表中将 last 的下标更新为 index；
3. 在变长数组中删除最后一个元素，在哈希表中删除 val；
4. 返回 true。

删除操作的重点在于将变长数组的最后一个元素移动到待删除元素的下标处，然后删除变长数组的最后一个元素。该操作的时间复杂度是 O(1)，且可以保证在删除操作之后变长数组中的所有元素的下标都连续，方便插入操作和获取随机元素操作。

获取随机元素操作时，由于变长数组中的所有元素的下标都连续，因此随机选取一个下标，返回变长数组中该下标处的元素。

```java
class RandomizedSet {
    List<Integer> nums; //变长数组
    Map<Integer, Integer> indices;
    Random random;

    public RandomizedSet() {
        nums = new ArrayList<Integer>();
        indices = new HashMap<Integer, Integer>();
        random = new Random();
    }

    public boolean insert(int val) {
        if (indices.containsKey(val)) {
            return false;
        }
        int index = nums.size();
        nums.add(val);
        indices.put(val, index);
        return true;
    }

    public boolean remove(int val) {
        if (!indices.containsKey(val)) {
            return false;
        }
        int index = indices.get(val);
        int last = nums.get(nums.size() - 1);
        nums.set(index, last);
        indices.put(last, index);
        nums.remove(nums.size() - 1);
        indices.remove(val);
        return true;
    }

    public int getRandom() {
        int randomIndex = random.nextInt(nums.size());
        return nums.get(randomIndex);
    }
}
```

### 238、除自身以外数组的乘积

给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请**不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。

**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

#### 方法一：前缀积和后缀积

遍历一遍数组，求得每个元素的前缀积；再反向遍历数组，求出元素的后缀积，并与对应前缀积相乘，获得最终结果

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int R = 1;
        int[] answer = new int[nums.length];
        answer[0] = 1;
        for (int i = 1; i < nums.length; ++i) {
            answer[i] = answer[i - 1] * nums[i - 1];  //前缀之积
        }
        for (int i = nums.length - 1; i > 0; --i) {
            answer[i] *= R;
            R *= nums[i];
        }
        answer[0] *= R;
        return answer;
    }
}
```

### 209、长度最小的子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

**提示：**

-   `1 <= target <= 109`
-   `1 <= nums.length <= 105`
-   `1 <= nums[i] <= 105`

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int result = Integer.MAX_VALUE;
        int sum = 0;
        int i = 0;
        int subLength = 0;
        for(int j = 0; j < nums.length; j++){
            sum += nums[j];
            while(sum >= target){
                subLength = (j - i + 1);
                result = result < subLength ? result : subLength;
                sum -= nums[i++];
            }
        }
        return result == Integer.MAX_VALUE ? 0 : result;
    }
}
```

904、水果成篮

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

-   你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
-   你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
-   一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。

**示例 1：**

```
输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
```

**示例 2：**

```
输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
```

**示例 3：**

```
输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
```

**示例 4：**

```
输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。
```

**提示：**

-   `1 <= fruits.length <= 105`
-   `0 <= fruits[i] < fruits.length`

```java
class Solution {
    //滑动窗口窗口内只能有两种元素
    public int totalFruit(int[] fruits) {
        int[] window = new int[fruits.length + 1];
        int l = 0, r = 0, ans = 0, same = 0;
        while (r < fruits.length) {
            if (window[fruits[r++]]++ == 0) same++; //这种水果是第一次添加进来，则 same++
            while (same > 2) {// same 过大则需要最左侧的水果退出窗口
                if (window[fruits[l++]]-- == 1) same--;
            }
            ans = Math.max(r - l, ans);
        }
        return ans;
    }
}
```



## Difficult

### 2681、英雄的力量

给你一个下标从 **0** 开始的整数数组 `nums` ，它表示英雄的能力值。如果我们选出一部分英雄，这组英雄的 **力量** 定义为：

- `i0` ，`i1` ，... `ik` 表示这组英雄在数组中的下标。那么这组英雄的力量为 `max(nums[i0],nums[i1] ... nums[ik])2 * min(nums[i0],nums[i1] ... nums[ik])` 。

请你返回所有可能的 **非空** 英雄组的 **力量** 之和。由于答案可能非常大，请你将结果对 `109 + 7` **取余。**

```
输入：nums = [2,1,4]
输出：141
解释：
第 1 组：[2] 的力量为 22 * 2 = 8 。
第 2 组：[1] 的力量为 12 * 1 = 1 。
第 3 组：[4] 的力量为 42 * 4 = 64 。
第 4 组：[2,1] 的力量为 22 * 1 = 4 。
第 5 组：[2,4] 的力量为 42 * 2 = 32 。
第 6 组：[1,4] 的力量为 42 * 1 = 16 。
第 7 组：[2,1,4] 的力量为 42 * 1 = 16 。
所有英雄组的力量之和为 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141 。
```

英雄组中的力量之和与最大最小值有关，所以不妨先对数组**排序**。

排序之后以 nums[i] 结尾的序列的最大值一定是 nums[i],所以我们只需要求出以 nums[i] 结尾的所有序列的最小值的和即可。我们记 dp[j] 为以 nums[j] 结尾序列的最小值之和。则 
$$
dp[j] = nums[j] + \sum_{k=0}^{j-1}dp[k] \label{eq3}
$$
显然这是一个经典的[前缀和](#前缀和)，如果定义
$$
pre\_sum[j] = \sum_{k=0}^{j}dp[k] \label{eq4}
$$
则根据 $\eqref{eq3}$ 、$\eqref{eq4}$ 有
$$
dp[j] = nums[j] + pre\_sum[j-1] \\
pre\_sum[j] = dp[j-1] + pre\_sum[j-1]
$$
通过遍历一遍 nums 数组，不断地求得 dp 和 pre_sum，获得 dp[i] 后通过 $dp[i] * nums[i] * nums[i]$ 求和获得最终结果。

```java
class Solution {
    public int sumOfPower(int[] nums) {
        Arrays.sort(nums);
        int[] dp = new int[nums.length];
        int[] preSum = new int[nums.length + 1];
        int res = 0, mod = 1000000007;
        for (int i = 0; i < nums.length; i++) {
            dp[i] = (nums[i] + preSum[i]) % mod;
            preSum[i + 1] = (preSum[i] + dp[i]) % mod;
            res = (int) ((res + (long) nums[i] * nums[i] % mod * dp[i]) % mod);
            if (res < 0) {
                res += mod;
            }
        }
        return res;
    }
}
```

### 1444、切披萨的方案数

给你一个 `rows x cols` 大小的矩形披萨和一个整数 `k` ，矩形包含两种字符： `'A'` （表示苹果）和 `'.'` （表示空白格子）。你需要切披萨 `k-1` 次，得到 `k` 块披萨并送给别人。

切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。

请你返回确保每一块披萨包含 **至少** 一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 10^9 + 7 取余的结果。

**官方题解思路**

![image-20230817190100584](%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3.images/image-20230817190100584.png)

```java
class Solution {
    public int ways(String[] pizza, int k) {
        int m = pizza.length, n = pizza[0].length(), mod = 1_000_000_007;
        int[][] apples = new int[m + 1][n + 1];
        int[][][] dp = new int[k + 1][m + 1][n + 1];

        // 预处理
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {  //从右下角开始判断
                apples[i][j] = apples[i][j + 1] + apples[i + 1][j] - apples[i + 1][j + 1] + (pizza[i].charAt(j) == 'A' ? 1 : 0);
                dp[1][i][j] = apples[i][j] > 0 ? 1 : 0; //如果有苹果则认为至少有 k = 1 的划分方式
            }
        }

        for (int ki = 2; ki <= k; ki++) {
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    // 水平方向切
                    for (int i2 = i + 1; i2 < m; i2++) {
                        if (apples[i][j] > apples[i2][j]) {// 至少苹果数目要大1，这样划分一刀才会有符合要求的情况出现
                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i2][j]) % mod;
                        }
                    }
                    // 垂直方向切
                    for (int j2 = j + 1; j2 < n; j2++) {
                        if (apples[i][j] > apples[i][j2]) {
                            dp[ki][i][j] = (dp[ki][i][j] + dp[ki - 1][i][j2]) % mod;
                        }
                    }
                }
            }
        }
        return dp[k][0][0];
    }
}
```

### 135、分发糖果

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。



**示例 1：**

```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

**示例 2：**

```
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
```

#### 方法一：爬坡法

我们可以将「相邻的孩子中，评分高的孩子必须获得更多的糖果」这句话拆分为两个规则，分别处理。

左规则：当 ratings[i−1] < ratings[i] 时，i 号学生的糖果数量将比 i−1 号孩子的糖果数量多。

右规则：当 ratings[i] > ratings[i+1] 时，i 号学生的糖果数量将比 i+1 号孩子的糖果数量多。

我们遍历该数组两次，处理出每一个学生分别满足左规则或右规则时，最少需要被分得的糖果数量。每个人最终分得的糖果数量即为这两个数量的最大值。

具体地，以左规则为例：我们从左到右遍历该数组，假设当前遍历到位置 i，如果有 ratings[i−1] < ratings[i] 那么 i 号学生的糖果数量将比 i−1 号孩子的糖果数量多，我们令 left[i]=left[i−1]+1 即可，否则我们令 left[i]=1。

在实际代码中，我们先计算出左规则 left 数组，在计算右规则的时候只需要用单个变量记录当前位置的右规则，同时计算答案即可。

为什么叫`爬坡法`呢？

1. 从左往右遍历，遇到波谷设为1，往上爬坡：如果比前一个大，就加1，如果跟前一个相等，就降为1，再继续爬坡； 
2. 从右往左遍历，遇到波谷设为1，往上爬坡：如果比后一个大，就加1，如果跟后一个相等，就降为1，再继续爬坡；

第一遍先确定右边比左边大的情况，后续再补充左边比右边大的情况

```java
class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int[] left = new int[n];
        left[0] = 1;
        for( int i = 1; i < n; ++i){
            if(ratings[i] > ratings[i - 1]){
                left[i] = left[i-1] + 1;
            }else{
                left[i] = 1;
            }
        }
        int right = 1;
        int count = 0;
        for(int i = n - 2; i>=0; i--){
            if(ratings[i+1] < ratings[i]){
                right++;
            }else{
                right = 1;
            }
            count += right > left[i] ? right : left[i];
        }
        count += left[n-1] > 1? left[n-1] : 1;
        return count;
    }
}
```

### 42、接雨水

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![img](%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3.images/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

#### 方法一：动态规划

对于下标 i，下雨后水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去 height[i]。

**朴素**的做法是对于数组 height 中的每个元素，分别向左和向右扫描并记录左边和右边的最大高度，然后计算每个下标位置能接的雨水量。假设数组 height 的长度为 n，该做法需要对每个下标位置使用 O(n) 的时间向两边扫描并得到最大高度，因此总时间复杂度是 O(n^2^)

上述做法的时间复杂度较高是因为需要对每个下标位置都向两边扫描。如果已经知道每个位置两边的最大高度，则可以在 O(n) 的时间内得到能接的雨水总量。使用动态规划的方法，可以在 O(n) 的时间内预处理得到每个位置两边的最大高度。

创建两个长度为 n 的数组 leftMax 和 rightMax。对于 0≤i<n ，leftMax[i] 表示下标 i 及其左边的位置中，height 的最大高度，rightMax[i] 表示下标 i 及其右边的位置中，height 的最大高度。

显然，leftMax[0]=height[0]，rightMax[n−1]=height[n−1]。两个数组的其余元素的计算如下：

动态规划做法可以由下图体现。

![fig1](%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3.images/1.png)

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        if (n == 0) {
            return 0;
        }

        int[] leftMax = new int[n];
        leftMax[0] = height[0];
        for (int i = 1; i < n; ++i) {
            leftMax[i] = Math.max(leftMax[i - 1], height[i]); //计算 height 中每一个元素对应的左最大值
        }

        int[] rightMax = new int[n];
        rightMax[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; --i) {
            rightMax[i] = Math.max(rightMax[i + 1], height[i]); //计算 height 中每一个元素对应的右最大值
        }

        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += Math.min(leftMax[i], rightMax[i]) - height[i]; // 每个 height 处得到的雨水量，为左右最大值中的最小值与 height 的插值
        }
        return ans;
    }
}
```

#### 方法二：单调栈

除了计算并存储每个位置两边的最大高度以外，也可以用单调栈计算能接的雨水总量。

维护一个单调栈，单调栈存储的是下标，满足从栈底到栈顶的下标对应的数组 height 中的元素递减。**(相当于保存下坡，直到碰到一个上坡**

从左到右遍历数组，遍历到下标 i 时，如果栈内至少有两个元素，记栈顶元素为 top，top 的下面一个元素是 left，则一定有 height[left]≥height[top]。如果 height[i]>height[top]，则得到一个可以接雨水的区域，该区域的宽度是 i−left−1，高度是 min⁡(height[left],height[i])−height[top]，根据宽度和高度即可计算得到该区域能接的雨水量。

为了得到 left，需要将 top 出栈。在对 top 计算能接的雨水量之后，left 变成新的 top，重复上述操作，直到栈变为空，或者栈顶下标对应的 height 中的元素大于或等于 height[i]。

在对下标 i 处计算能接的雨水量之后，将 i 入栈，继续遍历后面的下标，计算能接的雨水量。遍历结束之后即可得到能接的雨水总量。

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        Deque<Integer> stack = new LinkedList<Integer>();
        int n = height.length;
        for (int i = 0; i < n; ++i) {
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                int top = stack.pop();
                if (stack.isEmpty()) {
                    break;
                }
                int left = stack.peek();
                int currWidth = i - left - 1;
                int currHeight = Math.min(height[left], height[i]) - height[top];
                ans += currWidth * currHeight;
            }
            stack.push(i);
        }
        return ans;
    }
}
```

#### 方法三：双指针

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        while (left < right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left;
            } else {
                ans += rightMax - height[right];
                --right;
            }
        }
        return ans;
    }
}
```

### 41、缺失的第一个正数

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

**示例 1：**

```
输入：nums = [1,2,0]
输出：3
```

**示例 2：**

```
输入：nums = [3,4,-1,1]
输出：2
```

**示例 3：**

```
输入：nums = [7,8,9,11,12]
输出：1
```

**提示：**

-   `1 <= nums.length <= 5 * 105`
-   `-231 <= nums[i] <= 231 - 1`



#### 方法一：哈希表

>   如果不需要0（1）的空间复杂度，那么就用一个哈希表来将每个数保存，然后从 1 开始遍历查找哈希表中是否有需要的数，如果没有则找到最小的正数。
>
>   但是0（1）的空间复杂度需要我们利用原数组来模拟哈希表的作用，一个长度为 N 的数组，最小的正数属于 [1, N+1]（1 -- N 都出现最小的就是 N + 1），因此对于非正数和大于 N 的数我们都可以认为它们与 N + 1 效果等同，因此将所有小于等于 0 的数都置为 N + 1，这样数组中的所有数都为正数，就可以使用负号来标记某个数是否有出现。



算法的流程如下：

-   我们将数组中所有小于等于 0 的数修改为 N+1；
-   我们遍历数组中的每一个数 x，它可能已经被打了标记，因此原本对应的数为 |x|，其中 || 为绝对值符号。如果 ∣x∣∈[1,N]，那么我们给数组中的第 ∣x∣−1 个位置的数添加一个负号。注意如果它已经有负号，不需要重复添加；
-   在遍历完成之后，如果数组中的每一个数都是负数，那么答案是 N+1，否则答案是第一个正数的位置加 1。

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for(int i = 0; i < n; ++i){
            if(nums[i] <= 0){
                nums[i] = n + 1;
            }
        }
        for(int i = 0; i < n; ++i){
            if(Math.abs(nums[i]) > 0 && Math.abs(nums[i]) < n + 1 && nums[Math.abs(nums[i]) - 1] > 0){
                nums[Math.abs(nums[i]) - 1] = -nums[Math.abs(nums[i]) - 1];
            }
        }
        int result = 0;
        for(int i = 0; i < n; ++i){
            if(nums[i] > 0){
                result = i + 1;
                break;
            }
        }
        if(result == 0) return n + 1;
        else return result;
    }
}
```

#### 方法二：置换

>   除了打标记以外，我们还可以使用置换的方法，将给定的数组「恢复」成下面的形式：
>
>   如果数组中包含 x∈[1,N]，那么恢复后，数组的第 x−1 个元素为 x。
>
>   在恢复后，数组应当有 `[1, 2, ..., N]` 的形式，但其中有若干个位置上的数是错误的，每一个错误的位置就代表了一个缺失的正数。以题目中的示例二 `[3, 4, -1, 1]` 为例，恢复后的数组应当为 `[1, -1, 3, 4]`，我们就可以知道缺失的数为 2。
>
>   那么我们如何将数组进行恢复呢？我们可以对数组进行一次遍历，对于遍历到的数 x=nums[i]，如果 x∈[1,N]，我们就知道 x 应当出现在数组中的 x−1 的位置，因此交换 nums[i] 和 nums[x−1]，这样 x 就出现在了正确的位置。在完成交换后，新的 nums[i] 可能还在 [1,N] 的范围内，我们需要继续进行交换操作，直到 x∉[1,N]。
>
>   注意到上面的方法可能会陷入死循环。如果 nums[i]恰好与 nums[x−1] 相等，那么就会无限交换下去。此时我们有 nums[i]=x=nums[x−1]，说明 x 已经出现在了正确的位置。因此我们可以跳出循环，开始遍历下一个数。
>
>   由于每次的交换操作都会使得某一个数交换到正确的位置，因此交换的次数最多为 N，整个方法的时间复杂度为 O(N)。

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; ++i) {
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
    }
}
```

### 76、最小覆盖子串

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

-   对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
-   如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

 

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

**提示：**

-   `m == s.length`
-   `n == t.length`
-   `1 <= m, n <= 105`
-   `s` 和 `t` 由英文字母组成

#### 滑动窗口

```java
class Solution {
    Map<Character, Integer> ori = new HashMap<Character, Integer>();
    Map<Character, Integer> cnt = new HashMap<Character, Integer>();

    public String minWindow(String s, String t) {
        // 统计 t 中的字符种类以及字符个数
        for (int j = 0; j < t.length(); j++) {
            ori.put(t.charAt(j), ori.getOrDefault(t.charAt(j), 0) + 1);
        }
        int l = 0, r = -1;
        int len = Integer.MAX_VALUE, ansL = -1, ansR = -1;
        int sLen = s.length();
        while (r < sLen) {
            ++r;
            if (r < sLen && ori.containsKey(s.charAt(r))) {
                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);
            }
            while (check() && l <= r) { // 进入这个循环表示当前的字符串已经满足 t 的字符种类和个数，然后更新长度，并且逐个清退字符，直到不满足 t 的字符种类和个数
                if (r - l + 1 < len) {
                    len = r - l + 1;
                    ansL = l;
                    ansR = l + len;
                }
                if (ori.containsKey(s.charAt(l))) {
                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);
                }
                ++l;
            }
        }
        return ansL == -1 ? "" : s.substring(ansL, ansR);
    }

    public boolean check() {
        Iterator iter = ori.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry entry = (Map.Entry) iter.next();
            Character key = (Character) entry.getKey();
            Integer val = (Integer) entry.getValue();
            if (cnt.getOrDefault(key, 0) < val) {
                return false;
            }
        }
        return true;
    }
}
```





# 其他

## 为什么对10^9^ + 7 取模

其实不止 1e9+7 ，还有 1e9+9 和 998244353。这三个数都是一个质数，同时小于 2^30^ 。所以有什么好处呢？

1. 所有模过之后的数在加法操作在 int 范围内不会溢出，即 a,b < 2^30^,a + b < 2^31^ 。

2. 在乘法操作后在 long long 范围内不会溢出，即 ab < 2^60^ 。

# 排序算法手撕

## 1、插入排序（Insertion Sort）

>   插入排序其实就是借助这样的思想，首先我们将数组中的数据分为两个区间，一个是`已排序区间`，另一个是`未排序区间`，同时这两个区间都是`动态`的。开始时，假设最左侧的元素已被排序，即为已排序区间，每一次将未排序区间的首个数据放入排序好的区间中，直达未排序空间为空。

![img](%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3.images/v2-117cd66a561338a1635509b1c720209c_1440w-17034927464753.webp)

```java
public void InsertionSort(List<Integer> nums){
    int n = nums.length;
    for(int i = 0; i < n; ++i){
        int key = nums[i];
        int j = i - 1; //先指向已排好序元素的最后一个
        while((j >= 0) && nums[j] > key){
            nums[j + 1] = nums[j]; // 后移元素
            j--;
        }
        nums[j + 1] = key;
    }
}
```

**算法分析:**

1、**插入排序的时间复杂度？**

`最好情况`: 即该数据已经有序，我们不需要移动任何元素。于是我们需要从头到尾遍历整个数组中的元素**O(n)**.

`最坏情况`: 即数组中的元素刚好是倒序的，每次插入时都需要和已排序区间中所有元素进行比较，并移动元素。因此最坏情况下的时间复杂度是**O(n^2^)**.

`平均时间复杂度`:类似我们在一个数组中插入一个元素那样，该算法的平均时间复杂度为**O(n^2)**.

2、**插入排序是原地排序吗？**

从插入排序的原理中可以看出，在排序过程中并不需要额外的内存消耗，也就是说，插入排序是一个`原地排序算法`。

3、**插入排序是稳定的排序算法吗？**

其实，我们在插入的过程中，如果遇到相同的元素，我们可以选择将其插入到之前元素的前面也可以选择插入到后面。所以，插入排序可以是`稳定`的也可能是不稳定的。（代码中判断的是` nums[j] > key` 此时是稳定的，后面的元素不会跑到前面，如果改为`nums[j] >= key` 那么就是不稳定的，key 会插入到相同元素的最前面的位置。因此提升效率时需要保持判定条件是` nums[j] > key`。

## 2、选择排序（Selection Sort）

>   选择排序和插入排序类似，也将数组分为`已排序`和`未排序`两个区间。但是在选择排序的实现过程中，不会发生元素的`移动`，而是直接进行元素的`交换`。
>
>   选择排序的实现过程: 在不断`未排序`的区间中找到`最小`的元素，将其放入`已排序`区间的`尾部`。

![img](%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3.images/v2-fb8306ce9980f30671687af0c59ebe3b_1440w-17034929563297.webp)

```java
public void SelectionSort(List<Integer> nums){
    int n = nums.length;
    for(int i = 0; i < n; ++i){
        int index = i;
        for(int j = i + 1; j < n; ++j){
            if(nums[index] > nums[j]){
                index = j;
            }
        }
        int temp = nums[i];
        nums[i] = key;
        nums[j] = temp;
    }
}
```

**算法分析：**

`最好情况`，`最坏情况`：都需要遍历未排序区间，找到最小元素。所以都为**O(n^2)**.因此，平均复杂度也为**O(n^2)**.

**选择排序是原地排序吗？**

与插入排序一样，选择排序没有额外的内存消耗，为`原地排序算法`。

**插入排序是稳定的排序算法吗？**

答案是`否定`的，因为每次都要在未排序区间找到最小的值和前面的元素进行交换，这样如果遇到相同的元素，会使他们的顺序发生`交换`。（两个 2 的相对位置发生改变）

![img](%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3.images/v2-f3ec5dfe0e8ad7d722c0c707e1cb98ac_1440w-170349476687711.webp)

## 3、冒泡排序(Bubble Sort)

>   冒泡排序和插入排序和选择排序不太一样。冒泡排序每次只对`相邻`两个元素进行操作。每次冒泡操作，都会`比较`相邻两个元素的大小，若不满足排序要求，就将它俩`交换`。每一次冒泡，会将`一个元素`移动到它相应的位置，该元素就是未排序元素中`最大`的元素。

![img](%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3.images/v2-db5a77c34532aebc3efbc77199214258_1440w-170349486671615.webp)

```java
public void BubbleSort(List<Integer> nums){
    int n = nums.length;
    for(int i = 0; i < n; ++i){
        for(int j = i; j < n - i - 1; j++){ // 这里 n - i - 1 能够少几次不必要的判断
            if(nums[j] > nums[j + 1]){
                int temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
}
```

**算法介绍：**

**冒泡排序的时间复杂度？**

`最好情况`:我们只需要进行一次冒泡操作，没有任何元素发生交换，此时就可以结束程序，所以最好情况时间复杂度是**O(n)**.

`最坏情况`: 要排序的数据`完全倒序`排列的，我们需要进行**n**次冒泡操作，每次冒泡时间复杂度为**O(n)**,所以最坏情况时间复杂度为**O(n^2)**。

`平均复杂度`：**O(n^2)**

**冒泡排序是原地排序吗？**

冒泡的过程只涉及相邻数据之间的`交换`操作而没有额外的内存消耗，故冒泡排序为`原地排序算法`。

**冒泡排序是稳定的排序算法吗？**

在冒泡排序的过程中，只有每一次冒泡操作才会`交换`两个元素的顺序。所以我们为了冒泡排序的稳定性，在元素相等的情况下，我们不予交换，此时冒泡排序即为`稳定的排序算法`。

## 4、归并排序（Merge Sort）

>   该算法是利用`分治思想`解决问题的一个非常典型的应用，归并排序的基本思路就是先把数组一分为二，然后分别把左右数组排好序，再将排好序的左右两个数组合并成一个新的数组，最后整个数组就是有序的了。
>
>   合并的时候比较两个数组的元素大小----合并操作即排序操作

1.  申请空间，使其大小为两个已经排序序列之和，该空间用来存放`合并`后的序列。
2.  设定`两个指针`，最初位置分别为两个已经排序序列的`起始`位置。
3.  比较两个指针所指向的元素，选择`较小`的元素放入到合并空间，并将指针移动到`下一位置`。
4.  重复步骤3直到`某一指针`到达序列尾，然后将另一序列剩下的所有元素直接复制到`合并`序列尾

```java
public void MergeSort(List<Integer> arr, int left, int right){
    if(left >= right) return;
    
    int mid = left + (right - left) / 2;
    MergeSort(arr, left, mid);
    MergeSort(arr, mid + 1, right);
    Merge(arr, left, mid, right);
}

public void Merge(List<Integer> arr, int left, int mid, int right){
    int i = left;
    int j = mid + 1; // 两部分的起始 index
    List<Integer> temp = new ArrayList<>();
   	while(i <= mid && j <= right){
        temp.add(arr[i] < arr[j] ? arr[i++] : arr[j++]);
    }
    while(i < mid)
        temp.add(arr[i]);
    while(j < right)
        temp.add(arr[j]);
    for(int l = 0; l < temp.length; l++){
        arr[left + l] = temp[l];
    }
}
```

**算法分析:**

**归并排序的时间复杂度？**

归并排序的递推公式为**T(n)=2\*T(n/2)+n**

该递归式表明，对**n**个元素递归排序所需时间复杂度，等于左右子区间**n/2**个元素分别递归排序的时间，加上将两个已排好的子区间合并起来的时间**O(n)**

当递归循环至最后一层时，即**n=1**时,**T(1)=1**,于是可以推导出归并排序的时间复杂度为**O(nlongn)**

**归并排序是原地排序吗？**

从原理中可以看出，在归并排序过程中我们需要分配临时数组**temp**，所以`不是`原地排序算法，空间复杂度为**O(n)**.

**归并排序是稳定的排序算法吗？**

当我们遇到左右数组中的元素相同时，我们可以先把左边的元素放入**temp**数组中，再放入右边数组的元素，这样就保证了相同元素的前后顺序不发生改变。所以，归并排序是一个`稳定`的排序算法。
