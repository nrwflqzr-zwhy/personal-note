# Java

## 属性分类

###  属性（成员变量） vs  局部变量

1. 相同点：

    1.1  定义变量的格式：数据类型  变量名 = 变量值

    1.2  先声明，后使用

    1.3  变量都有其对应的作用域 

2. 不同点：

    2.1  在类中声明的位置的不同

    ​      - 属性：直接定义在类的一对{}内

    ​      - 局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量

​		2.2 关于权限修饰符的不同

​             - 属性：可以在声明属性时，指明其权限，使用权限修饰符。

​             - 常用的权限修饰符：private、public、缺省、protected  --->封装性

​             目前，大家声明属性时，都使用缺省就可以了。

​             - 局部变量：不可以使用权限修饰符。

​		2.3 默认初始化值的情况：

​             - 属性：类的属性，根据其类型，都有默认初始化值。

​                       整型（byte、short、int、long）：0

​                       浮点型（float、double）：0.0

​                       字符型（char）：0  （或'\u0000'）

​                       布尔型（boolean）：false

​                       引用数据类型（类、数组、接口）：null

​              - 局部变量：**没有默认初始化值**。

​                         意味着，我们在调用局部变量之前，一定要显式赋值

​                         特别地：形参在调用时，我们赋值即可

​		2.4 在内存中加载的位置：

​				- 属性：加载到堆空间中（非static）

​				- 局部变量：加载到栈空间

### 静态属性 vs 非静态属性

非静态属性又叫实例变量

实例变量：当我们创建了类的多个对象，每个对象都独立有一套类中的非静态属性。修改其中一个对象的非静态属性时，不会影响其他对象。

静态变量：类的多个对象共享同一个静态变量

-   静态变量随着类的加载而加载，可以通过"类名.静态变量"来调用
-   静态变量的加载要早于对象的创建（在类的加载中的准备阶段）

## 创建内部类的方式

```java
class Person{
    //静态成员内部类
    static class Dog{}
    //非静态成员内部类
    class Bird{}
    public void method(){
        //局部内部类
        class AA{}
    }
    {
        //局部内部类
        class BB{}
    }
    public Person(){
        //局部内部类
        class CC{}
    }
}
```

```java
Person.Dog dog = new Person.Dog(); //静态
dog.show();
//创建Bird实例(非静态的成员内部类):
//Person.Bird bird = new Person.Bird();//错误的
Person p = new Person();
Person.Bird bird = p.new Bird();//非静态
```

## 异常体系结构

```mermaid
graph TD
A[java.lang.Throwable]-->M{Error or Exception}
	M-->|error|B[java.lang.Error]
	M-->|Exception|C[java.lang.Exception]
	C-->N{checked or unchecked}
	N-->|yes|O(checked)
	N-->|no|P(UNchecked)
	O-->D[IO]
	O-->E[ClassNotFound]
	P-->G[NullPointer]
	P-->H[ArrayIndexOutOfBounds]
	P-->I[ClassCast]
	P-->J[NumberFormat]
	P-->K[InputMismatch]
	P-->L[Arithmetic]
		D-->F[FileNotFound]
```

## 线程的创建和使用

###  方式一：继承于Thread类

1. 创建一个继承于Thread类的子类

2. 重写Thread类中的run()方法  -->将此线程执行的操作声明在run()中

3. 创建子类对象

4. 通过对象调用start()：①启动当前线程 ②调用当前线程的run()--->调用了Runnable类型的tarket的run()

    问题一：我们不能通过直接调用run()方法启动线程（这时run()的执行仍然在主线程中)

    问题二：再启动一个线程时不能重复通过start()启动线程（start()只能调用一次），只能重新创建一个子类对象

###  方式二：实现Runnable接口

1. 创建一个实现了Runnable接口的类
2. 实现类去实现Runnable中的抽象方法：run()
3. 创建实现类的对象
4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
5. 通过Thread类的对象调用start()

**JDK5.0新增线程创建方式**

### 方式三：实现Callable接口

1. 创建一个实现Callable的实现类
2. 实现call()方法，将此线程需要执行的操作声明在call()中
3. 创建Callable接口实现类的对象
4. 将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象
5. 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()  ==这里是线程启动==
6. 获取Callable中call方法的返回值（使用futureTask.get()）
7. get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。 ==get()并不是启动线程的方法，只是获取call()的返回值==

```mermaid
graph TD
A[CallableImplement]-->|实现|B[Callable]
A[CallableImplement]-->|作为参数|C[FutureTask]
C[FutureTask]-->|作为参数|D[Thread]
C[FutureTask]-->|调用|F[get]
D[Thread]-->|调用|E[start]
E[start]-->|启动|G[线程]
F[get]-->|获取该方法返回值|H[call方法]
H[call方法]-->|属于接口|B[Callable]
```

> 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？
>
> 1. call()可以有返回值的
> 2. call()可以抛出异常，被外面的操作捕获，获取异常的信息
> 3. Callable是支持泛型的

### 方式四：使用线程池

经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大

提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具

**好处**

1. 提高响应速度（减少了创建新线程的时间）

2. 降低资源消耗（重复利用线程池中线程，不需要每次都创建）

3. 便于线程管理：

    corePoolSize：核心池的大小

    maximumPoolSize：最大线程数

    keepAliveTime：线程没有任务时最多保持多长时间后会终止

    .......

### 比较创建线程的两种方式

比较创建线程的两种方式

开发中：优先选择：实现Runnable接口的方式

原因：

1. 实现的方式没有类的单继承性的局限性

2. 实现的方式更适合来处理多个线程有共享数据的情况。

联系：public class Thread implements Runnable //实际上Thread也实现了Runnable接口

相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。



## 线程的同步

当一个线程操作共享数据的时候，其它线程不能参与进来，直到线程操作完成共享数据，其他线程才可以操作共享数据。即使当前线程出现阻塞，也不能被改变。

在Java中，我们通过同步机制，来解决线程的安全问题。

### 方式一：同步代码块

```java
synchronized(同步监视器){
		//需要被同步的代码
}
```

1. 操作共享数据的代码，即为需要被同步的代码。  -->不能包含代码多了，也不能包含代码少了。

2. 共享数据：多个线程共同操作的变量。

3. 同步监视器，俗称：锁。**任何一个类的对象，都可以充当锁**。要求：多个线程必须要共用同一把锁。

    补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器；在继承Thread类创建多线程的方式中，慎用this充当同步监视器

### 方式二：同步方法

如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。

关于同步方法的总结：同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。

-   非静态的同步方法，同步监视器是：this
-   静态的同步方法，同步监视器是：当前类本身

### 方式三：Lock锁

​	从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。

1. 实例化ReentrantLock
2. 调用锁定方法lock()
3. 调用解锁方法：unlock()

> 面试题：synchronized 与 Lock的异同？
>
> 相同：二者都可以解决线程安全问题
>
> 不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器
>
> ​		  Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()）
>
> 优先使用顺序:
>
> Lock->同步代码块（已经进入了方法体，分配了相应资源） ->  同步方法（在方法体之外）

**同步的方式，解决了线程的安全问题。---好处**

**操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 ---局限性**



![三分恶面渣逆袭：线程常用调度方法](%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.assets/javathread-6.png)





## 线程的几种状态

|     状态     | 说明                                                         |
| :----------: | :----------------------------------------------------------- |
|     NEW      | 当线程被创建后，如通过`new Thread()`，它处于新建状态。此时，线程已经被分配了必要的资源，但还没有开始执行。 |
|   RUNNABLE   | 当调用线程的`start()`方法后，线程进入可运行状态。在这个状态下，线程可能正在运行也可能正在等待获取 CPU 时间片，具体取决于线程调度器的调度策略。 |
|   BLOCKED    | 线程在试图获取一个锁以进入同步块/方法时，如果锁被其他线程持有，线程将进入阻塞状态，直到它获取到锁。 |
|   WAITING    | 线程进入等待状态是因为调用了如下方法之一：`Object.wait()`或`LockSupport.park()`。在等待状态下，线程需要其他线程显式地唤醒，否则不会自动执行。 |
| TIME_WAITING | 当线程调用带有超时参数的方法时，如`Thread.sleep(long millis)`、`Object.wait(long timeout)` 或`LockSupport.parkNanos()`，它将进入超时等待状态。线程在指定的等待时间过后会自动返回可运行状态。 |
|  TERMINATED  | 当线程的`run()`方法执行完毕后，或者因为一个未捕获的异常终止了执行，线程进入终止状态。一旦线程终止，它的生命周期结束，不能再被重新启动。 |

## String不同拼接操作的对比

1. 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量

2. 只要其中有一个是变量，结果就在堆中
3. 如果拼接的结果调用intern()方法，返回值就在常量池中



## Java 集合框架

![img](%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.images/gailan-01.png)



在 Java 中，常用的集合类有 ArrayList、LinkedList、HashMap、LinkedHashMap 等。

1.  ArrayList：ArrayList 可以看作是一个动态数组，它可以在运行时动态扩容。**优点是访问速度快，可以通过索引直接查到元素。缺点是插入和删除元素可能需要移动元素，效率就会降低。**
2.  LinkedList：LinkedList 是一个双向链表，它**适合频繁的插入和删除操作。** **优点是插入和删除元素的时候只需要改变节点的前后指针，缺点是访问元素时需要遍历链表。**
3.  HashMap：HashMap 是一个基于哈希表的键值对集合。优点是插入、删除和查找元素的速度都很快。缺点是它**不保留键值对的插入顺序。**
4.  LinkedHashMap：LinkedHashMap 在 HashMap 的基础上增加了一个双向链表来保持键值对的插入顺序。





-   线程安全：Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、ArrayBlockingQueue、LinkedBlockingQueue 这些都是线程安全的

-   LinkedList 更利于增删不是体现在时间复杂度上，因为二者增删的时间复杂度都是 O(n)，都需要遍历列表（LinkedList 需要找到增删的位置）；而是体现在增删的效率上，因为 LinkedList 的增删只需要改变引用，而 ArrayList 的增删可能需要移动元素。
-   ArrayList 是基于数组的，是一块连续的内存空间。

### ArrayList 和 Vector 的区别

Vector 是 JDK 1.0 的产物，已经不推荐使用，仍然保留是因为 Java 希望向后兼容

ArrayList 是 JDK 1.2 时引入的，用于替代 Vector 作为主要的**非同步动态数组实现**。因为 Vector 所有的方法都使用 synchronized 关键字进行了同步，单线程环境下效率较低。



## 红黑树

### 红黑树插入（构建）

![image-20240802162219639](%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.images/image-20240802162219639.png)

### 红黑树的删除

![image-20240802162023729](%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.images/image-20240802162023729.png)



## Java 并发

### 原子性、可见性、有序性的理解

原子性、有序性、可见性是并发编程中非常重要的基础概念，JMM 的很多技术都是围绕着这三大特性展开。

- **原子性**：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。
- **可见性**：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。
- **有序性**：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。

> 分析下面几行代码的原子性？

```java
int i = 2;
int j = i;
i++;
i = i + 1;
```

- 第 1 句是基本类型赋值，是原子性操作。
- 第 2 句先读 i 的值，再赋值到 j，两步操作，不能保证原子性。
- 第 3 和第 4 句其实是等效的，先读取 i 的值，再+1，最后赋值到 i，三步操作了，不能保证原子性。

> 原子性、可见性、有序性都应该怎么保证呢？

- 原子性：JMM 只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用`synchronized `。
- 可见性：Java 是利用`volatile`关键字来保证可见性的，除此之外，`final`和`synchronized`也能保证可见性。
- 有序性：`synchronized`或者`volatile`都可以保证多线程之间操作的有序性。



### synchronized 怎么使用

synchronized 可以用在方法和代码块中。

①、修饰方法

synchronized 修饰方法时，JVM 会通过 `ACC_SYNCHRONIZED` **标记符**来实现同步

```java
public synchronized void increment() {
    this.count++;
}
```

当在方法声明中使用了 synchronized 关键字，就表示该方法是同步的，也就是说，线程在执行这个方法的时候，其他线程不能同时执行，需要等待锁释放。

如果是**静态方法**的话，**锁的是这个类的 Class 对象**，因为静态方法是属于类级别的。

```java
public static synchronized void increment() {
    count++;
}
```

②、修饰代码块

synchronized 修饰代码块时，JVM 会通过 `monitorenter`、`monitorexit` 两个指令来实现同步：

- `monitorenter` 指向同步代码块的开始位置
- `monitorexit` 指向同步代码块的结束位置。

```java
public void increment() {
    synchronized (this) {
        this.count++;
    }
}
```

同步代码块可以减少需要同步的代码量，颗粒度更低，更灵活。synchronized 后面的括号中指定了要锁定的对象，可以是 this，也可以是其他对象。

### synchronized 锁住的是？

monitorenter、monitorexit 或者 ACC_SYNCHRONIZED 都是**基于 Monitor 实现**的。

实例对象结构里有对象头，对象头里面有一块结构叫 Mark Word，Mark Word 指针指向了 **monitor**

所谓的 Monitor 其实是一种**同步工具**，也可以说是一种**同步机制**。在 Java 虚拟机（HotSpot）中，Monitor 是由**ObjectMonitor** 实现的，可以叫做内部锁，或者 Monitor 锁。

ObjectMonitor 的工作原理：

- ObjectMonitor 有两个队列：\_WaitSet、_EntryList，用来保存 ObjectWaiter 对象列表。
- _owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒。

处于等待状态的线程会被加入到 \_WairSet

处于等待锁 block 状态的线程，会被加入到 \_EntryList

所以我们就知道了，**同步是锁住的什么东西**：

- monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1。
- monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。

#### 会不会牵扯到 os 层面呢？

会，synchronized 升级为重量级锁时，依赖于操作系统的互斥量（mutex）来实现，mutex 用于保证任何给定时间内，只有一个线程可以执行某一段特定的代码段。

#### synchronized 怎么保证可见性？

- 线程加锁前，将**清空工作内存中共享变量的值**，从而使用共享变量时需要从主内存中重新读取最新的值。
- 线程加锁后，其它线程无法获取主内存中的共享变量。
- 线程解锁前，必须把共享变量的最新值刷新到主内存中

#### synchronized 怎么保证有序性？

synchronized 同步的代码块，具有排他性，一次只能被一个线程拥有，所以 synchronized 保证同一时刻，代码是单线程执行的。

因为 as-if-serial 语义的存在，**单线程的程序能保证最终结果是有序的**，但是**不保证不会指令重排**。

所以 synchronized 保证的有序是**执行结果的有序性**，而不是防止指令重排的有序性。

#### synchronized 怎么实现可重入的呢？

可重入意味着同一个线程可以多次获得同一个锁，而不会被阻塞。具体来说，如果一个线程已经持有某个锁，那么它可以再次进入该锁保护的代码块或方法，而不会被阻塞。

synchronized 之所以支持可重入，是因为 Java 的对象头包含了一个 Mark Word，用于存储对象的状态，包括锁信息。

当一个线程获取对象锁时，JVM 会将该线程的 ID 写入 Mark Word，并将锁计数器设为 1。

如果一个线程尝试再次获取已经持有的锁，JVM 会检查 Mark Word 中的线程 ID。如果 ID 匹配，表示的是同一个线程，锁计数器递增。

当线程退出同步块时，锁计数器递减。如果计数器值为零，JVM 将锁标记为未持有状态，并清除线程 ID 信息。

### 锁升级，synchronized 优化

Java 对象头里的 `Mark Word` 会记录锁的状态，一共有四种状态：

①、无锁状态，在这个状态下，没有线程试图获取锁。

②、偏向锁，当第一个线程访问同步块时，锁会进入偏向模式。Mark Word 会被设置为偏向模式，并且存储了获取它的线程 ID。

偏向锁的目的是消除同一线程的后续锁获取和释放的开销。如果同一线程再次请求锁，就无需再次同步。

③、当有多个线程竞争锁，但没有锁竞争的强烈迹象（即线程交替执行同步块）时（多个线程在不同时段获取同一把锁），偏向锁会升级为轻量级锁。

线程尝试通过[CAS 操作](https://javabetter.cn/thread/cas.html)（Compare-And-Swap）将对象头的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获取轻量级锁；如果失败，说明有竞争。

当一个线程尝试获取轻量级锁时，它会在自己的栈帧中创建一个锁记录（Lock Record），然后尝试使用 CAS 操作将对象头的 Mark Word 替换为指向锁记录的指针。

如果成功，该线程持有锁；如果失败，表示有其他线程竞争，锁会升级为重量级锁。

当线程尝试获取轻量级锁失败时，它会进行自旋，即循环检查锁是否可用，以避免立即进入阻塞状态。

自旋的次数不是固定的，而是根据之前在同一个锁上的自旋时间和锁的状态动态调整的。

④、重量级锁，当锁竞争激烈时，轻量级锁会膨胀为重量级锁。

重量级锁通过将对象头的 Mark Word 指向监视器（Monitor）对象来实现，该对象包含了锁的持有者、锁的等待队列等信息。

![三分恶面渣逆袭：Mark Word变化](%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.assets/javathread-34.png)

![三分恶面渣逆袭：synchronized 锁升级过程](%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.assets/javathread-37.png)

[图像链接](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-37.png)





## 其他

-   一个Java应用程序java.exe，其实至少有三个线程：**main()主线程，gc()垃圾回收线程，异常处理线程**。当然如果发生异常，会影响主线程



# 数据库

## SQL 语言分类

**DDL（Data Definition Languages、数据定义语言）**，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构

**DML（Data Manipulation Language、数据操作语言）**，用于添加、删除、更新和查询数据库记录，并检查数据完整性。

**DCL（Data Control Language、数据控制语言）**，用于定义数据库、表、字段、用户的访问权限和安全级别。

## ORM 思想

- 一个数据表对应一个 java 类
- 表中的一条记录对应 java 类的一个对象
- 表中的一个字段对应 java 类的一个属性

## 事务的 ACID 属性

1. **原子性（Atomicity）**
    原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 

2. **一致性（Consistency）**
    事务必须使数据库从一个一致性状态变换到另外一个一致性状态。

3. **隔离性（Isolation）**
    事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

4. **持久性（Durability）**
    持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。

## 数据库的并发问题

- 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:
    - **脏读**: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还**没有被提交**的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。
    - **不可重复读**: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 **更新**了该字段。之后, T1再次读取同一个字段, 值就不同了。
    - **幻读**: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中**插入**了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。

- **数据库事务的隔离性**: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。

- 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, **隔离级别越高, 数据一致性就越好, 但并发性越弱。**

## 数据库中的四种隔离级别

1.   **未提交读（Read uncommitted）**

     这种事务隔离级别下，select 语句不加锁，事务中修改的数据，即使没有提交，对其他事务也都是可见的。此时，可能读取到不一致的数据，即“脏读 ”。这是**并发最高，一致性最差**的隔离级别。

2.   **不可重复读/提交读/读已提交（Read committed）**

     一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。

     大多数数据库系统的默认隔离级别都是提交读（但Mysql不是）。提交读满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。**可避免脏读，无法避免不可重复读发生**。

     因为两次执行同样的查询，可能会得到不一样的结果，这个级别有时候也叫做不可重复读（nonrepeatable read）

3.   **可重复读（Repeatable read）**

     该级别保证了在同一个事务中多次读取同样记录的结果是一致的，事务中未提交的数据对其他事务是不可见的，**解决 脏读 、不可重复读 的问题**，是**MySql默认隔离级别**。

4.   **串行化（Serializable）**

     可串行化是最高的隔离级别。它通过强制事务串行执行，避免了**脏读、不可重复读、幻读**的问题。

     简单来说，**可串行化会在读取的每一行数据上都加上锁**，所以可能导致大量的超时和锁争用问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑用该级别。

     以 **锁表** 的方式，使得其他的线程只能在锁外等待。

以上四种隔离级别最高的是 Serializable 级别，最低的是 Read uncommitted 级别，当然级别越高，执行效率就越低。像 Serializable 这样的级别，就是以 锁表 的方式，使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。SQL Server默认的隔离级别为rcommitted，MySQL默认的隔离级别为 Repeatable read, Oracle默认隔离级别为 Read committed。

SQL Server和MySQL数据库支持上面四种隔离级别，而 Oracle数据库只支持 Serializable (串行化) 级别和 Read committed (读已提交) 这两种级别。 



# OS

## 进程和线程

进程是**操作系统资源分配**的最小单位，它包括了程序、数据和进程控制块等

线程是 **CPU 分配资源**的基本单位

一个进程可以有多个线程

![三分恶面渣逆袭：进程与线程关系](%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.assets/javathread-3.png)

一个进程中可以有多个线程，多个线程共用进程的堆和方法区（Java 虚拟机规范中的一个定义，JDK 8 以后的实现为元空间）资源，但是每个线程都会有自己的程序计数器和栈

## 线程创建方式

![二哥的 Java 进阶之路](%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.assets/javathread-20240407172652.png)

- 继承 Thread 类，重写 `run()`方法，调用 `start()`方法启动线程\

	```java
	class ThreadTask extends Thread {
	    public void run() {
	        System.out.println("看完二哥的 Java 进阶之路，上岸了!");
	    }
	
	    public static void main(String[] args) {
	        ThreadTask task = new ThreadTask();
	        task.start();
	    }
	}
	```
	
	由于 Java 不支持多重继承，所以如果类已经继承了另一个类，就不能使用这种方法了

- 实现 Runnable 接口，重写 `run()` 方法，然后创建 Thread 对象，将 Runnable 对象作为参数传递给 Thread 对象，调用 `start()` 方法启动线程

	```java
	class RunnableTask implements Runnable {
	    public void run() {
	        System.out.println("看完二哥的 Java 进阶之路，上岸了!");
	    }
	
	    public static void main(String[] args) {
	        RunnableTask task = new RunnableTask();
	        Thread thread = new Thread(task);
	        thread.start();
	    }
	}
	```

- 实现 Callable 接口，重写 `call()` 方法，然后创建 FutureTask 对象，参数为 Callable 对象；紧接着创建 Thread 对象，参数为 FutureTask 对象，调用 `start()` 方法启动线程

	```java
	class CallableTask implements Callable<String> {
	    public String call() {
	        return "看完二哥的 Java 进阶之路，上岸了!";
	    }
	
	    public static void main(String[] args) throws ExecutionException, InterruptedException {
	        CallableTask task = new CallableTask();
	        FutureTask<String> futureTask = new FutureTask<>(task);
	        Thread thread = new Thread(futureTask);
	        thread.start();
	        System.out.println(futureTask.get());
	    }
	}
	```
	
	这种方法的优点是可以获取线程的执行结果

