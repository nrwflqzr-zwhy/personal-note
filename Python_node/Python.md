# 程序基本格式

**1. 恰当的空格**

​		逻辑行首的空白（空格和制表符）用来决定逻辑行的缩进层次

​		语句从新行的第一列开始

​		缩进风格统一：

​				每个缩进层次使用 单个制表符或四个空格

​				python使用缩进表示程序块

**2. Python区分大小写**

**3. 注释**

​		行注释  

```python
#行注释
```

​		段注释 

````python
```
段注释
```
````

# Python程序的构成

1. Python程序由模块组成。一个模块对应Python源文件，一般后缀是.py

2. 模块由语句组成。顺次执行

   <img src="E:\Typora_files\Python_node\Python.images\image-20220602213231898.png" alt="image-20220602213231898" style="zoom:50%;" />

# 一、编程基本概念

## 1.1 对象

**Python中，一切皆对象。**对象由标识、类型、值组成

1. 标识用于唯一标识对象，通常对应对象在内存中的地址。使用内置函数id(obj)能够返回对象obj的标识
2. 类型用于表示对象存储的类型。限制对象的取值范围和可执行的操作。type(obj)能够返回obj的类型
3. 值表示对象所存储的数据的信息。

**对象的本质是：一个内存块，拥有特定的值，支持特定类型相关操作。**



## 1.2 引用

​	在Python中，变量也称为：对象的引用。因为，变量存储的就是对象的地址。

​		变量通过地址引用了“对象”。

​	变量位于：栈内存（压栈出栈等细节，后续再介绍）。

​	对象位于：堆内存。

**Python是动态类型语言**

​	变量**不需要显式声明**类型。根据变量引用的对象，Python解释器自动确定数据类型。

**Python是强类型语言**

​	每个对象都有数据类型，只支持该类型支持的操作。

<img src="E:\Typora_files\Python_node\Python.images\image-20220603145352329.png" alt="image-20220603145352329" style="zoom: 50%;" />



##  1.3 标识符

### 1.3.1 基本用法

***\*标识符：用于变量、函数、类、模块等的名称。\****标识符有如下特定的规则：

1.   区分大小写。如：sxt 和 SXT是不同的

2.   第一个字符必须是**字母、下划线**。其后的字符是：字母、数字、下划线

3.   不能使用关键字。比如：if、or、while等。

4.   以**双下划线开头和结尾**的名称通常有特殊含义，尽量避免这种写法。比如：__ init __是类的构造函数。

###  1.3.2 Python标识符命名规则

开发中，我们通常约定俗成遵守如下规则：

|    类型    |                             规则                             |          例子           |
| :--------: | :----------------------------------------------------------: | :---------------------: |
| 模块和包名 |         全小写字母，尽量简单。若多个单词之间用下划线         |      math, os, sys      |
|   函数名   |             全小写字母，多个单词之间用下划线隔开             |     phone, my_name      |
|    类名    | 首字母大写，采用驼峰原则。多个单词时，每个单词第一个字母大写，其余部分小写 | MyPhone、MyClass、Phone |
|   常量名   |              全大写字母，多个单词使用下划线隔开              |    SPEED、MAX_SPEED     |

## 1.4 变量和简单赋值语句

### 1.4.1 变量的声明和赋值

变量的声明和赋值用于将一个变量绑定到一个对象上，格式如下：

变量名 = 表达式

最简单的表达式就是字面量。比如：a = 123 。 运行过程中，解释器先运行右边的表达式，生成一个代表表达式运算结果的对象；然后，将这个对象地址赋值给左边的变量。

### 1.4.2 删除变量和垃圾回收机制

可以通过del语句删除不在使用的变量。

如果对象没有变量引用，就会被垃圾回收器回收，清空内存空间。

### 1.4.3 链式赋值

链式赋值用于同一个对象赋值给多个变量。

x=y=123  相当于：x=123; y=123 

### 1.4.4 系列解包赋值

系列数据赋值给对应相同个数的变量（个数必须保持一致）

\>>> a,b,c=4,5,6  相当于：a=4;b=5;c=6

### 1.4.5 常量

Python不支持常量，即没有语法规则限制改变一个常量的值。我们只能约定常量的命名规则，以及在程序的逻辑上不对常量的值作出修改。



## 1.5 最基本内置数据类型和运算符

每个对象都有类型，python中最基本的内置数据类型：

1.   整型			整数，2345,10,50

2.   浮点型	    小数，3.14或者科学计数法314e-2

3.   布尔型        表示真假，仅包含：True、False

4.   字符串型      由字符组成的序列。 “abc”,”sxt”,“尚学堂”,”百战程序员”

### 1.5.1 数字和基本运算符

Python支持整数(如：50,520)和浮点数(如：3.14,10.0, 1.23e2)，我们可以对数字做如下运算。

| 运算符 | 说明           | 示例 | 结果 |
| :----- | -------------- | ---- | ---- |
| +      | 加法           | 3+2  | 5    |
| -      | 减法           | 30-5 | 25   |
| *      | 乘法           | 3*6  | 18   |
| /      | **浮点数除法** | 8/2  | 4.0  |
| //     | **整数除法**   | 7//2 | 3    |
| %      | 模（取余）     | 7%4  | 3    |
| **     | **幂**         | 2**3 | 8    |

### 1.5.2 整数

Python中，除10进制，还有其他三种进制：

-   0b或0B，二进制  0  1
-   0o或0O，八进制  0  1  2  3  4  5  6  7
-   0x或0X，十六进制0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f

**使用int()实现类型转换**

1.   浮点数直接舍去小数部分。如：int(9.9)结果是：9
2.   布尔值True转为1，False转为0。  如：int(True)结果是1
3.   字符串符合整数格式（浮点数格式不行）则直接转成对应整数，否则报错

**自动转型：**

整数和浮点数混合运算时，表达式结果自动转型成浮点数。比如：2+8.0的结果是10.0

**整数可以有多大？**

Python2中，int是32位，可以存储从-2147483648到2147483647的整数（约±21亿）。Long类型是64位，可以存储：

-2^63^-2^63^-1之间的数值。

Python3中，int可以存储任意大小的整数，long被取消。

Python3中可以做超大数的计算，而不会造成“整数溢出”，这也是Python特别适合科学运算的特点。

### 1.5.3 浮点数

浮点数，称为float。

浮点数用 a x b^10^ 形式的科学计数法表示。比如：3.14，表示成：314E-2或者314e-2。

这些数字在内存中也是按照科学计数法存储。

### 1.5.4 类型转换和四舍五入

1.   类似于int()，我们也可以使用float()将其他类型转化成浮点数。
2.   整数和浮点数混合运算时，表达式结果自动转型成浮点数。比如：2+8.0的结果是10.0
3.   round(value)可以返回四舍五入的值

注：但不会改变原有值，而是产生新的值

### 1.5.5 增强型赋值运算符

运算符+、-、*，/、//、**和%和赋值符=结合可以构成“增强型赋值运算符”。

a = a + 1   等价于：  a +=1 

**增强型赋值运算符**

| 运算符 | 例子    | 等价      |
| ------ | ------- | --------- |
| +=     | a += 2  | a = a + 2 |
| -=     | a -= 2  | a = a-2   |
| *=     | a *= 2  | a = a * 2 |
| /=     | a /= 2  | a = a / 2 |
| //=    | a //= 2 | a = a//2  |
| **=    | a **= 2 | a = a**2  |
| %=     | a %= 2  | a = a % 2 |

注意：“+=”中间不能加空格！

### 1.5.6 时间的表示

计算机中时间的表示是从“1970年1月1日 00:00:00”开始，以毫秒（1/1000秒）进行计算。我们也把1970年这个时刻成为“unix时间点”。

这样，我们就把时间全部用数字来表示了。

<img src="E:\Typora_files\Python_node\Python.images\wps2.jpg" alt="img" style="zoom:67%;" /> 

python中可以通过time.time() 获得当前时刻，返回的值是以秒为单位，带微秒（1/1000毫秒）精度的浮点值。例如：1530167364.8566。

```python
import turtle
import math
#设定四个点坐标
x1,y1 = 100,100
x2,y2 = 100,-100
x3,y3 = -100,-100
x4,y4 = -100,100
turtle.penup()
turtle.goto(x1,y1)
turtle.pendown()
turtle.goto(x2,y2)
turtle.goto(x3,y3)
turtle.goto(x4,y4)
#计算终点起点距离
distance = math.sqrt((x1-x4)**2 + (y1-y4)**2)
turtle.write(distance)
```

### 1.5.7 布尔值

Python2中没有布尔值，直接用数字0表示False,用数字1表示True。

Python3中，把True和False定义成了关键字，但他们的本质还是1和0，甚至可以和数字相加。

### 1.5.8 比较运算符****

所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。

以下假设变量a为15，变量b为30：

| **运算符** | **描述**                            | **实例**              |
| ---------- | ----------------------------------- | --------------------- |
| ==         | 等于 - 比较对象的值是否相等         | (a == b) 返回 False。 |
| !=         | 不等于 - 比较两个对象的值是否不相等 | (a != b) 返回 true.   |
| >          | 大于 - 返回x是否大于y               | (a > b) 返回 False。  |
| <          | 小于 - 返回x是否小于y。             | (a < b) 返回 true。   |
| >=         | 大于等于 - 返回x是否大于等于y。     | (a >= b) 返回 False。 |
| <=         | 小于等于 - 返回x是否小于等于y。     | (a <= b) 返回 true。  |

### 1.5.9 逻辑运算符

| 运算符    | 格式    | 说明                                                     |
| --------- | ------- | -------------------------------------------------------- |
| or逻辑或  | x or y  | x为true，则不计算y，直接返回true  x为false，则返回y      |
| and逻辑与 | x and y | x为true，则返回y的值  x为false，则不计算y，直接返回false |
| not逻辑非 | not  x  | x为true，返回false  x为false，返回true                   |

### 1.5.10 同一运算符

同一运算符用于比较两个对象的存储单元，实际比较的是对象的地址。

| 运算符 | 描述                                      |
| ------ | ----------------------------------------- |
| is     | is是判断两个标识符是不是引用同一个对象    |
| is not | is not 是判断两个标识符是不是引用不同对象 |

==**is 与 == 区别：**==

is 用于判断两个变量引用对象是否为同一个，既比较对象的地址。

== 用于判断引用变量引用对象的值是否相等，默认调用对象的 __ eq__()方法。

####  1.5.10.1 整数缓存问题

Python仅仅对比较小的整数对象进行缓存（范围为[-5, 256]）缓存起来，而并非是所有整数对象。需要注意的是，这仅仅是在命令行中执行，而在Pycharm或者保存为文件执行，结果是不一样的，这是因为解释器做了一部分优化(范围是[-5,任意正整数])。

**总结**

1.   is 比较两个对象的 id 值是否相等，是否指向同一个内存地址；
2.   == 比较的是两个对象的内容是否相等，值是否相等；
3.   小整数对象[-5,256]在全局解释器范围内被放入缓存供重复使用；
4.   is 运算符比 == 效率高，在变量和None进行比较时，应该使用 is。

### 1.5.11 基本运算符**

我们在前面讲解了“+”、“-”、“*”、“/”、“//”、“%”等运算符，这里我们继续讲解一些其他运算符

| 运算符            | 说明                             |
| ----------------- | -------------------------------- |
| and ,  or  ,  not | 布尔与、布尔或、布尔非           |
| is  ,  is  not    | 同一性判断，判断是否为同一个对象 |
| <,<=,>,>=,!=,==   | 比较值是否相当，可以连用         |
| \|   ^    &       | 按位或，按位异或、按位与         |
| <<, >>            | 移位                             |
| ~                 | 按位翻转                         |
| +,-,*,/,//,%      | 加，减，乘，浮点除、整数除、取余 |
| **                | 幂运算                           |

### 1.5.12 运算符优先级问题

如下优先级，从高到低。

| 运算符                   | 描述                 |
| ------------------------ | -------------------- |
| **                       | 指数 (最高优先级)    |
| ~                        | 按位翻转             |
| * / % //                 | 乘，除，取模和取整除 |
| + -                      | 加法减法             |
| >> <<                    | 右移，左移运算符     |
| &                        | 位 'AND'             |
| ^ \|                     | 位运算符             |
| <= < > >=                | 比较运算符           |
| <> == !=                 | 等于运算符           |
| = %= /= //= -= += *= **= | 赋值运算符           |
| is,is not                | 身份运算符           |
| in,not in                | 成员运算符           |
| not,or,and               | 逻辑运算符           |

实际使用中，记住如下简单的规则即可，复杂的表达式一定要使用小括号组织。

1.   乘除优先加减
2.   位运算和算术运算>比较运算符>赋值运算符>逻辑运算符

# 二、字符串

## 2.1 字符串基本特点

​	字符串的本质是：字符序列。Python的字符串是不可变的，我们无法对原字符串做任何修改。但，可以将字符串的一部分复制到新创建的字符串，达到“看起来修改”的效果。

​	Python不支持单字符类型，单字符也是作为一个字符串使用的。

## 2.2 字符串的编码

​	Python3直接支持Unicode，可以表示世界上任何书面语言的字符。Python3的字符默认就是16位Unicode编码，ASCII码是Unicode编码的子集。

​	使用内置函数ord()可以把字符转换成对应的Unicode码；

​	使用内置函数chr()可以把十进制数字转换成对应的字符。

## 2.3 引号创建字符串

我们可以通过单引号或双引号创建字符串。例如：a=’abc’;  b=”sxt”

使用两种引号的好处是可以创建本身就包含引号的字符串，而不用使用转义字符。

连续三个单引号或三个双引号，可以帮助我们创建多行字符串。

```python
resume = ''' name="gaoqi"
company="sxt"   age=18
lover="Tom"'''
print(resume)
name="gaoqi"
company="sxt"   
age=18
lover="Tom"
```

## 2.4 空字符串和len()函数

Python允许空字符串的存在，不包含任何字符且长度为0。

len()用于计算字符串含有多少字符。

## 2.5 转义字符

我们可以使用“ \ +特殊字符”，实现某些难以用字符表示的效果。比如：换行等。常见的转义字符有这些：

| **转义字符** | **描述**        |
| ------------ | --------------- |
| \(在行尾时)  | 续行符          |
| \ \          | 反斜杠符号      |
| \ '          | 单引号          |
| \ "          | 双引号          |
| \b           | 退格(Backspace) |
| \n           | 换行            |
| \t           | 横向制表符      |
| \r           | 回车            |

## 2.6 字符串操作

### 2.6.1 字符串拼接

1. 可以使用+将多个字符串拼接起来。例如：’aa’+ ’bb’ ==>’aabb’。

   (1) 如果+两边都是字符串，则拼接。

   (2) 如果+两边都是数字，则加法运算。

   (3) 如果+两边类型不同，则抛出异常。

2. 可以将多个字面字符串直接放到一起实现拼接。例如：’aa’’bb’==>’aabb’

### 2.6.2 字符串复制

使用*可以实现字符串复制

```python
a = 'Sxt'*3
print(a)
//'SxtSxtSxt'
```

### 2.6.3 不换行打印

我们前面调用print时，会自动打印一个换行符。有时，我们不想换行，不想自动添加换行符。我们可以自己通过参数end = “任意字符串”。

```python
print("sxt",end=' ')
print("sxt",end='##')
print("sxt")
```

### 2.6.4 从控制台读取字符串

我们可以使用input()从控制台读取键盘输入的内容。

```python
>>>myname = input("请输入名字:")
请输入名字:高淇
>>> myname
'高淇'
```

### 2.6.5 str()实现数字转型字符串

str()可以帮助我们将其他数据类型转换为字符串。

```python
str(5.20) => ‘5.20’		
str(3.14e2)=>’314.0’		
str(True) ==> ‘True’
```

当我们调用print()函数时，解释器自动调用了str()将非字符串的对象转成了字符串。我们在面向对象章节中详细讲解这部分内容。

### 2.6.6 使用[ ]提取字符

字符串的本质就是字符序列，我们可以通过在字符串后面添加[]，在[]里面指定偏移量，可以提取该位置的单个字符。

正向搜索：最左侧第一个字符，偏移量是0，第二个偏移量是1，以此类推。直到len(str)-1为止。

反向搜索：最右侧第一个字符，偏移量是-1，倒数第二个偏移量是-2，以此类推，直到-len(str)为止。

### 2.6.7 replace()实现字符串替换

```python
>>>a = 'abcdefghijklmnopqrstuvwxyz'
>>> a
'abcdefghijklmnopqrstuvwxyz'
>>> a = a.replace('c','高')
'ab高defghijklmnopqrstuvwxyz'
```

<img src="E:\Typora_files\Python_node\Python.images\image-20220606172046276.png" alt="image-20220606172046276" style="zoom:67%;" />

### 2.6.8 字符串切片slice操作

切片slice操作可以让我们快速的提取子字符串。标准格式为：[起始偏移量start：终止偏移量end：步长step]

 典型操作(三个量为正数的情况)如下：

| 操作和说明                                     | 示例            | 结果     |
| ---------------------------------------------- | --------------- | -------- |
| [:]  提取整个字符串                            | “abcdef”[:]     | “abcdef” |
| [start:]从start索引开始到结尾                  | “abcdef”[2:]    | “cdef”   |
| [:end]从头开始知道end-1                        | “abcdef”[:2]    | “ab”     |
| [start:end]从start到end-1                      | “abcdef”[2:4]   | “cd”     |
| [start:end:step]从start提取到end-1，步长是step | “abcdef”[1:5:2] | “bd”     |

其他操作（三个量为负数）的情况：

| 示例                                | 说明                               | 结果                         |
| ----------------------------------- | ---------------------------------- | ---------------------------- |
| "abcdefghijklmnopqrstuvwxyz"[-3:]   | 倒数三个                           | “xyz”                        |
| "abcdefghijklmnopqrstuvwxyz"[-8:-3] | 倒数第八个到倒数第三个(包头不包尾) | 'stuvw'                      |
| "abcdefghijklmnopqrstuvwxyz"[::-1]  | 步长为负，从右到左反向提取         | 'zyxwvutsrqponmlkjihgfedcba' |

切片操作时，起始偏移量和终止偏移量不在[0,字符串长度-1]这个范围，也不会报错。起始偏移量小于0则会当做0，终止偏移量大于“长度-1”会被当成最大长度。

### 2.6.9 split()分割和join()合并

split()可以基于指定分隔符将字符串分隔成多个子字符串(存储到列表中)。如果不指定分隔符，则默认使用空白字符(换行符/空格/制表符)

```python
>>> a = "to be or not to be"
>>> a.split()
['to', 'be', 'or', 'not', 'to', 'be']
>>> a.split('be')
['to ', ' or not to ', '']
```

join()的作用和split()作用刚好相反，用于将一系列子字符串连接起来。

```python
>>> a = ['sxt','sxt100','sxt200']
>>> '*'.join(a)
'sxt*sxt100*sxt200'
```

**拼接字符串要点：**
	使用字符串拼接符+，会生成新的字符串对象，因此不推荐使用+来拼接字符串。推荐使用join函数，因为join函数在拼接字符串之前会计算所有字符串的长度，然后逐一拷贝，仅新建一次对象。

### 2.6.10 字符串驻留机制和字符串比较

**字符串驻留：**仅保存一份相同且不可变字符串的方法，不同的值被存放在字符串驻留池中。

Python支持字符串驻留机制，对于符合标识符规则的字符串（仅包含下划线（_）、字母和数字）会启用字符串驻留机制驻留机制。（不同的python版本和不同的解释器规则有差异）

```python
>>> a = "abd_33"
>>> b = "abd_33"
>>> a is b
True
>>> c = "dd#"
>>> d = "dd#"
>>> c is d
False
>>> str1 = "aa"
>>> str2 = "bb"
>>> str1+str2  is "aabb"
False
>>> str1+str2 == "aabb"
True
```

### 2.6.11 成员操作符

in /not in 关键字，判断某个字符(子字符串)是否存在于字符串中。

### 2.6.12 字符串常用方法汇总

#### 2.6.12.1 常用查找方法

我们以一段文本作为测试：

a='''我是高淇,今年18岁了,我在北京尚学堂科技上班。我的儿子叫高洛希，他6岁了。我是一个编程教育的普及者，希望影响6000万学习编程的中国人。我儿子现在也开始学习编程，希望他18岁的时候可以超过我'''

| 方法和使用示例           | 说明                         | 结果  |
| ------------------------ | ---------------------------- | ----- |
| len(a)                   | 字符串长度                   | 96    |
| a.startswith('我是高淇') | 以指定字符串开头             | True  |
| a.endswith('过我')       | 以指定字符串结尾             | True  |
| a.find('高')             | 第一次出现指定字符串的位置   | 2     |
| a.rfind('高')            | 最后一次出现指定字符串的位置 | 29    |
| a.count("编程")          | 指定字符串出现了几次         | 3     |
| a.isalnum()              | 所有字符全是字母或数字       | False |

#### 2.6.12.2 去除首尾信息

我们可以通过strip()去除字符串首尾指定信息。通过lstrip()去除字符串左边指定信息，rstrip()去除字符串右边指定信息。

```python
>>> "*s*x*t*".strip("*")
's*x*t'
>>> "*s*x*t*".lstrip("*")
's*x*t*'
>>> "*s*x*t*".rstrip("*")
'*s*x*t'
>>> "  sxt  ".strip()
'sxt'
```

#### 2.6.12.3 大小写转换

编程中关于字符串大小写转换的情况，经常遇到。我们将相关方法汇总到这里。为了方便学习，先设定一个测试变量：  a = "gaoqi  love  programming, love  SXT"

| 示例           | 说明                                | 结果                                  |
| -------------- | ----------------------------------- | ------------------------------------- |
| a.capitalize() | 产生新的字符串,首字母大写           | 'Gaoqi  love  programming, love  sxt' |
| a.title()      | 产生新的字符串,每个单词都首字母大写 | 'Gaoqi  Love  Programming, Love  Sxt' |
| a.upper()      | 产生新的字符串,所有字符全转成大写   | 'GAOQI  LOVE  PROGRAMMING, LOVE  SXT' |
| a.lower()      | 产生新的字符串,所有字符全转成小写   | 'gaoqi  love  programming, love  sxt' |
| a.swapcase()   | 产生新的,所有字母大小写转换         | 'GAOQI  LOVE  PROGRAMMING, LOVE  sxt' |

#### 2.6.12.4 格式排版

center()、ljust()、rjust()这三个函数用于对字符串实现排版。

```python
>>> a="SXT"
>>> a.center(10,"*")
'***SXT****'
>>> a.center(10)
'   SXT    '
>>> a.ljust(10,"*")
'SXT*******'
```

#### 2.6.12.5 其他方法

1.   isalnum()	是否为字母或数字
2.   isalpha()	检测字符串是否只由字母组成(含汉字)。
3.   isdigit()	检测字符串是否只由数字组成。
4.   isspace()	检测是否为空白符
5.   isupper()	是否为大写字母
6.   islower()	是否为小写字母

```python
>>> "sxt100".isalnum()
True
>>> "sxt尚学堂".isalpha()
True
>>> "234.3".isdigit()
False
>>> "23423".isdigit()
True
>>> "aB".isupper()
False
>>> "A".isupper()
True
>>> "\t\n".isspace()
True
```

### 2.6.13 字符串的格式化

#### 2.6.13.1 format()基本用法

Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。

基本语法是通过 {} 和 : 来代替以前的 % 。

format 函数可以接受不限个参数，位置可以不按顺序。

我们通过示例进行格式化的学习。

```python
>>> a = "名字是:{0},年龄是：{1}"
>>> a.format("高淇",18)
'名字是:高淇,年龄是：18'
>>> a.format("高希希",6)
'名字是:高希希,年龄是：6'
>>> b = "名字是：{0}，年龄是{1}。{0}是个好小伙"
>>> b.format("高淇",18)
'名字是：高淇，年龄是18。高淇是个好小伙'
>>> c = "名字是{name}，年龄是{age}"
>>> c.format(age=19,name='高淇')
'名字是高淇，年龄是19'
```

我们可以通过{索引}/{参数名}，直接映射参数值，实现对字符串的格式化，非常方便。

#### 2.6.13.2 填充与对齐

填充常跟对齐一起使用
^、<、>分别是居中、左对齐、右对齐，后面带宽度
:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充

```python
>>> "{:*>8}".format("245")
'*****245'
>>> "我是{0},我喜欢数字{1:*^8}".format("高淇","666")
'我是高淇,我喜欢数字**666***'
```

#### 2.6.13.3 数字格式化

浮点数通过f，整数通过d进行需要的格式化。如下：

```python
>>> a = "我是{0}，我的存款有{1:.2f}"
>>> a.format("高淇",3888.234342)
'我是高淇，我的存款有3888.23'
```

其他格式，供大家参考：

| 数字       | 格式    | 输出      | 描述                         |
| ---------- | ------- | --------- | ---------------------------- |
| 3.1415926  | {:.2f}  | 3.14      | 保留小数点后两位             |
| 3.1415926  | {:+.2f} | 3.14      | 带符号保留小数点后两位       |
| 2.71828    | {:.0f}  | 3         | 不带小数                     |
| 5          | {:0>2d} | 05        | 数字补零 (填充左边, 宽度为2) |
| 5          | {:x<4d} | 5xxx      | 数字补x (填充右边, 宽度为4)  |
| 10         | {:x<4d} | 10xx      | 数字补x (填充右边, 宽度为4)  |
| 1000000    | {:,}    | 1,000,000 | 以逗号分隔的数字格式         |
| 0.25       | {:.2%}  | 25.00%    | 百分比格式                   |
| 1000000000 | {:.2e}  | 1.00E+09  | 指数记法                     |
| 13         | {:10d}  | 13        | 右对齐 (默认, 宽度为10)      |
| 13         | {:<10d} | 13        | 左对齐 (宽度为10)            |
| 13         | {:^10d} | 13        | 中间对齐 (宽度为10)          |

### 2.6.14 可变字符串

在Python中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，智能创建新的字符串对象。但是，经常我们确实需要原地修改字符串，可以使用io.StringIO对象或array模块。

```python
>>> import io
>>> s = "hello, sxt"
>>> sio = io.StringIO(s)
>>> sio
<_io.StringIO object at 0x02F462B0>
>>> sio.getvalue()
'hello, sxt'
>>> sio.seek(7) #定位到位置7
7
>>> sio.write("g")  #将位置7处的字符替换
1
>>> sio.getvalue()
'hello, gxt'
```

## 2.7 字符串常用方法

### rstrip、lstrip() 和strip() 删除字符串空白

**要确保字符串末尾没有空白**，可使用方法`rstrip()` ，原字符串没有改变；剔除字符串开头的空白 `lstrip()`，或同时剔除字符串两端的空白 `strip()`

![image-20230328225504438](E:\GitHub\Note\Python_node\Python.images\image-20230328225504438.png)

### str()

显式地指出你希望Python将这个整数用作字符串。为此，可调用函数str()

```python
age = 23
message = "Happy " + str(age) + "rd Birthday!"
print(message)
---
# 如果不加入str() 则可能报错 Can't convert 'int' object to str implicitly
```











# 三、序列

序列是一种数据存储方式，用来存储一系列的数据。在内存中，序列就是一块用来存放多个值的连续的内存空间。比如一个整数序列[10,20,30,40]，可以这样示意表示：

![img](E:\Typora_files\Python_node\Python.images\wps1.jpg) 

由于Python3中一切皆对象，在内存中实际是按照如下方式存储的：

a = [10,20,30,40]

![img](E:\Typora_files\Python_node\Python.images\wps2-16546869470831.jpg) 

 从图示中，我们可以看出序列中存储的是整数对象的地址，而不是整数对象的值。python中常用的序列结构有：

字符串、列表、元组、字典、集合

 

我们上一章学习的字符串就是一种序列。关于字符串里面很多操作，在这一章中仍然会用到，大家一定会感觉非常熟悉。

本章内容，我们必须非常熟悉。无论是在学习还是工作中，序列都是每天都会用到的技术，可以非常方便的帮助我们进行数据存储的操作。

## 3.1 列表

### 3.1.1 列表简介

**列表：用于存储任意数目、任意类型的数据集合**

列表是内置可变序列，是包含多个元素的有序连续的内存空间。列表定义的标准语法格式：

a = [10,20,30,40]

其中，10,20,30,40这些称为：列表a的元素。

列表中的元素可以各不相同，==可以是任意类型==。比如：

a = [10,20,'abc',True]

列表对象的常用方法汇总如下，方便大家学习和查阅。

| 方法                 | 要点         | 描述                                                        |
| -------------------- | ------------ | ----------------------------------------------------------- |
| list.append(x)       | 增加元素     | 将元素x增加到列表list尾部                                   |
| list.extend(aList)   | 增加元素     | 将列表alist所有元素加到列表list尾部                         |
| list.insert(index,x) | 增加元素     | 在列表list指定位置index处插入元素x                          |
| list.remove(x)       | 删除元素     | 在列表list中删除首次出现的指定元素x                         |
| list.pop([index])    | 删除元素     | 删除并返回列表list指定为止index处的元素，默认是最后一个元素 |
| list.clear()         | 删除所有元素 | 删除列表所有元素，并不是删除列表对象                        |
| list.index(x)        | 访问元素     | 返回第一个x的索引位置，若不存在x元素抛出异常                |
| list.count(x)        | 计数         | 返回指定元素x在列表list中出现的次数                         |
| len(list)            | 列表长度     | 返回列表中包含元素的个数                                    |
| list.reverse()       | 翻转列表     | 所有元素原地翻转                                            |
| list.sort()          | 排序         | 所有元素原地排序                                            |
| list.copy()          | 浅拷贝       | 返回列表对象的浅拷贝                                        |

Python的==列表大小可变==，根据需要随时增加或缩小。

字符串和列表都是序列类型，一个字符串是一个字符序列，一个列表是任何元素的序列。我们前面学习的很多字符串的方法，在列表中也有类似的用法，几乎一模一样。

### 3.1.2 **列表的创建**

#### 3.1.2.1 **基本语法 []创建**

```python
>>> a = [10,20,'gaoqi','sxt']
>>> a = []   #创建一个空的列表对象
```

#### 3.1.2.2 **list()创建**

使用list()可以将任何可迭代的数据转化成列表。

```python
>>> a = list()  #创建一个空的列表对象
>>> a = list(range(10))
>>> a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> a = list("gaoqi,sxt")
>>> a
['g', 'a', 'o', 'q', 'i', ',', 's', 'x', 't']
```

#### 3.1.2.3 **range()创建整数列表**

range()可以帮助我们非常方便的创建整数列表，这在开发中及其有用。语法格式为：

range([start,] end [,step])

start参数：可选，表示起始数字。默认是0

end参数：必选，表示结尾数字。

step参数：可选，表示步长，默认为1

python3中range()返回的是一个range对象，而不是列表。我们需要通过list()方法将其转换成列表对象。

```python
>>> list(range(3,15,2))
[3, 5, 7, 9, 11, 13]
>>> list(range(15,3,-1))
[15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]
>>> list(range(3,-10,-1))
[3, 2, 1, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
```

#### 3.1.2.4 **推导式生成列表(简介一下，重点在for循环后讲)**

使用列表推导式可以非常方便的创建列表，在开发中经常使用。但是，由于涉及到for循环和if语句。在此，仅做基本介绍。在我们控制语句后面，会详细讲解更多列表推导式的细节。

```python
>>> a = [x*2  for  x  in range(5)]   #循环创建多个元素
>>> a
[0, 2, 4, 6, 8]
>>> a = [x*2 for x in range(100) if x%9==0]   #通过if过滤元素
>>> a
[0, 18, 36, 54, 72, 90, 108, 126, 144, 162, 180, 198]
```

###  3.1.3 **列表元素的增加**

当列表增加和删除元素时，列表会自动进行内存管理，大大减少了程序员的负担。但这个特点涉及列表元素的大量移动，效率较低。除非必要，我们一般只在列表的尾部添加元素或删除元素，这会大大提高列表的操作效率。

#### 3.1.3.1 **append()方法**

**原地修改**列表对象，是真正的列表尾部添加新的元素，速度最快，推荐使用。

```python
>>> a = [20,40]
>>> a.append(80)
>>> a
[20, 40, 80]
```

#### 3.1.3.2 **+运算符操作**

并不是真正的尾部添加元素，而是==**创建新的列表对象**==；将原列表的元素和新列表的元素依次复制到新的列表对象中。这样，会涉及大量的复制操作，对于操作大量元素不建议使用。

```python
>>> a = [20,40]
>>> id(a)
46016072
>>> a = a+[50]
>>> id(a)
46015432  #地址发生了变化，说明是产生了新的对象
```

#### 3.1.3.3 **extend()方法**

将**目标列表**的所有元素添加到本列表的尾部，属于**原地操作**，不创建新的列表对象。

```python
>>> a = [20,40]
>>> id(a)
46016072
>>> a.extend([50,60])
>>> id(a)
46016072  #地址未发生变化
```

#### 3.1.3.4 **insert()插入元素**

使用insert()方法可以将指定的元素插入到列表对象的指定位置。这样会让插入位置后面所有的元素进行移动，会影响处理速度。涉及大量元素时，尽量避免使用。类似发生这种移动的函数还有：remove()、pop()、del()，它们在删除非尾部元素时也会发生操作位置后面元素的移动。

```python
>>> a = [10,20,30]
>>> a.insert(2,100)
>>> a
[10, 20, 100, 30]
```

#### 3.1.3.5 **乘法扩展**

使用乘法扩展列表，生成一个新列表，新列表元素时原列表元素的多次重复。(与字符串的乘法扩展类似)

```python
>>> a = ['sxt',100]
>>> b = a*3
>>> a
['sxt', 100]
>>> b
['sxt', 100, 'sxt', 100, 'sxt', 100]
```

###  3.1.4 **列表元素的删除**

#### 3.1.4.1 **del 删除**

删除列表**指定位置**的元素。

```python
>>> a = [100,200,888,300,400]
>>> del a[1]
>>> a
[100,200,300,400]
```

![img](E:\Typora_files\Python_node\Python.images\wps3.jpg) 

#### 3.1.4.2 **pop()方法**

pop()**删除并返回指定位置元素**，如果未指定位置则默认操作列表最后一个元素。

```python
>>> a = [10,20,30,40,50]
>>> a.pop()
50
>>> a
[10, 20, 30, 40]
>>> a.pop(1)
20
>>> a
[10, 30, 40]
```

#### 3.1.4.3 **remove()方法**

删除**首次出现的指定元素**，若不存在该元素抛出异常。

```python
>>> a = [10,20,30,40,50,20,30,20,30]
>>> a.remove(20)
>>> a
[10, 30, 40, 50, 20, 30, 20, 30]
>>> a.remove(100)
Traceback (most recent call last):
 File "<pyshell#208>", line 1, in <module>
  a.remove(100)
ValueError: list.remove(x): x not in list
```

### 3.1.5 **列表元素访问和计数**

#### 3.1.5.1 **通过索引直接访问元素**

我们可以通过索引直接访问元素。索引的区间在[0, 列表长度-1]这个范围。超过这个范围则会抛出异常。

````python
>>> a = [10,20,30,40,50,20,30,20,30]
>>> a[2]
30
>>> a[10]
Traceback (most recent call last):
 File "<pyshell#211>", line 1, in <module>
  a[10]
IndexError: list index out of range
````

####  3.1.5.2 **index()获得指定元素在列表中首次出现的索引**

index()可以获取**指定元素首次**出现的索引位置。语法是：**index(value,[start,[end]])**。其中，start和end指定了搜索的范围。

```python
>>> a = [10,20,30,40,50,20,30,20,30]
>>> a.index(20)
1
>>> a.index(20,3)  #从索引位置3开始往后搜索的第一个20
5
>>> a.index(30,5,7)  #从索引位置5到7这个区间，第一次出现30元素的位置
6
```

#### 3.1.5.3 count()获得指定元素在列表中出现的次数

count()可以返回指定元素在列表中出现的次数。

```python
>>> a = [10,20,30,40,50,20,30,20,30]
>>> a.count(20)
3
```

### 3.1.6 **len()返回列表长度**

len()返回列表长度，即列表中包含元素的个数。

```python
>>> a = [10,20,30]
>>> len(a)
3
```

### 3.1.7 **成员资格判断**

判断列表中是否存在指定的元素，我们可以使用count()方法，返回0则表示不存在，返回大于0则表示存在。但是，一般我们会使用更加简洁的**in**关键字来判断，直接返回True或False。

```python
>>> a = [10,20,30,40,50,20,30,20,30]
>>> 20 in a
True
>>> 100 not in a
True
>>> 30 not in a
False
```

### 3.1.8 **切片操作**

我们在前面学习字符串时，学习过字符串的切片操作，对于列表的切片操作和字符串类似。

切片是Python序列及其重要的操作，适用于列表、元组、字符串等等。切片的格式如下：

切片slice操作可以让我们快速提取子列表或修改。标准格式为：**[起始偏移量start:终止偏移量end[:步长step]]**

注：当步长省略时顺便可以省略第二个冒号

典型操作(三个量为正数的情况)如下：

| 操作和说明                                      | 示例                           | 结果         |
| ----------------------------------------------- | ------------------------------ | ------------ |
| [:]  提取整个列表                               | [ 10 ,20,30] [:]               | [10,20,30]   |
| [start:]从start索引开始到结尾                   | [10,20,30] [1:]                | [20,30]      |
| [:end]从头开始知道end-1                         | [10,20,30] [:2]                | [10,20]      |
| [start:end]从start到end-1                       | [10,20,30,40] [1:3]            | [20,30]      |
| [start: end:step]从start提取到end-1，步长是step | [10,20,30,40,50,60,70] [1:6:2] | [20, 40, 60] |

其他操作（三个量为负数）的情况：(从右往左的索引分别为 -1，-2，-3，-4，-5，-6，-7)

| 示例                          | 说明                               | 结果                         |
| ----------------------------- | ---------------------------------- | ---------------------------- |
| [10,20,30,40,50,60,70] [-3:]  | 倒数三个                           | [50,60,70]                   |
| 10,20,30,40,50,60,70][-5:-3]  | 倒数第五个到倒数第三个(包头不包尾) | [30,40]                      |
| [10,20,30,40,50,60,70] [::-1] | 步长为负，从右到左反向提取         | [70, 60, 50, 40, 30, 20, 10] |

切片操作时，起始偏移量和终止偏移量不在[0,字符串长度-1]这个范围，也不会报错。起始偏移量小于0则会当做0，终止偏移量大于“长度-1”会被当成”长度-1”。例如：

```python
>>> [10,20,30,40] [1:30]
[20, 30, 40]
```

### 3.1.9 **列表的遍历**

```python
for obj  in  listObj:
	print(obj)
```

### 3.1.10 **复制列表所有的元素到新列表对象**

如下代码实现列表元素的复制了吗？

list1 = [30,40,50]

list2 = list1

只是将list2也指向了列表对象，也就是说list2和list2持有地址值是相同的，列表对象本身的元素并没有复制。 

我们可以通过如下简单方式，实现列表元素内容的复制：

list1 = [30,40,50]

list2 = [] + list1

注：我们后面也会学习copy模块，使用浅复制或深复制实现我们的复制操作。

### 3.1.11 **列表排序**

#### **3.1.11.1 修改原列表，不建新列表的排序**

```python
>>> a = [20,10,30,40]
>>> id(a)
46017416
>>> a.sort()         #默认是升序排列
>>> a
[10, 20, 30, 40]
>>> a = [10,20,30,40]
>>> a.sort(reverse=True)    #降序排列
>>> a
[40, 30, 20, 10]
>>> import random
>>> random.shuffle(a)    #打乱顺序
>>> a
[20, 40, 30, 10]
```

#### 3.1.11.2 **建新列表的排序**

我们也可以通过**内置函数sorted()**进行排序，这个方法返回新列表，不对原列表做修改。

```python
>>> a = [20,10,30,40]
>>> id(a)
46016008
>>> a = sorted(a)          #默认升序
>>> a
[10, 20, 30, 40]
>>> id(a)
45907848
>>> a = [20,10,30,40]
>>> id(a)
45840584
>>> b = sorted(a)
>>> b
[10, 20, 30, 40]
>>> id(a)
45840584
>>> id(b)
46016072
>>> c = sorted(a,reverse=True)    #降序
>>> c
[40, 30, 20, 10]
#可知b、c都是新列表对象
```

### 3.1.12 **reversed()返回迭代器**

内置函数reversed()也支持进行逆序排列，与列表对象reverse()方法不同的是，内置函数reversed()不对原列表做任何修改，只是返回一个逆序排列的迭代器对象。

该迭代器只能使用一次，相当于得到一个指向列表末尾的指针，使用迭代器的过程即为指针从列表尾移动到列表头，故只能使用一次。

```python
>>> a = [20,10,30,40]
>>> c = reversed(a)
>>> c
<list_reverseiterator object at 0x0000000002BCCEB8>
>>> list(c)
[40, 30, 10, 20]
>>> list(c)
[]   #只能使用一次，第二次返回空列表
```

### 3.1.13**列表相关的其他内置函数汇总**

#### 3.1.13.1 **max和min**

用于返回列表中最大和最小值。

```python
>>> a = [3,10,20,15,9]
>>> max(a)
20
>>> min(a)
3
```

#### 3.1.13.2 **sum**

对数值型列表的所有元素进行求和操作，对非数值型列表运算则会报错。

```python
>>> a = [3,10,20,15,9]
>>> sum(a)
57
```

## 3.2 元组tuple

**列表属于可变序列**，可以任意修改列表中的元素。**元组属于不可变序列**，不能修改元组中的元素。因此，元组没有增加元素、修改元素、删除元素相关的方法。

因此，我们只需要学习元组的创建和删除，元组中元素的访问和计数即可。元组支持如下操作：

1.   索引访问
2.   切片操作

3.   连接操作

4.   成员关系操作

5.   比较运算操作

6.   计数：元组长度len()、最大值max()、最小值min()、求和sum()等。

### 3.2.1 元组的创建

1.   **通过()创建元组。****小括号可以省略**。
     	 a = (10,20,30)   或者  a = 10,20,30

**如果元组只有一个元素，则必须后面加逗号**。这是因为解释器会把(1)解释为整数1，(1,)解释为元组

```python
>>> a = (1)
>>> type(a)
<class 'int'>    #不加,将会被解释为整型
>>> a = (1,)     #或者  a = 1, 
>>> type(a)
<class 'tuple'>
```

2. **通过tuple()创建元组**

   tuple(可迭代的对象)

```python
b = tuple()		#创建一个空元组对象
b = tuple("abc")
b = tuple(range(3))
b = tuple([2,3,4])
```

==tuple()可以接收列表、字符串、其他序列类型、迭代器等生成元组。==

==list()可以接收元组、字符串、其他序列类型、迭代器等生成列表。==

### 3.2.2 元组的元素访问和计数

1.   元组的元素不能修改

```python
>>> a = (20,10,30,9,8)
>>> a[3]=33
Traceback (most recent call last):
  File "<pyshell#313>", line 1, in <module>
    a[3]=33
TypeError: 'tuple' object does not support item assignment
```

2.   元组的元素访问和列表一样，只不过返回的仍然是元组对象。

```python
>>> a = (20,10,30,9,8)
>>> a[1]
10
>>> a[1:3]
(10, 30)
>>> a[:4]
(20, 10, 30, 9)
```

3.   列表关于排序的方法list.sorted()是修改原列表对象，**元组没有该方法**。如果要对元组排序，**只能使用内置函数sorted(tupleObj)**，并生成新的**列表对象**。

```python
>>> a = (20,10,30,9,8)
>>> sorted(a)
[8, 9, 10, 20, 30]
```

### 3.2.3 zip

zip(列表1，列表2，...)将**多个列表对应位置的元素组合成为元组**，并返回这个zip对象。

```python
>>> a = [10,20,30]
>>> b = [40,50,60]
>>> c = [70,80,90]
>>> d = zip(a,b,c)
>>> list(d)
[(10, 40, 70), (20, 50, 80), (30, 60, 90)]
```

### 3.2.4 生成器推导式创建元组

​	从形式上看，生成器推导式与列表推导式类似，只是生成器推导式使用小括号。列表推导式直接生成列表对象，生成器推导式生成的不是列表也不是元组，而是一个**生成器对象**。

​	我们可以通过生成器对象，转化成列表或者元组。也可以使用生成器对象的__ next__()方法进行遍历，或者直接作为迭代器对象来使用。不管什么方式使用，元素访问结束后，如果需要重新访问其中的元素，必须重新创建该生成器对象。

```python
>>> s = (x*2 for x in range(5))
>>> s
<generator object <genexpr> at 0x0000000002BDEB48>  #生成器对象
>>> tuple(s)
(0, 2, 4, 6, 8)
>>> list(s)         #只能访问一次元素。第二次就为空了。需要再生成一次
[]
>>> s
<generator object <genexpr> at 0x0000000002BDEB48>
>>> tuple(s)
()
>>> s = (x*2 for x in range(5))
>>> s.__next__()
0
>>> s.__next__()
2
>>> s.__next__()
4
```

### 3.2.5 元组总结

1.   元组的核心特点是：不可变序列。

2.   元组的访问和处理速度比列表快。
3.   与整数和字符串一样，元组可以作为字典的键（元组不可变），列表则永远不能作为字典的键使用。

## 3.3 字典

### 3.3.1 字典介绍

字典是“键值对”的无序可变序列，字典中的每个元素都是一个“键值对”，包含：“键对象”和“值对象”。可以通过“键对象”实现快速获取、删除、更新对应的“值对象”。

列表中我们通过“下标数字”找到对应的对象。字典中通过“键对象”找到对应的“值对象”。“键”是任意的**不可变数据**，比如：整数、浮点数、字符串、元组。但是：列表、字典、集合这些可变对象，不能作为“键”。并且**“键”不可重复。**

**“值”可以是任意的数据，并且可重复。**

一个典型的字典的定义方式：

​												a = {'name':'gaoqi','age':18,'job':'programmer'}3.

### 3.3.2 字典的创建

1.   我们可以通过{}、dict()来创建字典对象。

```python
>>> a = {'name':'gaoqi','age':18,'job':'programmer'}
>>> b = dict(name='gaoqi',age=18,job='programmer')
>>> a = dict([("name","gaoqi"),("age",18)])  #dict列表，列表的元素为元组
>>> c = {}   #空的字典对象
>>> d = dict()   #空的字典对象
```

2.   通过zip()创建字典对象

```python
>>> k = ['name','age','job']
>>> v = ['gaoqi',18,'techer']
>>> d = dict(zip(k,v))  #zip中第一个为key，第二个为value
>>> d
{'name': 'gaoqi', 'age': 18, 'job': 'techer'}
```

​	zip函数本身是可以将多个列表组合起来，但是放入dict函数中时只能放入key和value

````python
k = ['a','b','c']
v = [1,2,3]
k1 = ['1','2',3]
a = zip(k,v,k1)
print(a)
c = dict(zip(k,v,k1)) #报错
print(c)
```
<zip object at 0x00000227F086A500>
Traceback (most recent call last):
  File "D:\PythonProject\test\main.py", line 6, in <module>
    c = dict(zip(k,v,k1))
ValueError: dictionary update sequence element #0 has length 3; 2 is required
```
````

3.   通过fromkeys创建值为空的字典

```python
>>> a = dict.fromkeys(['name','age','job'])
>>> a
{'name': None, 'age': None, 'job': None}
```

### 3.3.3 字典元素的访问

为了测试各种访问方法，我们这里设定一个字典对象：

 a = {'name':'gaoqi','age':18,'job':'programmer'}

1.   通过  [键]  获得“值”。若键不存在，则抛出异常。

```python
>>> a = {'name':'gaoqi','age':18,'job':'programmer'}
>>> a['name']
'gaoqi'
>>> a['age']
18
>>> a['sex']
Traceback (most recent call last):
  File "<pyshell#374>", line 1, in <module>
    a['sex']
KeyError: 'sex'
```

2.   通过get()方法获得“值”。推荐使用。优点是：指定键不存在，返回None；也可以设定指定键不存在时默认返回的对象。推荐使用get()获取“值对象”。

```python
>>> a.get('name')
'gaoqi'
>>> a.get('sex')
>>> a.get('sex','一个男人')
'一个男人'
```

3.   列出所有的键值对

```python
>>> a.items()
dict_items([('name', 'gaoqi'), ('age', 18), ('job', 'programmer')])
```

4.   列出所有的键，列出所有的值

```python
>>> a.keys()
dict_keys(['name', 'age', 'job'])
>>> a.values()
dict_values(['gaoqi', 18, 'programmer'])
```

5.   len()键值对的个数
6.   检测一个键是否在字典中

```python
>>> a = {"name":"gaoqi","age":18}
>>> "name" in a
True
```

### 3.3.4 字典元素添加、修改、删除

1.   给字典新增“键值对”。**如果“键”已经存在，则覆盖旧的键值对；如果“键”不存在，则新增“键值对”。**

```python
>>>a = {'name':'gaoqi','age':18,'job':'programmer'}
>>> a['address']='西三旗1号院'
>>> a['age']=16
>>> a
{'name': 'gaoqi', 'age': 16, 'job': 'programmer', 'address': '西三旗1号院'}
```

2.   使用update()将新字典中所有键值对全部**添加**到旧字典对象上。如果key有重复，则直接覆盖。

```python
>>> a = {'name':'gaoqi','age':18,'job':'programmer'}
>>> b = {'name':'gaoxixi','money':1000,'sex':'男的'}
>>> a.update(b)
>>> a
{'name': 'gaoxixi', 'age': 18, 'job': 'programmer', 'money': 1000, 'sex': '男的'}
```

3.   字典中元素的删除，可以使用del()方法；或者clear()删除所有键值对；pop()删除指定键值对，并返回对应的“值对象”；

```python
>>> a = {'name':'gaoqi','age':18,'job':'programmer'}
>>> del(a['name'])
>>> a
{'age': 18, 'job': 'programmer'}
>>> b = a.pop('age')
>>> b
18
```

4.   popitem() ：随机删除和返回该键值对。字典是“无序可变序列”，因此没有第一个元素、最后一个元素的概念；*popitem弹出随机的项，因为字典并没有"最后的元素"或者其他有关顺序的概念。*若想一个接一个地移除并处理项，这个方法就非常有效（因为不用首先获取键的列表）。

```python
>>> a = {'name':'gaoqi','age':18,'job':'programmer'}
>>> a.popitem()
('job', 'programmer')
>>> a
{'name': 'gaoqi', 'age': 18}
>>> a.popitem()
('age', 18)
>>> a
{'name': 'gaoqi'}
```

**实际测试结果是删除最后的项**

```python
a = {'name':'gaoqi','job':'programmer','age':18}
print(a)
a.popitem()
print(a)
a.popitem()
print(a)

{'name': 'gaoqi', 'job': 'programmer', 'age': 18}
{'name': 'gaoqi', 'job': 'programmer'}
{'name': 'gaoqi'}
```

## 3.4 序列解包

序列解包可以用于元组、列表、字典。序列解包可以让我们方便的对多个变量赋值。

```python
>>> x,y,z=(20,30,10)
>>> x
20
>>> y
30
>>> z
10
>>> (a,b,c)=(9,8,10)
>>> a
9
>>> [a,b,c]=[10,20,30]
>>> a
10
>>> b
20
```

序列解包用于字典时，默认是对“键”进行操作； 如果需要对键值对操作，则需要使用items()；如果需要对“值”进行操作，则需要使用values()；

```python
>>> s = {'name':'gaoqi','age':18,'job':'teacher'}
>>> name,age,job=s			#默认对键进行操作
>>> name
'name'
>>> name,age,job=s.items()		#对键值对进行操作
>>> name
('name', 'gaoqi')
>>> name,age,job=s.values()		#对值进行操作
>>> name
'gaoqi'
```

## 3.5 字典核心底层原理(重要)

字典对象的核心是**散列表**。散列表是一个稀疏数组（总是有空白元素的数组），数组的每个单元叫做bucket。每个bucket有两部分：一个是键对象的引用，一个是值对象的引用。

由于，所有bucket结构和大小一致，我们可以通过偏移量来读取指定bucket。

![img](E:\Typora_files\Python_node\Python.images\wps1-16547606989841.jpg) 

 

### 3.5.1 将一个键值对放进字典的底层过程

```python
>>> a = {}
>>> a["name"]="gaoqi"
```

假设字典a对象创建完后，数组长度为8：

![img](E:\Typora_files\Python_node\Python.images\wps2-16547607431172.jpg) 

我们要把”name”=”gaoqi”这个键值对放到字典对象a中，首先第一步需要计算键”name”的散列值。Python中可以通过hash()来计算。

```python
>>> bin(hash("name"))
'-0b1010111101001110110101100100101'
```

由于数组长度为8，我们可以拿计算出的散列值的最右边3位数字作为偏移量，即“101”，十进制是数字5。我们查看偏移量5，对应的bucket是否为空。如果为空，则将键值对放进去。如果不为空，则依次取右边3位作为偏移量，即“100”，十进制是数字4。再查看偏移量为4的bucket是否为空。直到找到为空的bucket将键值对放进去。流程图如下：

![img](E:\Typora_files\Python_node\Python.images\wps3-16547607758123.jpg) 

​                                                                            ![img](E:\Typora_files\Python_node\Python.images\wps4.jpg)       

**扩容**

python会根据散列表的拥挤程度扩容。“扩容”指的是:创造更大的数组，将原有内容拷贝到新数组中。

接近2/3时，数组就会扩容。

### 3.5.2 根据键查找“键值对”的底层过程

我们明白了，一个键值对是如何存储到数组中的，根据键对象取到值对象，理解起来就简单了。

```python
>>> a.get("name")
'gaoqi'
```

当我们调用a.get(“name”)，就是根据键“name”查找到“键值对”，从而找到值对象“gaoqi”。

第一步，我们仍然要计算“name”对象的散列值：

```python
>>> bin(hash("name"))
'-0b1010111101001110110101100100101'
```

和存储的底层流程算法一致，也是依次取散列值的不同位置的数字。 假设数组长度为8，我们可以拿计算出的散列值的最右边3位数字作为偏移量，即“101”，十进制是数字5。我们查看偏移量5，对应的bucket是否为空。如果为空，则返回None。如果不为空，则将这个bucket的键对象计算对应散列值，和我们的散列值进行比较，如果相等。则将对应“值对象”返回。如果不相等，则再依次取其他几位数字，重新计算偏移量。依次取完后，仍然没有找到。则返回None。流程图如下：

![img](E:\Typora_files\Python_node\Python.images\wps5.jpg)

用法总结：

1. 键必须可散列

   （1）、 数字、字符串、元组，都是可散列的。

   （2）、自定义对象需要支持下面三点：

   -   **支持hash()函数**
   -   **支持通过__ eq__()方法检测相等性。**
   -   **若a == b为真，则hash(a)==hash(b)也为真。**

2. 字典在内存中开销巨大，典型的空间换时间。

3. 键查询速度很快

4. 往字典里面添加新建可能导致扩容，导致散列表中键的次序变化。因此，**不要在遍历字典的同时进行字典的修改。**

## 3.6 集合

集合是无序可变，元素不能重复。实际上，**集合底层是字典实现**，集合的所有元素都是字典中的“键对象”，因此是不能重复的且唯一的。

### 3.6.1 集合创建和删除

1.   使用{}创建集合对象，并使用add()方法添加元素

```python
>>> a = {3,5,7}
>>> a
{3, 5, 7}
>>> a.add(9)
>>> a
{9, 3, 5, 7}
```

2.   使用set()，将列表、元组等可迭代对象转成集合。如果原来数据存在重复数据，则只保留一个。

```python
>>> a = ['a','b','c','b']
>>> b = set(a)
>>> b
{'b', 'a', 'c'}
```

3.   remove()删除指定元素；clear()清空整个集合

```python
>>> a = {10,20,30,40,50}
>>> a.remove(20)
>>> a
{10, 50, 30}
```

### 3.6.2 集合相关操作

像数学中概念一样，Python对集合也提供了**并集、交集、差集**等运算。我们给出示例：

```python
>>> a = {1,3,'sxt'}
>>> b = {'he','it','sxt'}
>>> a|b					#并集
{1, 3, 'sxt', 'he', 'it'}
>>> a&b					#交集
{'sxt'}
>>> a-b					#差集
{1, 3}
>>> a.union(b)				#并集
{1, 3, 'sxt', 'he', 'it'}
>>> a.intersection(b)		#交集
{'sxt'}
>>> a.difference(b)			#差集
{1, 3}
```

# enumerate()函数

## enumerate()函数的基本用法

这个函数的基本应用就是用来遍历一个集合对象，**它在遍历的同时还可以得到当前元素的位置索引**

```python
names = ["Alice","Bob","Carl"]
for index,value in enumerate(names):
    print(f'{index}: {value}')
    
0: Alice
1: Bob
2: Carl
```

在之前遍历集合对象想要得到索引采用的是下面的方式：

```python
# 警告: 不建议这么写
for i in range(len(my_items)):
    print(i, my_items[i])
```

但是这种风格非常的不 pythonic，所以建议使用 enumerate()函数

enumerate()函数允许我们为循环自定义起始索引值

```python
names = ["Alice","Bob","Carl"]
for index,value in enumerate(names,1):
    print(f'{index}: {value}')
# 此时起始索引值就不再是0而是1了
```

## enumrate() 函数是如何工作的

它的部分魔法是通过Python迭代器来实现的。每个元素的索引是懒加载的（一个接一个，用的时候生成），这使得内存使用量很低并且保持这个结构很快的运行。



# 四、控制语句

## 4.1 选择结构

选择结构通过判断条件是否成立，来决定执行哪个分支。选择结构有多种形式，分为：单分支、双分支、多分支。流程图如下：

单分支结构							                                                           双分支结构

![img](E:\Typora_files\Python_node\Python.images\wps1-16547803501074.jpg)![img](E:\Typora_files\Python_node\Python.images\wps2-16547803501085.jpg) 

 

​                                                                                     多分支结构

​                                               <img src="E:\Typora_files\Python_node\Python.images\wps3-16547803501086.jpg" alt="img" style="zoom:50%;" /> 

### 4.1.1 单分支选择结构

if语句单分支结构的语法形式如下：

if 条件表达式:

​		语句/语句块

其中：

①．条件表达式：可以是逻辑表达式、关系表达式、算术表达式等等。

②．语句/语句块：可以是一条语句，也可以是多条语句。多条语句，缩进必须对齐一致。

### 4.1.2 条件表达式详解

​	在选择和循环结构中，条件表达式的值为False的情况如下：==False、0、0.0、空值None、空序列对象（空列表、空元祖、空集合、空字典、空字符串）、空range对象、空迭代对象==。

​	其他情况，均为True。这么看来，Python所有的合法表达式都可以看做条件表达式，甚至包括函数调用的表达式。

```python
if 3:    #整数作为条件表达式
    print("ok")
a = []   #列表作为条件表达式，由于为空列表，是False
if a:
    print("空列表，False")
s = "False"    #非空字符串，是True
if s:
    print("非空字符串，是True")

c = 9
if 3<c<20:
    print("3<c<20")
if 3<c  and  c<20:
    print("3<c  and c<20")

if True:        #布尔值
    print("True")

    
    
ok
非空字符串，是True
3<c<20
3<c  and c<20
True
```

**条件表达式中，不能有赋值操作符“=”**

在Python中，条件表达式不能出现赋值操作符“=”，避免了其他语言中经常误将关系运算符“==”写作赋值运算符“=”带来的困扰。如下代码将会报语法错误：

```python
if 3<c and (c=20):      #此行报错
    print("赋值符不能出现在条件表达式中")
```

### 4.1.3 双分支选择结构

双分支结构的语法格式如下：

if  条件表达式 :

​		语句1/语句块1

else:

​		语句2/语句块2

### 4.1.4 三元条件运算符

Python提供了三元运算符（类似于? : 表达式），用来在某些简单双分支赋值情况。三元条件运算符语法格式如下：                       条件为真时的值  if  (条件表达式)  else 条件为假时的值

### 4.1.5 多分支选择结构

多分支选择结构的语法格式如下：

if 条件表达式1 :

​		语句1/语句块1

elif 条件表达式2:

​		语句2/语句块2

···

elif 条件表达式n :

​		语句n/语句块n

[else:

​		语句n+1/语句块n+1

]

```python
score = int(input("请输入分数"))
grade = ''
if score<60 :
    grade = "不及格"
elif  score<80 :
    grade = "及格"
elif  score<90 :
    grade = "良好"
elif  score<=100:
    grade = "优秀"
print("分数是{0},等级是{1}".format(score,grade))
```

### 4.1.6选择结构嵌套

**选择结构可以嵌套，使用时一定要注意控制好不同级别代码块的缩进量**，因为缩进量决定了代码的从属关系。语法格式如下：

if 表达式1：

​		语句块1

​		if 表达式2：

​				语句块2

​		else:

​				语句块3

else:

​		if 表达式4：

​				语句块4

```python
score = int(input("请输入一个在0-100之间的数字："))
grade = ""
if score>100 or score<0:
    print(input("输入错误！"))
else:
    if score>=90:
        grade = "A"
    elif score>=80:
        grade = 'B'
    elif score>=70:
        grade = 'C'
    elif score>=60:
        grade = 'D'
    else:
        grade = 'E'
    print("分数为{0},等级为{1}".format(score,grade))
```

## 4.2 循环结构

循环结构用来重复执行一条或多条语句。表达这样的逻辑：如果符合条件，则反复执行循环体里的语句。在每次执行完后都会判断一次条件是否为True，如果为True则重复执行循环体里的语句。图示如下：

​                                                              ![img](E:\Typora_files\Python_node\Python.images\wps4.png) 

循环体里面的语句至少应该包含改变条件表达式的语句，以使循环趋于结束；否则，就会变成一个死循环。

### 4.2.1 while循环

while循环的语法格式如下：

while  条件表达式：

​		循环体语句

```python
num = 0
sum_all = 0         #1-100所有数的累加和
sum_even = 0        #1-100偶数的累加和
sum_odd = 0         #1-100奇数的累加和
while num<=100:
    sum_all += num
    if num%2==0:sum_even += num
    else:sum_odd += num
    num += 1         #迭代，改变条件表达式，使循环趋于结束
print("1-100所有数的累加和",sum_all)
print("1-100偶数的累加和",sum_even)
print("1-100奇数的累加和",sum_odd)
```

### 4.2.2 for循环和可迭代对象遍历

for循环通常用于可迭代对象的遍历。for循环的语法格式如下：

for  变量  in  可迭代对象：

​		循环体语句

### 4.2.3 可迭代对象

Python包含以下几种可迭代对象：

1.   序列。包含：字符串、列表、元组

2.   字典

3.   迭代器对象（iterator）

4.   生成器函数（generator）

5.   文件对象

```python
d = {'name':'gaoqi','age':18,'address':'西三旗001号楼'}
for x  in  d:  #遍历字典所有的key
    print(x)

for x   in  d.keys():#遍历字典所有的key
    print(x)

for x   in  d.values():#遍历字典所有的value
    print(x)

for x   in  d.items():#遍历字典所有的"键值对"
    print(x)
```

### 4.2.4 range对象

range对象是一个迭代器对象，用来产生指定范围的数字序列。格式为：

​										range(start, end  [,step])

生成的数值序列从start开始到end结束（不包含end）。若没有填写start，则默认从0开始。step是可选的步长，默认为1。如下是几种典型示例：

​					for i in range(10)				产生序列：0 1 2 3 4 5 6 7 8 9

​					for i in range(3,10)			产生序列：3 4 5 6 7 8 9  

​					for i in range(3,10,2)			产生序列：3  5  7  9  

```python
sum_all = 0         #1-100所有数的累加和
sum_even = 0        #1-100偶数的累加和
sum_odd = 0         #1-100奇数的累加和
for num in range(101):
    sum_all += num
    if num%2==0:sum_even += num
    else:sum_odd += num
print("1-100累加总和{0},奇数和{1},偶数和{2}".format(sum_all,sum_odd,sum_even))
```

### 4.2.5 嵌套循环和综合练习

一个循环体内可以嵌入另一个循环，一般称为“嵌套循环”，或者“多重循环”。

```python
for x in range(5):
    for y in range(5):
        print(x,end="\t")
    print()   #仅用于换行
```

打印九九乘法表

```python
for m in range(1,10):
    for n in range(1,m+1):
        print("{0}*{1}={2}".format(m,n,(m*n)),end="\t")
    print()
```

### 4.2.6 break语句

break语句可用于while和for循环，用来结束整个循环。当有嵌套循环时，break语句只能跳出最近一层的循环。

### 4.2.7 continue语句

continue语句用于结束本次循环，继续下一次。多个循环嵌套时，continue也是应用于最近的一层循环。

**【操作】要求输入员工的薪资，若薪资小于0则重新输入。最后打印出录入员工的数量和薪资明细，以及平均薪资**

```python
empNum = 0
salarySum= 0
salarys = []
while True:
    s = input("请输入员工的薪资（按Q或q结束）")

    if s.upper()=='Q':
        print("录入完成，退出")
        break
    if float(s)<0:
        continue
    empNum +=1
    salarys.append(float(s))
    salarySum += float(s)
print("员工数{0}".format(empNum))
print("录入薪资：",salarys)
print("平均薪资{0}".format(salarySum/empNum))
```

### 4.2.8 else语句

while、for循环可以附带一个else语句（可选）。==**如果for、while语句没有被break语句结束，则会执行else子句，否则不执行**==。语法格式如下：

​	while  条件表达式：

​				循环体

​	else:

​				语句块 

或者：

​	for  变量  in  可迭代对象：

​				循环体

​	else:

​				语句块

**【操作】员工一共4人。录入这4位员工的薪资。全部录入后，打印提示“您已经全部录入4名员工的薪资”。最后，打印输出录入的薪资和平均薪资**

```python
salarySum= 0
salarys = []
for i in range(4):
    s = input("请输入一共4名员工的薪资（按Q或q中途结束）")

    if s.upper()=='Q':
        print("录入完成，退出")
        break
    if float(s)<0:
        continue

    salarys.append(float(s))
    salarySum += float(s)

else:
    print("您已经全部录入4名员工的薪资")    

print("录入薪资：",salarys)
print("平均薪资{0}".format(salarySum/4))
```

### 4.2.9 循环代码优化

虽然计算机越来越快，空间也越来越大，我们仍然要在性能问题上“斤斤计较”。编写循环时，遵守下面三个原则可以大大提高运行效率，避免不必要的低效计算：

1. 尽量减少循环内部不必要的计算
2. 嵌套循环中，尽量减少内层循环的计算，尽可能向外提。
3. 局部变量查询较快，尽量使用局部变量

```python
#循环代码优化测试
import time

start = time.time()
for i in range(1000):
    result = []
    for m in range(10000):
        result.append(i*1000+m*100)

end = time.time()
print("耗时：{0}".format((end-start)))

start2 = time.time()
for i in range(1000):
    result = []
    c = i*1000
    for m in range(10000):
        result.append(c+m*100)

end2 = time.time()
print("耗时：{0}".format((end2-start2)))
```

#### 4.2.9.1 其他优化手段

1. 连接多个字符串，使用join()而不使用+

2. 列表进行元素插入和删除，尽量在列表尾部操作

## 4.3 使用zip()并行迭代

我们可以通过zip()函数对多个序列进行并行迭代，zip()函数在最短序列“用完”时就会停止。

```python
names = ("高淇","高老二","高老三","高老四")
ages = (18,16,20,25)
jobs = ("老师","程序员","公务员")

for name,age,job in zip(names,ages,jobs):
    print("{0}--{1}--{2}".format(name,age,job))
```

## 4.4 推导式创建序列

推导式是从一个或者多个迭代器快速创建序列的一种方法。它可以将循环和条件判断结合，从而避免冗长的代码。推导式是典型的Python风格，会使用它代表你已经超过Python初学者的水平。

### 4.4.1 列表推导式

列表推导式生成列表对象，语法如下：

​			[表达式  for  item  in 可迭代对象 ]

或者：[表达式  for  item  in 可迭代对象  if  条件判断]

 ```python
>>> [x for x in range(1,5)]
[1, 2, 3, 4]
>>> [x*2 for x in range(1,5)]
[2, 4, 6, 8]
>>> [x*2 for x in range(1,20) if x%5==0 ]
[10, 20, 30]
>>> [a  for  a  in "abcdefg"]
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> cells = [(row,col) for  row in range(1,10) for col in range(1,10)]  #可以使用两个循环 
 ```

### 4.4.2 字典推导式

字典的推导式生成字典对象，格式如下：

​				{key_expression  :  value_expression  for  表达式  in  可迭代对象}

类似于列表推导式，字典推导也可以增加if条件判断、多个for循环。

统计文本中字符出现的次数：

```python
>>> my_text = ' i love you, i love sxt, i love gaoqi'
>>> char_count = {c:my_text.count(c)   for c in my_text}
>>> char_count
{' ': 9, 'i': 4, 'l': 3, 'o': 5, 'v': 3, 'e': 3, 'y': 1, 'u': 1, ',': 2, 's': 1, 'x': 1, 't': 1, 'g': 1, 'a': 1, 'q': 1}
```

### 4.4.3 集合推导式

集合推导式生成集合，和列表推导式的语法格式类似：

​			{表达式  for  item  in 可迭代对象 }

或者：{表达式  for  item  in 可迭代对象  if  条件判断}

 ```python
>>> {x for x in range(1,100) if x%9==0}
{99, 36, 72, 9, 45, 81, 18, 54, 90, 27, 63}
 ```

### 4.4.4 生成器推导式（生成元组）

很多同学可能会问：“都有推导式，元组有没有？”，能不能用小括号呢？

```python
>>> (x for x in range(1,100) if x%9==0)
<generator object <genexpr> at 0x0000000002BD3048>
```

我们发现提示的是“一个生成器对象”。显然，元组是没有推导式的。

**一个生成器只能运行一次**。第一次迭代可以得到数据，第二次迭代发现数据已经没有了。

```python
>>> gnt = (x for x in range(1,100) if x%9==0)
>>> for x in gnt:
print(x,end=' ')
>>>9 18 27 36 45 54 63 72 81 90 99 
>>> for x in gnt:
print(x,end=' ')
>>>
```

```python
# 绘制棋盘
import turtle
t = turtle.Pen()

for i in range(19):
    t.penup()
    t.goto(-200+10*i,200)
    t.pendown()
    t.goto(-200+10*i,20)
for i in range(19):
    t.penup()
    t.goto(-200,200-10*i)
    t.pendown()
    t.goto(-20, 200-10*i)
turtle.done()
```

# 五、函数用法和底层分析

函数是**可重用的程序代码块**。函数的作用，不仅可以实现代码的复用，更能实现代码的一致性。一致性指的是，只要修改函数的代码，则所有调用该函数的地方都能得到体现。

在编写函数时，函数体中的代码写法和我们前面讲述的基本一致，只是对代码实现了封装，并增加了函数调用、传递参数、返回计算结果等内容。

为了让大家更容易理解，掌握的更深刻。我们也要深入内存底层进行分析。绝大多数语言内存底层都是高度相似的，这样大家掌握了这些内容也便于以后学习其他语言。 

## 5.1 函数简介

### 5.1.1 函数的基本概念

1. 一个程序由一个个任务组成；函数就是代表一个任务或者一个功能。

2. 函数是代码复用的通用机制。

### 5.1.2 Python函数的分类

Python中函数分为如下几类：

1. 内置函数
   我们前面使用的str()、list()、len()等这些都是内置函数，我们可以拿来直接使用。

2. 标准库函数
   我们可以通过import语句导入库，然后使用其中定义的函数

3. 第三方库函数
   Python社区也提供了很多高质量的库。下载安装这些库后，也是通过import语句导入，然后可以使用这些第三方库的函数

4. 用户自定义函数

   用户自己定义的函数，显然也是开发中适应用户自身需求定义的函数。

## 5.2 函数的定义和调用

### 5.2.1 核心要点

Python中，定义函数的语法如下：

**def  函数名 ([参数列表]) :**

​		**'''文档字符串'''**

​		**函数体/若干语句**

**要点：**

1. 我们使用def来定义函数，然后就是一个空格和函数名称；

   (1) Python执行def时，会创建一个函数对象，并绑定到函数名变量上。

2. 参数列表

   (1) 圆括号内是形式参数列表，有多个参数则使用逗号隔开

   (2) 形式参数**不需要声明类型**，也不需要指定函数返回值类型 

   (3) **无参数，也必须保留空的圆括号**

   (4) **实参列表必须与形参列表一一对应**

3. return返回值

   (1) 如果函数体中包含return语句，则结束函数执行并返回值；

   (2) 如果函数体中不包含return语句，则**返回None值**。

4. 调用函数之前，必须要**先定义函数**，即先调用def创建函数对象

   (1) 内置函数对象会自动创建

   (2) 标准库和第三方库函数，通过import导入模块时，会**执行**模块中的def语句

我们通过实际定义函数来学习函数的定义方式。

### 5.2.2 形参和实参

形参和实参的要点，请参考上一节中的总结。在此不再赘述

```python
def  printMax(a,b):
    '''实现两个数的比较，并返回较大的值'''
    if a>b:
        print(a,'较大值')
    else:
        print(b,'较大值')
printMax(10,20)
printMax(30,5)
```

上面的printMax函数中，在定义时写的printMax(a,b)。a和b称为“形式参数”，简称“形参”。也就是说，形式参数是在定义函数时使用的。 形式参数的命名只要符合“标识符”命名规则即可。

在调用函数时，传递的参数称为“实际参数”，简称“实参”。上面代码中，printMax(10,20)，10和20就是实际参数。

### 5.2.3 文档字符串(函数的注释)

程序的可读性最重要，一般建议在函数体开始的部分附上函数定义说明，这就是“文档字符串”，也有人成为“函数的注释”。我们通过三个单引号或者三个双引号来实现，中间可以加入多行文字进行说明。

我们调用help(函数名.__doc__)可以打印输出函数的文档字符串。

### 5.2.4 返回值

return返回值要点：

1. 如果函数体中包含return语句，则***\*结束函数执行\****并返回值；

2. 如果函数体中不包含return语句，则返回None值。
3. 要返回多个返回值，使用列表、元组、字典、集合将多个值“存起来”即可。

## 5.3 函数也是对象，内存底层分析

Python中，“一切都是对象”。实际上，执行def定义函数后，系统就创建了相应的函数对象。我们执行如下程序，然后进行解释：

```python
def print_star(n):                 
    print("*"*n)
print(print_star)
print(id(print_star))
c = print_star
c(3)
```

上面代码执行def时，**系统中会创建函数对象**，并通过**print_star这个变量进行引用**：

<img src="E:\Typora_files\Python_node\Python.images\wps1-16559717101041.jpg" alt="img" style="zoom:67%;" /> 

我们执行“c=print_star”后，显然将print_star变量的值赋给了变量c，内存图变成了：

<img src="E:\Typora_files\Python_node\Python.images\wps2-16559717101062.jpg" alt="img" style="zoom:67%;" /> 

显然，我们可以看出变量c和print_star都是指向了同一个函数对象。因此，执行c(3)和执行print_star(3)的效果是完全一致的。 Python中，**圆括号意味着调用函数。在没有圆括号的情况下，Python会把函数当做普通对象**。

与此核心原理类似，我们也可以做如下操作：

zhengshu = int

zhengshu("234")

显然，**我们将内置函数对象int()赋值给了变量zhengshu，这样zhengshu和int都是指向了同一个内置函数对象**。当然，此处仅限于原理性讲解，实际开发中没必要这么做。

## 5.4 变量的作用域(全局变量和局部变量)

变量起作用的范围称为变量的作用域，不同作用域内同名变量之间互不影响。变量分为：全局变量、局部变量。 

==**全局变量：**==

1. 在函数和类定义之外声明的变量。作用域为定义的模块，从定义位置开始直到模块结束。

2. 全局变量降低了函数的通用性和可读性。应尽量避免全局变量的使用。

3. 全局变量一般做常量使用。

4. 函数内要改变全局变量的值，使用global声明一下

==**局部变量：**==

1. 在函数体中（包含形式参数）声明的变量。

2. 局部变量的引用比全局变量快，优先考虑使用。

如果局部变量和全局变量同名，则在**函数内隐藏全局变量，只使用同名的局部变量**

## 5.5 参数的传递

函数的参数传递本质上就是：从实参到形参的赋值操作。 Python中“一切皆对象”，所有的赋值操作都是“引用的赋值”。所以，Python中参数的传递都是“引用传递”，不是“值传递”。具体操作时分为两类：

1. 对“可变对象”进行“写操作”，直接作用于原对象本身。

2. 对“不可变对象”进行“写操作”，会产生一个新的“对象空间”，并用新的值填充这块空间。（起到其他语言的“值传递”效果，但不是“值传递”）

可变对象有：

​		字典、列表、集合、自定义的对象等

不可变对象有：

​		数字、字符串、元组、function等

### 5.5.1 传递可变对象的引用

传递参数是可变对象（例如：列表、字典、自定义的其他可变对象等），实际传递的还是对象的引用。在函数体中不创建新的对象拷贝，而是可以直接修改所传递的对象。

```python
b = [10,20]
def f2(m):
    print("m:",id(m))       #b和m是同一个对象
    m.append(30)    #由于m是可变对象，不创建对象拷贝，直接修改这个对象
f2(b)
print("b:",id(b))
print(b)
```

### 5.5.2 传递不可变对象的引用

传递参数是不可变对象（例如：int、float、字符串、元组、布尔值），实际传递的还是对象的引用。在”赋值操作”时，由于不可变对象无法修改，系统会新创建一个对象。

```python
a = 100
def f1(n):
    print("n:",id(n))        #传递进来的是a对象的地址
    n = n+200            #由于a是不可变对象，因此创建新的对象n
    print("n:",id(n))    #n已经变成了新的对象
    print(n)
f1(a)
print("a:",id(a))
```

执行结果：

n: 1663816464

n: 46608592

300

a: 1663816464

显然，通过id值我们可以看到n和a一开始是同一个对象。给n赋值后，n是新的对象。

### 5.5.3 浅拷贝和深拷贝

为了更深入的了解参数传递的底层原理，我们需要讲解一下“浅拷贝和深拷贝”。我们可以使用内置函数：copy(浅拷贝)、deepcopy(深拷贝)。

**浅拷贝：不拷贝子对象的内容，只是拷贝子对象的引用。**

**深拷贝：会连子对象的内存也全部拷贝一份，对子对象的修改不会影响源对象**

```python
#测试浅拷贝和深拷贝

import copy

def testCopy():
    '''测试浅拷贝'''
    a = [10, 20, [5, 6]]
    b = copy.copy(a)

    print("a", a)
    print("b", b)
    b.append(30)
    b[2].append(7)
    print("浅拷贝......")
    print("a", a)
    print("b", b)

def testDeepCopy():
    '''测试深拷贝'''
    a = [10, 20, [5, 6]]
    b = copy.deepcopy(a)

    print("a", a)
    print("b", b)
    b.append(30)
    b[2].append(7)
    print("深拷贝......")
    print("a", a)
    print("b", b)

testCopy()
print("*************")
testDeepCopy()

result:
a [10, 20, [5, 6]]
b [10, 20, [5, 6]]
浅拷贝......
a [10, 20, [5, 6, 7]]
b [10, 20, [5, 6, 7], 30]
*************
a [10, 20, [5, 6]]
b [10, 20, [5, 6]]
深拷贝......
a [10, 20, [5, 6]]
b [10, 20, [5, 6, 7], 30]
```

### 5.5.4 传递不可变对象包含的子对象是可变的情况

```python
#传递不可变对象时。不可变对象里面包含的子对象是可变的。则方法内修改了这个可变对象，源对象也发生了变化。

a = (10,20,[5,6])
print("a:",id(a))

def test01(m):
    print("m:",id(m))
    m[2][0] = 888
    print(m)
    print("m:",id(m))

test01(a)
print(a)

a: 41611632
m: 41611632
(10, 20, [888, 6])
m: 41611632
(10, 20, [888, 6])
```

## 5.6 参数的几种类型

### 5.6.1 位置参数

函数调用时，实参默认按位置顺序传递，需要个数和形参匹配。按位置传递的参数，称为：“位置参数”。

```python
def f1(a,b,c):
    print(a,b,c)

f1(2,3,4)
f1(2,3)     #报错，位置参数不匹配
```

### 5.6.2 默认值参数

我们可以为某些参数设置默认值，这样这些参数在传递时就是可选的。称为“默认值参数”。**默认值参数放到位置参数后面。**

```python
def f1(a,b,c=10,d=20):   #默认值参数必须位于普通位置参数后面
    print(a,b,c,d)

f1(8,9)
f1(8,9,19)
f1(8,9,19,29)
```

### 5.6.3 命名参数

我们也可以按照形参的名称传递参数，称为“命名参数”，也称“关键字参数”。

```python
def f1(a,b,c):
    print(a,b,c)

f1(8,9,19)          #位置参数
f1(c=10,a=20,b=30)  #命名参数
```

### 5.6.4 可变参数

可变参数指的是“可变数量的参数”。分两种情况：

1. **param（一个星号），将多个参数收集到一个“元组”对象中。**

2. **param（两个星号），将多个参数收集到一个“字典”对象中**。

```python
def f1(a,b,*c):
    print(a,b,c)
f1(8,9,19,20)

def f2(a,b,**c):
    print(a,b,c)
f2(8,9,name='gaoqi',age=18)

def  f3(a,b,*c,**d):
    print(a,b,c,d)
f3(8,9,20,30,name='gaoqi',age=18)

8 9 (19, 20)
8 9 {'name': 'gaoqi', 'age': 18}
8 9 (20, 30) {'name': 'gaoqi', 'age': 18}
```

### 5.6.5 强制命名参数

在带星号的“可变参数”后面增加新的参数，必须在调用的时候“强制命名参数”。

```python
def f1(*a,b,c):
    print(a,b,c)


#f1(2,3,4)   #会报错。由于a是可变参数，将2,3,4全部收集。造成b和c没有赋值。

f1(2,b=3,c=4) 
```

## 5.7 lambda表达式和匿名函数

lambda表达式可以用来声明匿名函数。lambda函数是一种简单的、在同一行中定义函数的方法。lambda函数实际生成了一个函数对象。

lambda表达式**只允许包含一个表达式**，不能包含复杂语句，该表达式的计算结果就是函数的返回值。

lambda表达式的基本语法如下：

​											lambda  arg1,arg2,arg3...  :  <表达式>

arg1/arg2/arg3为函数的参数。<表达式>相当于函数体。运算结果是：表达式的运算结果。

```python
f = lambda a,b,c:a+b+c
print(f)
print(f(2,3,4))

g = [lambda a:a*2,lambda b:b*3,lambda c:c*4]
print(g[0](6),g[1](7),g[2](8))

<function <lambda> at 0x0000000002BB8620>
9
12 21 32
```

## 5.8 eval()函数

　功能：将字符串str当成有效的表达式来求值并返回计算结果。

　语法： eval(source[, globals[, locals]]) -> value

　参数：

　　　source：一个Python表达式或函数compile()返回的代码对象

　　　globals：可选。必须是dictionary

　　　locals：可选。任意映射对象

```python
#测试eval()函数

s = "print('abcde')"
eval(s)

a = 10
b = 20
c = eval("a+b")
print(c)

dict1 = dict(a=100,b=200)

d = eval("a+b",dict1)
print(d)

```

eval函数会将字符串当做语句来执行，因此会被注入安全隐患。比如：字符串中含有删除文件的语句。那就麻烦大了。因此，使用时候，要慎重！！

## 5.9 递归函数

递归函数指的是：自己调用自己的函数，在函数体内部直接或间接的自己调用自己。递归类似于大家中学数学学习过的“数学归纳法”。 每个递归函数必须包含两个部分：

1. 终止条件
   	表示递归什么时候结束。一般用于返回值，不再调用自己。

2. 递归步骤
   	把第n步的值和第n-1步相关联。

递归函数由于会创建大量的函数对象、过量的消耗内存和运算能力。在处理大量数据时，谨慎使用。

## 5.10 嵌套函数(内部函数)

嵌套函数：

在函数内部定义的函数！

```python
def  f1():
    print('f1 running...')
    def f2():
        print('f2 running...')
    f2()

f1()
```

上面程序中，f2()就是定义在f1函数内部的函数。f2()的定义和调用都在f1()函数内部。

一般在什么情况下使用嵌套函数？

1. 封装 - 数据隐藏

   外部无法访问“嵌套函数”。

2. 贯彻 DRY(Don’t Repeat  Yourself) 原则

   嵌套函数，可以让我们在函数内部避免重复代码。

3. 闭包

   后面会详细讲解。

```python
def printChineseName(name,familyName):
    print("{0} {1}".format(familyName,name))

def printEnglishName(name,familyName):
    print("{0} {1}".format(name, familyName))
    
#使用1个函数代替上面的两个函数
def printName(isChinese,name,familyName):
    def inner_print(a,b):
        print("{0} {1}".format(a,b))

    if isChinese:
        inner_print(familyName,name)
    else:
        inner_print(name,familyName)

printName(True,"小七","高")
printName(False,"George","Bush")

```

## 5.11 nonlocal关键字

nonlocal	用来声明外层的局部变量。

global		用来声明全局变量。

```python
#测试nonlocal、global关键字的用法
a = 100

def outer():
    b = 10
    def inner():
        nonlocal  b         #声明外部函数的局部变量
        print("inner b:",b)
        b = 20
        global a            #声明全局变量
        a = 1000
    inner()
    print("outer b:",b)

outer()
print("a：",a)
```

## 5.12 LEGB规则

Python在查找“名称”时，是按照LEGB规则查找的：

​            **Local-->Enclosed-->Global-->Built in**  

Local   指的就是函数或者类的方法内部

Enclosed  指的是嵌套函数（一个函数包裹另一个函数，闭包）

Global   指的是模块中的全局变量

Built in  指的是Python为自己保留的特殊名称。

如果某个name映射在局部(local)命名空间中没有找到，接下来就会在闭包作用域(enclosed)进行搜索，如果闭包作用域也没有找到，Python就会到全局(global)命名空间中进行查找，最后会在内建(built-in)命名空间搜索 （如果一个名称在所有命名空间中都没有找到，就会产生一个NameError）。

```python
#测试LEGB

str = "global"
def outer():
    str = "outer"

    def inner():
        str = "inner"
        print(str)

    inner()

outer()
```

# 六、面向对象初步

> **面向对象（Object oriented Programming，OOP）**编程的思想主要是针对大型软件设计而来的。面向对象编程使程序的扩展性更强、可读性更好，使的编程可以像搭积木一样简单。

面向对象编程将数据和操作数据相关的方法封装到对象中，组织代码和数据的方式更加接近人的思维，从而大大提高了编程的效率。

Python完全采用了面向对象的思想，是真正面向对象的编程语言，完全支持面向对象的基本功能，例如：继承、多态、封装等。

Python中，一切皆对象。我们在前面学习的数据类型、函数等，都是对象。

注：Python支持面向过程、面向对象、函数式编程等多种编程范式。

## 6.1 面向对象和面向过程区别

**面向过程(Procedure Oriented)思维**

> 面向过程编程更加关注的是“程序的逻辑流程”，是一种“执行者”思维，适合编写小规模的程序。

面向过程思想思考问题时，我们首先思考“怎么按步骤实现？”并将步骤对应成方法，一步一步，最终完成。 这个适合简单任务，不需要过多协作的情况下。比如，如何开车？我们很容易就列出实现步骤：

1. 发动车	2. 挂挡		3.踩油门		4. 走你

面向过程适合简单、不需要协作的事务。 但是当我们思考比较复杂的问题，比如“如何造车？”，就会发现列出1 2 3 4 这样的步骤，是不可能的。那是因为，造车太复杂，需要很多协作才能完成。此时面向对象思想就应运而生了。

**面向对象(Object Oriented)思维**

> 面向对象更加关注的是“软件中对象之间的关系”，是一种“设计者”思维，适合编写大规模的程序。

面向对象(Object)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物？” 比如思考造车，我们就会先思考“车怎么设计？”，而不是“怎么按步骤造车的问题”。这就是思维方式的转变。

面向对象方式思考造车，发现车由如下对象组成：

1. 轮胎

2. 发动机

3. 车壳

4. 座椅

5. 挡风玻璃

为了便于协作，我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤；这样，发现大家可以同时进行车的制造，最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开面向过程思想！

因此，面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作（就是一个个方法），仍然需要面向过程的思路去处理。

我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程！

**面向对象思考方式**

遇到复杂问题，先从问题中找名词（面向过程更多的是找动词），然后确立这些名词哪些可以作为类，再根据问题需求确定的类的属性和方法，确定类之间的关系。

**面向对象和面向过程的总结**

- 都是解决问题的思维方式，都是代码组织的方式。
- 解决简单问题可以使用面向过程
- 解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。

## 6.2 对象的进化

> 随着编程面临的问题越来越复杂，编程语言本身也在进化，从主要处理简单数据开始，随着数据变多进化“数组”； 数据类型变复杂，进化出了“结构体”； 处理数据的方式和逻辑变复杂，进化出了“对象”

1. 简单数据

   像30,40，50.4等这些数字，可以看做是简单数据。最初的计算机编程，都是像这样的数字。

2. 数组

   将同类型的数据放到一起。比如：整数数组[20,30,40]，浮点数数组[10.2, 11.3, 12.4]，字符串数组：[“aa”,”bb”,”cc”]

3. 结构体

   将不同类型的数据放到一起，是C语言中的数据结构。比如：

   ```C
   struct resume{
     int age;
     char name[10];
     double salary;
   };
   ```

4. 对象

   将不同类型的数据、方法（即函数）放到一起，就是对象。比如：

   ```python
   class Student:
       company = "SXT"     #类属性
       count = 0           #类属性
       def __init__(self,name,score):
           self.name = name         #实例属性
           self.score = score
           Student.count = Student.count+1
       def say_score(self):           #实例方法
           print("我的公司是：",Student.company)
           print(self.name,'的分数是：',self.score)
   ```

我们前学习的数字也是对象。比如：整数9，就是一个包含了加法、乘法等方法的对象。

## 6.3 类的定义

> 我们把对象比作一个“饼干”，类就是制造这个饼干的“模具”。

![img](E:\Typora_files\Python_node\Python.images\wps1-16563837790731.png)![img](E:\Typora_files\Python_node\Python.images\wps2.png)					![img](E:\Typora_files\Python_node\Python.images\wps3.png)

> 我们通过类定义数据类型的属性（数据）和方法（行为）,也就是说，“类将行为和状态打包在一起”。

![img](E:\Typora_files\Python_node\Python.images\wps4-16563837790742.jpg)  

对象是类的具体实体，一般称为“类的实例”。类看做“饼干模具”，对象就是根据这个“模具”制造出的“饼干”。

> 从一个类创建对象时，每个对象会共享这个类的行为（类中定义的方法），但会有自己的属性值（不共享状态）。更具体一点：“方法代码是共享的，属性数据不共享”。

![img](E:\Typora_files\Python_node\Python.images\wps5-16563837790743.jpg) 

> Python中，“一切皆对象”。类也称为“类对象”，类的实例也称为“实例对象”。

定义类的语法格式如下：

```python
class  类名：
	类体
```

要点如下：

1. 类名必须符合“标识符”的规则；一般规定，首字母大写，多个单词使用“驼峰原则”。

2. 类体中我们可以定义属性和方法。

3. 属性用来描述数据，方法(即函数)用来描述这些数据相关的操作。

 ### 6.3.1 一个典型的类定义

```python
class Student:
    def __init__(self,name,score):    #构造方法第一个参数必须为self
        self.name = name         #实例属性
        self.score = score

    def say_score(self):           #实例方法
        print(self.name,'的分数是：',self.score)

s1 = Student('张三',80)           #s1是实例对象，自动调用__init__()方法
s1.say_score()
```

## 6.4 __ init __ 构造方法和 __ new__方法

类是抽象的，也称之为“对象的模板”。我们需要通过类这个模板，创建类的实例对象，然后才能使用类定义的功能。

> 我们前面说过一个Python对象包含三个部分：id（identity识别码）、type（对象类型）、value（对象的值）。

现在，我们可以更进一步的说，一个Python对象包含如下部分： 

1. id（identity识别码）				

2. type（对象类型）					

3. value（对象的值）					

   (1) 属性（attribute）					

   (2) 方法（method）					

创建对象，我们需要定义构造函数__ init __()方法。构造方法用于执行“**实例对象的初始化工作**”，即对象创建后，初始化当前对象的相关属性，无返回值。

**__ init__()的要点如下：**

1. 名称固定，必须为：__ init__()

2. 第一个参数固定，必须为：self。  self指的就是刚刚创建好的实例对象。

3. 构造函数通常用来初始化实例对象的实例属性，如下代码就是初始化实例属性：name和score。

   ```python
   def __init__(self,name,score):    
       self.name = name     #实例属性    
       self.score = score 
   ```

4. 通过“类名(参数列表)”来调用构造函数。调用后，将创建好的对象返回给相应的变量。 比如：s1 = Student('张三', 80) 

5. __ init__()方法：初始化创建好的对象，初始化指的是：“给实例属性赋值”

6. __ new__()方法: 用于创建对象，但我们一般无需重定义该方法。

7. 如果我们不定义__ init __ 方法，系统会提供一个默认的__ init__ 方法。如果我们定义了带参的 __ init __ 方法，系统不创建默认的 __ init __方法。

> Python中的self相当于C++中的self指针，JAVA和C#中的this关键字。Python中，self必须为构造函数的第一个参数，名字可以任意修改。但一般遵守惯例，都叫做self。

## 6.5 实例属性和实例方法

### 6.5.1  实例属性

实例属性是从属于实例对象的属性，也称为“实例变量”。他的使用有如下几个要点：

1. 实例属性一般在__ init__()方法中通过如下代码定义：
   	self.实例属性名 = 初始值

2. 在本类的其他实例方法中，也是通过self进行访问：
   	self.实例属性名

3. 创建实例对象后，通过实例对象访问：

   obj01 = 类名()    #创建对象，调用__ init__()初始化属性

   obj01.实例属性名 = 值   #可以给已有属性赋值，也可以新加属性  

 

### 6.5.2 实例方法

实例方法是从属于实例对象的方法。实例方法的定义格式如下：

​	def  方法名(self [, 形参列表])：

​		函数体

方法的调用格式如下：

​	对象.方法名([实参列表])

要点：

1. 定义实例方法时，第一个参数必须为self。和前面一样，self指当前的实例对象。

2. 调用实例方法时，不需要也不能给self传参。self由解释器自动传参。

**函数和方法的区别**

1. 都是用来完成一个功能的语句块，本质一样。

2. 方法调用时，通过对象来调用。方法从属于特定实例对象，普通函数没有这个特点。

3. 直观上看，方法定义时需要传递self，函数不需要。

**实例对象的方法调用本质：**

 ![image-20220628121825832](E:\Typora_files\Python_node\Python.images\image-20220628121825832.png)

**其他操作：**

1. dir(obj)可以获得对象的所有属性、方法

2. obj.__ dict__  对象的属性字典

3. pass 空语句
4. isinstance（对象,类型）  判断“对象”是不是“指定类型”

## 6.6 类对象、类属性、类方法、静态方法

### 6.6.1 类对象

> 我们在前面讲的类定义格式中，“class  类名：”。实际上，当解释器执行class语句时，就会创建一个类对象。

```python
class Student:
    pass    #空语句

print(type(Student))
print(id(Student))

Stu2 = Student
s1 = Stu2()
print(s1)


<class 'type'>
51686328
<__main__.Student object at 0x0000000002B5FDD8>
```

我们可以看到实际上生成了一个变量名就是类名“Student”的对象。我们通过赋值给新变量Stu2，也能实现相关的调用。说明，确实创建了“类对象”。

> pass为空语句。就是表示什么都不做，只是作为一个占位符存在。当你写代码时，遇到暂时不知道往方法或者类中加入什么时，可以先用pass占位，后期再补上。

### 6.6.2 类属性

类属性是从属于“类对象”的属性，也称为“类变量”。由于，类属性从属于类对象，可以被所有实例对象共享。 

> 类属性类似于Java、C、C++中的静态变量

类属性的定义方式：

​	class  类名：

​			类变量名= 初始值 

在类中或者类的外面，我们可以通过：“类名.类变量名”来读写。

```python
class Student:
    company = "SXT"     #类属性   所有类共享
    count = 0           #类属性

    def __init__(self,name,score):
        self.name = name         #实例属性
        self.score = score
        Student.count = Student.count+1

    def say_score(self):           #实例方法
        print("我的公司是：",Student.company)
        print(self.name,'的分数是：',self.score)

s1 = Student('张三',80)           #s1是实例对象，自动调用__init__()方法
s1.say_score()
print('一共创建{0}个Student对象'.format(Student.count))
```

<img src="E:\Typora_files\Python_node\Python.images\image-20220628143554657.png" alt="image-20220628143554657" style="zoom:67%;" />



> Python中全部都是对象，包括类的定义也是对象，其类型为type类型，每种类对象只能有一个

### 6.6.3 类方法

类方法是从属于“类对象”的方法。类方法通过装饰器@classmethod来定义，格式如下：

​		@classmethod

​		def  类方法名(cls  [，形参列表]) ：

​				函数体

要点如下：

1. @classmethod必须位于方法上面一行

2. 第一个cls必须有；cls指的就是“类对象”本身；

3. 调用类方法格式：“类名.类方法名(参数列表)”。 参数列表中，不需要也不能给cls传值。

4. 类方法中访问实例属性和实例方法会导致错误

5. 子类继承父类方法时，传入cls是子类对象，而非父类对象

```python
class Student:

    company = "SXT"     #类属性
    @classmethod
    def printCompany(cls):
        print(cls.company)
    
Student.printCompany()
```

### 6.6.4 静态方法

Python中允许定义与“类对象”无关的方法，称为“静态方法”。

“静态方法”和在模块中定义普通函数没有区别，只不过“静态方法”放到了“类的名字空间里面”，需要通过“类调用”。

静态方法通过装饰器@staticmethod来定义，格式如下：

​		@staticmethod

​		def  静态方法名([形参列表]) ：

​				函数体

要点如下：

1. @staticmethod必须位于方法上面一行

2. 调用静态方法格式：“类名.静态方法名(参数列表)”。

3. 静态方法中访问实例属性和实例方法会导致错误

```python
class Student:
    company = "SXT"  # 类属性

    @staticmethod
    def add(a, b):  # 静态方法
        print("{0}+{1}={2}".format(a,b,(a+b)))
        return a+b

Student.add(20,30)
```

## 6.7 __ del __方法(析构函数)和垃圾回收机制

__ del __方法称为“析构方法”，用于实现对象被销毁时所需的操作。比如：释放对象占用的资源，例如：打开的文件资源、网络连接等。

> Python实现自动的垃圾回收，当对象没有被引用时（引用计数为0），由垃圾回收器调用__ del__方法。
>
> 我们也可以通过del语句删除对象，从而保证调用__ del__方法。
>
> 系统会自动提供__ del__方法，一般不需要自定义析构方法。

```python
#析构函数
class Person:

    def __del__(self):
        print("销毁对象：{0}".format(self))

p1 = Person()
p2 = Person()
del p2
print("程序结束")
```

## 6.8 __ call__方法和可调用对象

定义了__ call__方法的对象，称为“可调用对象”，即该对象可以像函数一样被调用。

```python
#测试__call__，可调用对象

class SalaryAccount:
   '''工资计算类'''

   def __call__(self, salary):
       yearSalary = salary*12
       daySalary = salary//30
       hourSalary = daySalary//8
       return dict(monthSalary=salary,yearSalary=yearSalary,daySalary=daySalary,hourSalary=hourSalary)

s = SalaryAccount()
print(s(5000))      #可以像调用函数一样调用对象的__call__方法
```

## 6.9 方法没有重载

在其他语言中，可以定义多个重名的方法，只要保证方法签名唯一即可。方法签名包含3个部分：方法名、参数数量、参数类型。

Python中，方法的的参数没有声明类型（调用时确定参数的类型），参数的数量也可以由可变参数控制。因此，Python中是没有方法的重载的。定义一个方法即可有多种调用方式，相当于实现了其他语言中的方法的重载。

> 如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。

建议：不要使用重名的方法！Python中方法没有重载。

```python
#Python中没有方法的重载。定义多个同名方法，只有最后一个有效
class Person:

    def say_hi(self):
        print("hello")

    def say_hi(self,name):
        print("{0},hello".format(name))
p1 = Person()
#p1.say_hi()       #不带参，报错：TypeError: say_hi() missing 1 required positional argument: 'name'
p1.say_hi("高淇")
```

## 6.10 方法的动态性

> Python是动态语言，我们可以动态的为类添加新的方法，或者动态的修改类的已有的方法。

```python
#测试方法的动态性
class Person:
    def work(self):
        print("努力上班！")

def play_game(self):
    print("{0}玩游戏".format(self))

def work2(s):
    print("好好工作，努力上班！")


Person.play = play_game
Person.work = work2
p = Person()
p.play()
p.work()
```

我们可以看到，Person动态的新增了play_game方法，以及用work2替换了work方法。

## 6.11 私有属性和私有方法(实现封装)

Python对于类的成员没有严格的访问控制限制，这与其他面向对象语言有区别。关于私有属性和私有方法，有如下要点：

1. 通常我们约定，两个下划线开头的属性是私有的(private)。其他为公共的(public)。

2. 类内部可以访问私有属性(方法)

3. 类外部不能直接访问私有属性(方法)

4. 类外部可以通过“_类名__私有属性(方法)名”访问私有属性(方法)

> 方法本质上也是属性！只不过是可以通过()执行而已。所以，此处讲的私有属性和公有属性，也同时讲解了私有方法和公有方法的用法。如下测试中，同时也包含了私有方法和公有方法的例子。

```python
#测试私有属性、私有方法
class Employee:
    __company = "百战程序员"      #私有类属性.   通过dir可以查到_Employee__company

    def __init__(self,name,age):
        self.name = name
        self.__age = age         #私有实例属性

    def say_company(self):
        print("我的公司是：",Employee.__company)          #类内部可以直接访问私有属性
        print(self.name,"的年龄是：",self.__age)
        self.__work()

    def __work(self):         #私有实例方法   通过dir可以查到_Employee__work
        print("工作！好好工作，好好赚钱，娶个媳妇！")

p1 = Employee("高淇",32)
print(p1.name)
print(dir(p1))              #
p1.say_company()
print(p1._Employee__age)     #通过这种方式可以直接访问到私有属性  。通过dir可以查到属性：_Employee__age
#print(p1.__age)           #直接访问私有属性，报错
#p1.__sleep()             #直接访问私有方法，报错

执行结果：
高淇
['_Person__age', '_Person__leg_num', '_Person__sleep', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'say_age']
腿的数目： 2
高淇 的年龄是： 18
睡觉
18
```

从打印的Person对象所有属性我们可以看出。私有属性 __ age在实际存储时是按照 _Person __ age这个属性来存储的。这也就是为什么我们不能直接使用 __ age而可以使用 _Person __age的根本原因。

## 6.12 @property装饰器

@property可以将一个方法的调用方式变成“属性调用”。下面是一个简单的示例，让大家体会一下这种转变：

```python
#简单测试@property
class Employee:

    @property
    def salary(self):
        return 30000;

emp1 = Employee()
print(emp1.salary)              #打印30000
print(type(emp1.salary))        #打印<class 'int'>
#emp1.salary()                   #报错：TypeError: 'int' object is not callable

#emp1.salary =1000               #@property修饰的属性，如果没有加setter方法，则为只读属性。此处修改报错：AttributeError: can't set attribute
```

@property主要用于帮助我们处理属性的读操作、写操作。对于某一个属性，我们可以直接通过：

emp1.salary = 30000  

如上的操作读操作、写操作。但是，这种做法不安全。比如，我需要限制薪水必须为1-10000的数字。这时候，我们就需要通过getter、setter方法来处理。

```python
#测试@property
class Employee:

    def __init__(self,name,salary):
        self.name = name
        self.__salary = salary

    @property               #相当于salary属性的getter方法
    def salary(self):
        print("月薪为{0},年薪为{1}".format(self.__salary,(12*self.__salary)))
        return self.__salary;

    @salary.setter           #属性.setter装饰器
    def salary(self,salary):    #相当于salary属性的setter方法
        if(0<salary<1000000):
            self.__salary = salary
        else:
            print("薪水录入错误！只能在0-1000000之间")


emp1 = Employee("高淇",100)
print(emp1.salary)

emp1.salary = -200
运行结果：
月薪为100,年薪为1200
100
月薪为100,年薪为1200
100
薪水录入错误！只能在0-1000000之间
```

## 6.13 属性和方法命名总结

- _xxx：保护成员，不能用“from module import * ”导入，只有类对象和子类对象能访问这些成员。
- __ xxx__：系统定义的特殊成员
- __ xxx： 类中的私有成员，只有类对象自己能访问，子类对象也不能访问。（但，在类外部可以通过“对象名. _类名__xxx”这种特殊方式访问。Python不存在严格意义的私有成员）

注：再次强调，方法和属性都遵循上面的规则。

## 6.14 类编码风格

1. 类名首字母大写，多个单词之间采用驼峰原则。

2. 实例名、模块名采用小写，多个单词之间采用下划线隔开。

3. 每个类，应紧跟“文档字符串”，说明这个类的作用。

4. 可以用空行组织代码，但不能滥用。在类中，使用一个空行隔开方法；模块中，使用两个空行隔开多个类。



# 七、面向对象进阶

## 7.1 面向对象三大特征介绍

> Python是面向对象的语言，也支持面向对象编程的三大特性：继承、封装（隐藏）、多态。 

**封装（隐藏）**

隐藏对象的属性和实现细节，只对外提供必要的方法。相当于将“细节封装起来”，只对外暴露“相关调用方法”。

通过前面学习的“私有属性、私有方法”的方式，实现“封装”。Python追求简洁的语法，没有严格的语法级别的“访问控制符”，更多的是依靠程序员自觉实现。

**继承**

继承可以让子类具有父类的特性，提高了代码的重用性。

从设计上是一种增量进化，原有父类设计不变的情况下，可以增加新的功能，或者改进已有的算法。

**多态**

多态是指同一个方法调用由于对象不同会产生不同的行为。生活中这样的例子比比皆是：同样是休息方法，人不同休息方法不同。张三休息是睡觉，李四休息是玩游戏，程序员休息是“敲几行代码”。

## 7.2 继承

> 继承是面向对象程序设计的重要特征，也是实现“代码复用”的重要手段。
>
> 如果一个新类继承自一个设计好的类，就直接具备了已有类的特征，就大大降低了工作难度。已有的类，我们称为“父类或者基类”，新的类，我们称为“子类或者派生类”。

<img src="E:\Typora_files\Python_node\Python.images\image-20220628180900824.png" alt="image-20220628180900824" style="zoom:67%;" />

### 7.2.1 语法格式

Python支持多重继承，一个子类可以继承多个父类。继承的语法格式如下：

​		class  子类类名(父类1[，父类2，...])：

​						类体 

如果在类定义中没有指定父类，则==**默认父类是object类**==。也就是说，object是所有类的父类，里面定义了一些所有类共有的默认实现，比如：__ new__()。

定义子类时，**必须在其构造函数中调用父类的构造函数**。调用格式如下：

**父类名.__ init__(self, 参数列表)**

```python
class Person:
    def __init__(self,name,age):
        self.name = name
        self.__age = age

    def say_age(self):
        print(self.name,"的年龄是：",self.__age)


class Student(Person):
    def __init__(self,name,age,score):
        self.score = score
        Person.__init__(self,name,age)  #构造函数中包含调用父类构造函数。根据需要，不是必须。 子类并不会自动调用父类的__init__()，我们必须显式的调用它。

s1 = Student("张三",15,85)
s1.say_age()
print(dir(s1))  #dir能够得到对象所有的属性

运行结果：
张三 的年龄是： 15
['_Person__age', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'say_age', 'score']
```

> 可以看到Student中也有age属性，但是无法直接使用，使用方法为_Person__age

### 7.2.2 类成员的继承和重写

1. 成员继承：==子类继承了父类除构造方法之外的所有成员。==

2. 方法重写：==子类可以重新定义父类中的方法，这样就会覆盖父类的方法，也称为“重写”==

```python
class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age

    def say_age(self):
        print(self.name,"的年龄是：",self.age)

    def say_name(self):
       print("我是",self.name)

class Student(Person):

    def __init__(self,name,age,score):
        self.score = score
        Person.__init__(self,name,age)  #构造函数中包含调用父类构造函数

    def say_score(self):
        print(self.name,"的分数是：",self.score)

    def say_name(self):      #重写父类的方法
        print("报告老师，我是",self.name)

s1 = Student("张三",15,85)
s1.say_score()
s1.say_name()
s1.say_age()
```

### 7.2.3 查看类的继承层次结构

通过类的方法mro()或者类的属性__ mro__可以输出这个类的继承层次结构。

```python
class A:pass
class B(A):pass
class C(B):pass

print(C.mro())
```

<img src="E:\Typora_files\Python_node\Python.images\image-20220628181659655.png" alt="image-20220628181659655" style="zoom:50%;" />

## 7.3 object根类

> object类是所有类的父类，因此所有的类都有object类的属性和方法。我们显然有必要深入研究一下object类的结构。对于我们继续深入学习Python很有好处。

### 7.3.1 dir()查看对象属性

> 为了深入学习对象，我们先学习内置函数dir()，他可以让我们方便的看到指定对象所有的属性。

```python
class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age

    def say_age(self):
        print(self.name,"的年龄是：",self.age)

obj = object()
print(dir(obj))

s2 = Person("高淇",18)
print(dir(s2))

执行结果：
['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']

['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'name', 'say_age']
```

从上面我们可以发现这样几个要点：

1. Person对象增加了六个属性：__ dict __ ,__ module __ ,__ weakref __ ,age,name,say_age

2. object的所有属性，Person类作为object的子类，显然包含了所有的属性。

3. 我们打印age、name、say_age，发现say_age虽然是方法，实际上也是属性。只不过，这个属性的类型是“method”而已。
   	age <class 'int'>

      name <class 'str'>

      say_age <class 'method'>

### 7.3.2 重写__str__()方法

object有一个__ str __ ()方法，用于返回一个对于“对象的描述”，对应于内置函数str()经常用于print()方法，帮助我们查看对象的信息。__ str __()可以重写。

```python
class Person:
    def __init__(self,name,age):
        self.name = name
        self.__age = age

    def __str__(self):
        '''将对象转化成一个字符串，一般用于print方法'''
        return "名字是：{0},年龄是{1}".format(self.name,self.__age)

p = Person("高淇",18)
print(p)
```

## 7.4 多重继承

Python支持多重继承，一个子类可以有多个“直接父类”。这样，就具备了“多个父类”的特点。但是由于，这样会被“类的整体层次”搞的异常复杂，尽量避免使用。

```python
#多重继承
class A:
    def aa(self):
        print("aa")

class B:
    def bb(self):
        print("bb")

class C(B,A):
    def cc(self):
        print("cc")

c = C()
c.cc()
c.bb()
c.aa()
```

### 7.4.1 MRO()

Python支持多继承，如果父类中有相同名字的方法，在子类没有指定父类名时，解释器将==“从左向右”==按顺序搜索。

MRO（Method Resolution Order）：方法解析顺序。 我们可以通过mro()方法获得“类的层次结构”，方法解析顺序也是按照这个“类的层次结构”寻找的。

```python
class A:
    def aa(self):
        print("aa")

    def say(self):
        print("say AAA!")

class B:
    def bb(self):
        print("bb")

    def say(self):
        print("say BBB!")
class C(B,A):
    def cc(self):
        print("cc")

c = C()
print(C.mro())          #打印类的层次结构
c.say()                 #解释器寻找方法是“从左到右”的方式寻找，此时会执行B类中的say()
```

## 7.5 Super()获得父类定义

在子类中，如果想要获得父类的方法时，我们可以通过super()来做。==super()代表父类的定义，不是父类对象。==

```python
# 测试super()

class A:
    def say(self):
        print("say AAA")


class B:
    def say(self):
        print("say BBB")


class C(B, A):
    def say(self):
        super().say()
        print("say CCC")


c = C()
c.say()
```

> 多重继承时，super()调用的方法与继承声明的顺序有关

## 7.6 多态

> 多态（polymorphism）是指同一个方法调用由于对象不同可能会产生不同的行为。在现实生活中，我们有很多例子。比如：同样是调用人的休息方法，张三的休息是睡觉，李四的休息是玩游戏，高淇老师是敲代码。同样是吃饭的方法，中国人用筷子吃饭，英国人用刀叉吃饭，印度人用手吃饭。

关于多态要注意以下2点：

1. ==多态是方法的多态==，属性没有多态。
2. 多态的存在有2个必要条件：==继承、方法重写==。

```python
#多态

class Animal:
    def shout(self):
        print("动物叫了一声")

        
class Dog(Animal):
    def shout(self):
        print("小狗，汪汪汪")


class Cat(Animal):

    def shout(self):
        print("小猫，喵喵喵")


def animalShout(a):
    if isinstance(a,Animal):
        a.shout()    #传入的对象不同，shout方法对应的实际行为也不同。


animalShout(Dog())
animalShout(Cat())
运行结果：
小狗，汪汪汪
小猫，喵喵喵
```

## 7.7 特殊方法和运算符重载

Python的运算符实际上是通过调用对象的特殊方法实现的。比如：

```python
a = 20
b = 30
c = a+b
d = a.__add__(b)
print("c=",c)
print("d=",d)
```

运算结果：

c= 50

d= 50

> 常见的特殊方法统计如下：

| 方法              | 说明       | 例子                   |
| ----------------- | ---------- | ---------------------- |
| __ init__         | 构造方法   | 对象创建：p = Person() |
| __ del__          | 析构方法   | 对象回收               |
| __ repr__,__str__ | 打印，转换 | print(a)               |
| __ call__         | 函数调用   | a()                    |
| __ getattr__      | 点号运算   | a.xxx                  |
| __ setattr__      | 属性赋值   | a.xxx = value          |
| __ getitem__      | 索引运算   | a[key]                 |
| __ setitem__      | 索引赋值   | a[key]=value           |
| __ len__          | 长度       | len(a)                 |

> 每个运算符实际上都对应了相应的方法，统计如下：

| 运算符   | 特殊方法                                            | 说明                               |
| -------- | --------------------------------------------------- | ---------------------------------- |
| 运算符+  | __ add__                                            | 加法                               |
| 运算符-  | __ sub__                                            | 减法                               |
| <,<=,==  | __ lt __ ,__ le __ ，__ eq__                        | 比较运算符                         |
| >,>=,!=  | __ gt __ ,__ ge __ , __ ne__                        |                                    |
| \|,^,&   | __ or __ , __ xor  __ ,__ and__                     | 或、异或、与                       |
| <<,>>    | __ lshift__ , __rshift__                            | 左移、右移                         |
| *,/,%,// | __ mul__ , __ truediv __ , __ mod __ ,__ floordiv__ | 乘、浮点除、模运算（取余）、整数除 |
| **       | __ pow __                                           | 指数运算                           |

> 我们可以重写上面的特殊方法，即实现了“运算符的重载”。

```python
#测试运算符的重载
class Person:
    def __init__(self,name):
        self.name = name

    def __add__(self, other):
        if isinstance(other,Person):
            return "{0}--{1}".format(self.name,other.name)
        else:
            return "不是同类对象，不能相加"

    def __mul__(self, other):
        if isinstance(other,int):
            return  self.name*other
        else:
            return "不是同类对象，不能相乘"

p1 = Person("高淇")
p2 = Person("高希希")

x = p1 + p2
print(x)

print(p1*3)
```

## 7.7 特殊属性

Python对象中包含了很多双下划线开始和结束的属性，这些是特殊属性，有特殊用法。这里我们列出常见的特殊属性：

| 特殊方法                | 含义                   |
| ----------------------- | ---------------------- |
| obj.__ dict__           | 对象的属性字典         |
| obj.__ class__          | 对象所属的类           |
| class.__ bases__        | 类的基类元组（多继承） |
| class.__ base__         | 类的基类               |
| class.__ mro__          | 类层次结构             |
| class.__ subclasses__() | 子类列表               |

 ```python
#测试特殊属性
class A:
    pass

class B:
    pass

class C(B,A):

    def __init__(self,nn):
        self.nn = nn

    def cc(self):
        print("cc")

c = C(3)

print(dir(c))
print(c.__dict__)
print(c.__class__)
print(C.__bases__)
print(C.mro())
print(A.__subclasses__())

运行结果：
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'cc', 'nn']
{'nn': 3}
<class '__main__.C'>
(<class '__main__.B'>, <class '__main__.A'>)
[<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>]
[<class '__main__.C'>]
 ```

## 7.8 对象的浅拷贝和深拷贝

### 7.8.1 变量的赋值操作

> 只是形成两个变量，实际还是指向同一个对象。

### 7.8.2 浅拷贝

> Python拷贝一般都是浅拷贝。拷贝时，对象包含的子对象内容不拷贝。因此，源对象和拷贝对象会引用同一个子对象。

### 7.8.3 深拷贝

> 使用copy模块的deepcopy函数，递归拷贝对象中包含的子对象。源对象和拷贝对象所有的子对象也不同。

 ```python
#测试对象的引用赋值、浅拷贝、深拷贝
import copy
class MobilePhone:
    def __init__(self,cpu,screen):
        self.cpu = cpu
        self.screen = screen
class CPU:
    def calculate(self):
        print("计算，算个12345")
        print("CPU对象:",self)
class Screen:
    def show(self):
        print("显示一个好看的画面，亮瞎你的钛合金大眼")
        print("屏幕对象：",self)
c = CPU()
s = Screen()
m = MobilePhone(c,s)
m.cpu.calculate()
n = m               #两个变量，但是指向了同一个对象
print(m,n)
m2 = copy.copy(m)   #m2是新拷贝的另一个手机对象
print(m,m2)
m.cpu.calculate()
m2.cpu.calculate()   #m2和m拥有了一样的cpu对象和screen对象
m3 = copy.deepcopy(m)
m3.cpu.calculate()      #m3和m拥有不一样的cpu对象和screen对象
 ```

## 7.9 组合

> “is-a”关系，我们可以使用“继承”。从而实现子类拥有的父类的方法和属性。“is-a”关系指的是类似这样的关系：狗是动物，dog is animal。狗类就应该继承动物类。
>
> “has-a”关系，我们可以使用“组合”，也能实现一个类拥有另一个类的方法和属性。”has-a”关系指的是这样的关系：手机拥有CPU。 MobilePhone has a CPU。

```python
#组合测试
class MobilePhone:
    def __init__(self,cpu,screen):
        self.cpu = cpu
        self.screen = screen

class CPU:

    def calculate(self):
        print("计算，算个12345")

class Screen:
    def show(self):
        print("显示一个好看的画面，亮瞎你的钛合金大眼")

c = CPU()
s = Screen()
m = MobilePhone(c,s)
m.cpu.calculate()       #通过组合，我们也能调用cpu对象的方法。相当于手机对象间接拥有了“cpu的方法”
m.screen.show()
```

## 7.10 设计模式_工厂模式实现

> 设计模式是面向对象语言特有的内容，是我们在面临某一类问题时候固定的做法，设计模式有很多种，比较流行的是：GOF（Goup Of Four）23种设计模式。当然，我们没有必要全部学习，学习几个常用的即可。
>
> 对于初学者，我们学习两个最常用的模式：工厂模式和单例模式。
>
> 工厂模式实现了创建者和调用者的分离，使用专门的工厂类将选择实现类、创建对象进行统一的管理和控制。

 ```python
#工厂模式
class CarFactory:
    def createCar(self,brand):
        if brand == "奔驰":
            return Benz()
        elif brand == "宝马":
            return BMW()
        elif brand == '比亚迪':
            return BYD()
        else:
            return "未知品牌，无法创建"

class Benz:
    pass

class BMW:
    pass

class BYD:
    pass

factory = CarFactory()
c1 = factory.createCar("奔驰")
c2 = factory.createCar("宝马")
print(c1)
print(c2)
 ```

## 7.11 设计模式_单例模式实现

> 单例模式（Singleton Pattern）的核心作用是确保一个类只有一个实例，并且提供一个访问该实例的全局访问点。
>
> 单例模式只生成一个实例对象，减少了对系统资源的开销。当一个对象的产生需要比较多的资源，如读取配置文件、产生其他依赖对象时，可以产生一个“单例对象”，然后永久驻留内存中，从而极大的降低开销。
>
> 单例模式有多种实现的方式，我们这里推荐重写__ new__()的方法。

 ```python
#单例模式
class MySingleton:
    __obj = None
    __init_flag = True

    def __new__(cls, *args, **kwargs):
        if cls.__obj == None:
            cls.__obj = object.__new__(cls)

        return cls.__obj

    def __init__(self,name):
        if MySingleton.__init_flag:
            print("init....")
            self.name = name
            MySingleton.__init_flag = False

a = MySingleton("aa")
print(a)
b = MySingleton("bb")
print(b)
 ```

**[Python官方推荐代码风格](https://www.python.org/dev/peps/pep-0008/)**



# Assert 语句

## 1. 基础语法

```python
assert boolean_expression
```

这里我们期望上述 boolean_expression 取值为 True，而 assert 关键字的作用是帮助我们再次检查它是否为 True

## 2. 基础用法

```python
price = get_price()
assert price > 0
```

这里可以使用 assert 断言 price 是否是一个合理的值（因为价格不能为负），如果 price 为负数则会发生断言错误并停止运行程序。

```python
assert boolean_expression, message
```

进阶用法，可以自定义错误消息

e.g.

```python
price = -1
assert price > 0, "price must not be negative"
```

```python
Traceback (most recent call last):
  File "/your/path/a.py", line 3, in <module>
    assert price > 0, "price must not be negative"
AssertionError: price must not be negative
```



# with...as和try except finally语句

with…as 是 python 的控制流语句，像 if ，while一样。with…as 语句是简化版的 try except finally语句。

先理解一下 try…except…finally 语句是干啥的。实际上 try…except 语句和 try…finally 语句是两种语句，用于不同的场景。但是当二者结合在一起时，可以“实现稳定性和灵活性更好的设计”。

## 1. try…except 语句

用于处理程序执行过程中的异常情况，比如语法错误、从未定义变量上取值等等，也就是一些python程序本身引发的异常、报错。比如你在python下面输入 1 / 0：

```python
>>> 1/0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
```

系统会给你一个 ZeroDivisionError 的报错。说白了就是为了防止一些报错影响你的程序继续运行，就用try语句把它们抓出来(捕获)。

**try…except 的标准格式：**

```python
try:  
    ## normal block  
except A:  
    ## exc A block  
except:  
    ## exc other block  
else:  
    ## noError block  
```

**程序执行流程是：**

```scss
–>执行normal block
–>发现有A错误，执行 exc A block(即处理异常)
–>结束

如果没有A错误呢？
–>执行normal block
–>发现B错误，开始寻找匹配B的异常处理方法，发现A，跳过，发现except others(即except:)，执行exc other block
–>结束

如果没有错误呢？
–>执行normal block
–>全程没有错误，跳入else 执行noError block
–>结束
```

Tips: 我们发现，一旦跳入了某条except语句，就会执行相应的异常处理方法(block)，执行完毕就会结束。不会再返回try的normal block继续执行了。

```python
try:
    a = 1 / 2 #a normal number/variable
    print(a)
    b = 1 / 0 # an abnormal number/variable
    print(b)
    c = 2 / 1 # a normal number/variable
    print(c)
except:
    print("Error")
```

结果是，先打出了一个0，又打出了一个Error。就是把ZeroDivisionError错误捕获了。

先执行 try 后面这一堆语句，由上至下：

- step1: a 正常，打印a. 于是打印出0.5 (python3.x以后都输出浮点数)
- step2: b, 不正常了，0 不能做除数，所以这是一个错误。直接跳到except报错去。于是打印了Error。
- step3: 其实没有step3，因为程序结束了。c是在错误发生之后的b语句后才出现，根本轮不到执行它。也就看不到打印出的c了

但这还不是 try/except 的所有用法

except后面还能跟表达式的!

所谓的表达式，就是错误的定义。也就是说，我们可以捕捉一些我们想要捕捉的异常。而不是什么异常都报出来。

**异常分为两类：**

- python标准异常
- 自定义异常

我们先抛开自定义异常(因为涉及到类的概念)，看看 except 都能捕捉到哪些 python 标准异常。请查看[菜鸟笔记](http://www.runoob.com/python/python-exceptions.html)

## 2. try…finallly 语句

用于无论执行过程中有没有异常，都要执行清场工作。

```python
try:  
    execution block  ##正常执行模块  
except A:  
    exc A block ##发生A错误时执行  
except B:  
    exc B block ##发生B错误时执行  
except:  
    other block ##发生除了A,B错误以外的其他错误时执行  
else:  
    if no exception, jump to here ## else是没有错误时执行的代码块 
finally:  
    final block  ##总是执行  
```

**tips:** 注意顺序不能乱，否则会有语法错误。如果用 else 就必须有 except，否则会有语法错误。

```python
try:
    a = 1 / 2
    print(a)
    print(m)  # 抛出 NameError异常, 此后的语句都不在执行
    b = 1 / 0
    print(b)
    c = 2 / 1
    print(c)
except NameError:
    print("Ops!!")  # 捕获到异常
except ZeroDivisionError:
    print("Wrong math!!")
except:
    print("Error")
else:
    print("No error! yeah!")
finally:  # 是否异常都执行该代码块
    print("Successfully!")
```

## 1. with 语句的原理

- 上下文管理协议（Context Management Protocol）：包含方法 \_\_enter\_\_() 和 \_\_exit\_\_()，支持该协议的对象要实现这两个方法。
- 上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了 \_\_enter\_\_() 和 \_\_exit\_\_() 方法。上下文管理器定义执行  with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with  语句调用上下文管理器，也可以通过直接调用其方法来使用。

说完上面两个概念，我们再从 with 语句的常用表达式入手，一段基本的 with 表达式，其结构是这样的：

```crystal
with context_expression [as target(s)]:
    ...
    with-body
    ...
```

其中 context_expression 可以是任意表达式；as target(s) 是可选的。

with 语句执行过程 。在语义上等价于:

```python
    context_manager = context_expression
    exit = type(context_manager).__exit__
    value = type(context_manager).__enter__(context_manager)
    exc = True   # True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理
    try:
        try:
            target = value  # 如果使用了 as 子句
            with-body     # 执行 with-body
        except:
            # 执行过程中有异常发生
            exc = False
            # 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常
            # 由外层代码对异常进行处理
            if not exit(context_manager, *sys.exc_info()):
                raise
    finally:
        # 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出
        # 或者忽略异常退出
        if exc:
            exit(context_manager, None, None, None)
        # 缺省返回 None，None 在布尔上下文中看做是 False
```

可以看到，with 和 try finally 有下面的等价流程：

```delphi
try:  
    执行 __enter__的内容  
    执行 with_block.  
finally:  
    执行 __exit__内容  
```

1. 执行 **context_expression** ，生成上下文管理器 **context_manager**
2. 调用上下文管理器的 **\_\_enter\_\_()** 方法；如果使用了 as 子句，则将**\_\_enter\_\_()** 方法的 **返回值** 赋值给 as 子句中的 target(s)
3. 执行语句体 with-body
4. 不管执行过程中是否发生了异常，执行上下文管理器的 **\_\_exit\_\_()** 方法， **\_\_exit\_\_()** 方法负责执行 "清理" 工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 **\_\_exit\_\_**(None, None, None) ；如果执行过程中出现异常，则使用 sys.exc\*info 得到的异常信息为参数调用* **\_\_exit\_\_**(exc_type, exc_value, exc_traceback)
5. 出现异常时，如果 **\_\_exit\_\_**(type, value, traceback) 返回 False，则会重新抛出异常，让 with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理

那么`__enter__`和`__exit__`是怎么用的方法呢？我们直接来看一个栗子好了。

**程序无错的例子:**

```python
class Sample(object):             # object类是所有类最终都会继承的类
    def __enter__(self):          # 类中函数第一个参数始终是self，表示创建的实例本身
        print("In __enter__()")
        return "Foo"
    def __exit__(self, type, value, trace):
        print("In __exit__()")
        
def get_sample():
    return Sample()

with get_sample() as sample:
    print("sample:", sample)
print(Sample)    # 这个表示类本身   <class '__main__.Sample'>

print(Sample())  # 这表示创建了一个匿名实例对象 <__main__.Sample object at 0x00000259369CF550>


'''
In __enter__()
sample: Foo
In __exit__()
<class '__main__.Sample'>
<__main__.Sample object at 0x00000226EC5AF550>
'''
```

**步骤分析:**
 –> 调用`get_sample()`函数，返回`Sample`类的实例;
 –> 执行`Sample`类中的`__enter__()`方法，打印`"In__enter_()"`字符串，并将字符串`“Foo”`赋值给as后面的sample变量;
 –> 执行`with-block`码块，即打印`"sample: %s"`字符串，结果为`"sample: Foo"`
 –> 执行`with-block`码块结束，返回`Sample`类，执行类方法`__exit__()`。因为在执行with-block码块时并没有错误返回，所以type,value,trace这三个arguments都没有值。直接打印`"In__exit__()"`

**程序有错的例子：**

```python
class Sample:
    def __enter__(self):
        return self

    def __exit__(self, type, value, trace):
        print("type:", type)
        print("value:", value)
        print("trace:", trace)

    def do_something(self):
        bar = 1 / 0
        return bar + 10

with Sample() as sample:
    sample.do_something()

'''
type: <class 'ZeroDivisionError'>
value: division by zero
trace: <traceback object at 0x0000019B73153848>
Traceback (most recent call last):
  File "F:/机器学习/生物信息学/Code/first/hir.py", line 16, in <module>
    sample.do_something()
  File "F:/机器学习/生物信息学/Code/first/hir.py", line 11, in do_something
    bar = 1 / 0
ZeroDivisionError: division by zero
'''
```

**步骤分析:**
 –> 实例化`Sample`类，执行类方法`__enter__()`，返回值`self`也就是实例自己赋值给`sample`。即`sample`是`Sample`的一个实例(对象);
 –>执行`with-block`码块: 实例`sample`调用方法`do_something()`;
 –>执行`do_something()`第一行 `bar = 1 / 0`，发现`ZeroDivisionError`，直接结束`with-block`代码块运行
 –>执行类方法`__exit__()`，带入`ZeroDivisionError`的错误信息值，也就是`type`,`value`, `trace`，并打印它们。

如果有多个项目，则会视作存在多个 [`with`](https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with) 语句嵌套来处理多个上下文管理器: （ https://docs.python.org/zh-cn/3/reference/compound_stmts.html#the-with-statement ）

```csharp
with A() as a, B() as b:
    SUITE
在语义上等价于:
with A() as a:
    with B() as b:
        SUITE
```

在 3.1 版更改: 支持多个上下文表达式。

参见：[**PEP 343**](https://www.python.org/dev/peps/pep-0343) - "with" 语句。Python [`with`](https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with) 语句的规范描述、背景和示例。

 

## 2. 自定义上下文管理器

开发人员可以自定义支持上下文管理协议的类。自定义的上下文管理器要实现上下文管理协议所需要的 **enter**() 和 **exit**() 两个方法：

- **context\*manager.\*__enter__()** ：进入上下文管理器的运行时上下文，在语句体执行前调用。with 语句将该方法的返回值赋值给 as 子句中的 target，如果指定了 as 子句的话
- **context\*manager.\*__exit__(exc_type, exc_value, exc_traceback)** ：退出与上下文管理器相关的运行时上下文，返回一个布尔值表示是否对发生的异常进行处理。参数表示引起退出操作的异常，如果退出时没有发生异常，则3个参数都为None。如果发生异常时，返回True 表示不处理异常，否则会在退出该方法后重新抛出异常以由 with 语句之外的代码逻辑进行处理。如果该方法内部产生异常，则会取代由  statement-body 中语句产生的异常。要处理异常时，不要显示重新抛出异常，即不能重新抛出通过参数传递进来的异常，只需要将返回值设置为  False 就可以了。之后，上下文管理代码会检测是否 **__exit__()** 失败来处理异常

下面通过一个简单的示例来演示如何构建自定义的上下文管理器。

注意，上下文管理器必须同时提供 **__enter__**() 和 **__exit__**() 方法的定义，缺少任何一个都会导致 AttributeError；with 语句会先检查是否提供了 **__exit__**() 方法，然后检查是否定义了 **__enter__**() 方法。

```python
# coding = utf-8
class DBManager(object):
    def __init__(self):
        pass
    
    def __enter__(self):
        print('__enter__')
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print('__exit__')
        return True

def getInstance():
        return DBManager()

with getInstance() as dbManagerIns:
    print('with demo')

'''
运行结果:
__enter__
with demo
__exit__
'''
```

**with 后面必须跟一个上下文管理器，如果使用了 as，则是把上下文管理器的 __enter__() 方法的返回值赋值给 target，target 可以是单个变量，或者由 "()" 括起来的元组（不能是仅仅由 "," 分隔的变量列表，必须加 "()"）**

结果分析：当我们使用 with 的时候，__enter__方法被调用，并且将返回值赋值给 as 后面的变量，并且在退出 with 的时候自动执行 __exit__ 方法

```python
class With_work(object):
    def __enter__(self):
        """进入with语句的时候被调用"""
        print('enter called')
        return "xxt"

    def __exit__(self, exc_type, exc_val, exc_tb):
        """离开with的时候被with调用"""
        print('exit called')

with With_work() as as_f:
    print(f'as_f : {as_f}')
    print('hello with')

'''
enter called
as_f : xxt
hello with
exit called
'''
```

示例 2：

自定义支持 with 语句的对象 

```python
class DummyResource:
    def __init__(self, tag):
        self.tag = tag
        print(f'Resource [{tag}]')
        
    def __enter__(self):
        print(f'[Enter {self.tag}]: Allocate resource.')
        return self  # 可以返回不同的对象

    def __exit__(self, exc_type, exc_value, exc_tb):
        """
        :param exc_type: 错误的类型
        :param exc_value: 错误类型对应的值 
        :param exc_tb: 代码中错误发生的位置 
        :return:
        """
        print(f'[Exit {self.tag}]: Free resource.')
        if exc_tb is None:
            print(f'[Exit {self.tag}]: Exited without exception.')
        else:
            print(f'[Exit {self.tag}]: Exited with exception raised.')
            return False  # 可以省略，缺省的None也是被看做是False

# 第一个 with 语句
num = 50
print('*' * num)

with DummyResource('First'):
    print('[with-body] Run without exceptions.')
print('*' * num)
# 第二个 with 语句
print('*' * num)

with DummyResource('second'):
    print('[with-body] Run with exception.')
    raise Exception
    print('[with-body] Run with exception. Failed to finish statement-body!')
print('*' * num)

# 嵌套 with 语句
print('*' * num)

with DummyResource('Normal'):
    print('[with-body] Run without exceptions.')

    with DummyResource('With-Exception'):
        print('[with-body] Run with exception.')
        raise Exception
        print('[with-body] Run with exception. Failed to finish statement-body!')
print('*' * num)
```

DummyResource 中的 **__enter__**() 返回的是自身的引用，这个引用可以赋值给 as 子句中的 target 变量；返回值的类型可以根据实际需要设置为不同的类型，不必是上下文管理器对象本身。

**__exit__**() 方法中对变量 exc*tb 进行检测，如果不为 None，表示发生了异常，返回 False 表示需要由外部代码逻辑对异常进行处理；注意到如果没有发生异常，缺省的返回值为 None，在布尔环境中也是被看做 False，但是由于没有异常发生，***__exit__**() 的三个参数都为 None，上下文管理代码可以检测这种情况，做正常处理。

执行结果：

```markdown
**************************************************
Resource [First]
[Enter First]: Allocate resource.
[with-body] Run without exceptions.
[Exit First]: Free resource.
[Exit First]: Exited without exception.
**************************************************
**************************************************
Resource [second]
[Enter second]: Allocate resource.
[with-body] Run with exception.
[Exit second]: Free resource.
[Exit second]: Exited with exception raised.
Traceback (most recent call last):
  File "temp.py", line 30, in <module>
    raise Exception
Exception
```

第1个 with 语句执行结果：可以看到，正常执行时会先执行完语句体 with-body，然后执行 **__exit__**() 方法释放资源。

第2个 with 语句的执行结果：可以看到，with-body 中发生异常时with-body 并没有执行完，但资源会保证被释放掉，同时产生的异常由 with 语句之外的代码逻辑来捕获处理。

因为第2个with语句发生异常，所以 嵌套 with 语句没有执行。。。

## 3. 自动关闭文件

我们都知道打开文件有两种方法:

- f = open()
- with open() as f:

这两种方法的区别就是第一种方法需要我们自己关闭文件；f.close()，而第二种方法不需要我们自己关闭文件，无论是否出现异常，with都会自动帮助我们关闭文件，这是为什么呢？

我们先自定义一个类，用with来打开它：

```python
class Foo(object):

    def __enter__(self):
        print("enter called")

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("exit called")
        print("exc_type :%s" % exc_type)
        print("exc_val :%s" % exc_val)
        print("exc_tb :%s" % exc_tb)

with Foo() as foo:
    print("hello python")
    a = 1 / 0
    print("hello end")

'''
enter called
Traceback (most recent call last):
hello python
exit called
exc_type :<class 'ZeroDivisionError'>
exc_val :division by zero
 File "F:/workspaces/python_workspaces/flask_study/with.py", line 25, in <module>
  a = 1/0
exc_tb :<traceback object at 0x0000023C4EDBB9C8>
ZeroDivisionError: division by zero
Process finished with exit code 1
'''
```

执行结果的输入顺序，分析如下：

当我们 with Foo() as foo: 时，此时会执行 __enter__方法，然后进入执行体，也就是：

```erlang
print("hello python")
a = 1/0
print("hello end")
```

语句，但是在 a=1/0 出现了异常，with将会中止，此时就执行__exit__方法，就算不出现异常，当执行体被执行完毕之后，__exit__方法仍然被执行一次。

我们回到 with open("file")as f: 不用关闭文件的原因就是在 __exit__ 方法中，存在关闭文件的操作，所以不用我们手工关闭文件，with已将为我们做好了这个操作，这就可以理解了。

## 4. contextlib 模块 

contextlib --- 为 with语句上下文提供的工具：https://docs.python.org/zh-cn/3/library/contextlib.html#contextlib.asynccontextmanager

contextlib 模块提供了3个对象，使用这些对象，可以对已有的生成器函数或者对象进行包装，加入对上下文管理协议的支持，避免了专门编写上下文管理器来支持 with 语句。

- 装饰器 contextmanager
- 函数 nested 
- 上下文管理器 closing

### 装饰器 contextmanager

contextmanager 用于对生成器函数进行装饰，生成器函数被装饰以后，返回的是一个上下文管理器，其 **enter**() 和 **exit**() 方法由 contextmanager 负责提供，而不再是之前的迭代子。被装饰的生成器函数只能产生一个值，否则会导致异常 RuntimeError；产生的值会赋值给 as 子句中的 target，如果使用了 as 子句的话。下面看一个简单的例子。

```python
from contextlib import contextmanager

@contextmanager

def demo():
    print('[Allocate resources]')
    print('Code before yield-statement executes in __enter__')
    yield '*** contextmanager demo ***'
    print('Code after yield-statement executes in __exit__')
    print('[Free resources]')


with demo() as value:
    print(f'Assigned Value: {value}')

'''
[Allocate resources]
Code before yield-statement executes in __enter__
Assigned Value: *** contextmanager demo ***
Code after yield-statement executes in __exit__
[Free resources]
'''
```

可以看到，生成器函数中 yield 之前的语句在 **enter**() 方法中执行，yield 之后的语句在 **exit**() 中执行，而 yield 产生的值赋给了 as 子句中的 value 变量。

需要注意的是，contextmanager 只是省略了 **enter**() / **exit**() 的编写，但并不负责实现资源的”获取”和”清理”工作；”获取”操作需要定义在 yield 语句之前，”清理”操作需要定义 yield 语句之后，这样 with 语句在执行 **enter**() / **exit**() 方法时会执行这些语句以获取/释放资源，即生成器函数中需要实现必要的逻辑控制，包括资源访问出现错误时抛出适当的异常。

 

### 函数 nested

nested 可以将多个上下文管理器组织在一起，避免使用嵌套 with 语句。

```csharp
nested 语法
with nested(A(), B(), C()) as (X, Y, Z):
    # with-body code here

类似于：
with A() as X:
    with B() as Y:
        with C() as Z:
            # with-body code here
需要注意的是，发生异常后，如果某个上下文管理器的 exit() 方法对异常处理返回 False，则更外层的上下文管理器不会监测到异常。
```

### 上下文管理器 closing

closing 的实现如下：

```python
class closing(object):
    # help doc here
    def __init__(self, thing):
        self.thing = thing
    def __enter__(self):
        return self.thing
    def __exit__(self, *exc_info):
        self.thing.close()
```

上下文管理器会将包装的对象赋值给 as 子句的 target 变量，同时保证打开的对象在 with-body  执行完后会关闭掉。closing 上下文管理器包装起来的对象必须提供 close() 方法的定义，否则执行时会报 AttributeError  错误。

自定义支持 closing 的对象

```python
from contextlib import closing

class ClosingDemo(object):
    def __init__(self):
        self.acquire()

    def acquire(self):
        print('Acquire resources.')

    def free(self):
        print('Clean up any resources acquired.')

    def close(self):
        self.free()

with closing(ClosingDemo()):
    print('Using resources')

'''
Acquire resources.
Using resources
Clean up any resources acquired.
'''
```

closing 适用于提供了 close() 实现的对象，比如网络连接、数据库连接等，也可以在自定义类时通过接口 close() 来执行所需要的资源”清理”工作。

## 5. 总结

with 是对 try…expect…finally 语法的一种简化，并且提供了对于异常非常好的处理方式。在Python有2种方式来实现  with 语法：class-based 和 decorator-based，2种方式在原理上是等价的，可以根据具体场景自己选择。

with 最初起源于一种block…as…的语法，但是这种语法被很多人所唾弃，最后诞生了with，关于这段历史依然可以去参考PEP-343和PEP-340

with 主要用在：自定义上下文管理器来对软件系统中的资源进行管理，比如数据库连接、共享资源的访问控制等。文件操作。进程线程之间互斥对象。支持上下文其他对象



# Python切片操作

> 列表、元祖、字符串可迭代对象都支持切片操作
>
> 切片返回结果类型和切片类型一致，返回的是切片对象的子序列
>
> 切片生成的子序列元素是源版的拷贝，因此切片是一种浅拷贝

## 1、索引方式

Python中切片的索引方式分为：

- 正索引 
- 负索引

|        |      |      |      |      |      |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 正索引 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| 负索引 | -10  | -9   | -8   | -7   | -6   | -5   | -4   | -3   | -2   | -1   |
| 值     | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |

## 2、切片语法格式

```python
object[start_index:end_index:step]
```

1. step：绝对值大小决定了切取数据的步长，正负号决定了切取方向，正表示“从左往右”，负表示“从右往左”
2. start_index：表示起始索引（包含索引本身）。省略时表示从端点开始，至于从起点开始还是终点开始，由step的正负号决定
3. end_index：表示终止索引（不包含索引本身）。